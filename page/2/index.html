<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Times New Roman:300,300italic,400,400italic,700,700italic|Courier New:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="学海无涯">
<meta name="keywords" content="coding game">
<meta property="og:type" content="website">
<meta property="og:title" content="B.C. Studio">
<meta property="og:url" content="http://linjinxin.com/page/2/index.html">
<meta property="og:site_name" content="B.C. Studio">
<meta property="og:description" content="学海无涯">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="B.C. Studio">
<meta name="twitter:description" content="学海无涯">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://linjinxin.com/page/2/"/>





  <title>B.C. Studio - Learning the ocean without boundaries</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">B.C. Studio</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Learning the ocean without boundaries</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linjinxin.com/2019/09/20/opengl/point/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林锦新">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="B.C. Studio">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/20/opengl/point/" itemprop="url">【OpenGL】绘制一个点</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-20T15:53:21+08:00">
                2019-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index">
                    <span itemprop="name">OpenGL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/09/20/opengl/point/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/09/20/opengl/point/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用-glew"><a href="#使用-glew" class="headerlink" title="使用 glew"></a>使用 glew</h1><p>glew 全称是 <code>OpengGL Extension Wrangler Library</code>，它能够帮忙解决 OpengGL 不断扩展的问题。初始化 glew 之后，它将查询系统上所有可用的扩展功能并自动加载它们，然后提供一个头文件作为接口，我们直接通过头文件就可以使用这些扩展功能。</p>
<p><a href="http://glew.sourceforge.net/" target="_blank" rel="noopener">下载 glew</a>，下载之后进行解压，得到的目录结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|-glew-2.1.0</span><br><span class="line">    |-bin</span><br><span class="line">    |-lib</span><br><span class="line">    |-include</span><br><span class="line">    |-doc</span><br></pre></td></tr></table></figure>
<p>接下来开始配置环境，配置的方式有两种，第一种方式跟配置 glut 一样，系统级的配置，配置之后所有的 OpenGL 项目都不需要配置，</p>
<ul>
<li>第一步，把 include 目录下的头文件放在 <code>%VISUAL_STUDIO%\VC\include\gl</code> 目录下；</li>
<li>第二步，把 lib 目录下的 lib 文件放在 <code>%VISUAL_STUDIO%\VC\lib</code> 目录下，然后在项目属性的 <em>链接器</em> –&gt; <em>输入</em> 添加相应库的引用；<blockquote>
<p>如果要创建 64 位程序，则要把 lib 文件放在 <code>%VISUAL_STUDIO%\VC\lib\amd64</code> 目录下。</p>
</blockquote>
</li>
<li>第三步，把 bin 目录下的 dll 文件放在系统目录下。<blockquote>
<p>32 位系统直接放在 <code>System32</code> 目录下；64 位系统如果要创建 64 位程序也放在 <code>System32</code> 目录下，如果要创建 32 位程序则要放在 <code>SysWOW64</code> 目录下。</p>
</blockquote>
</li>
</ul>
<p>这是系统级的配置，一次配置对所有项目都生效，这种方式虽然能够一劳永逸，但过多地把库文件拷到系统路径也不好，因此还有第二种方式，即给每个创建的项目单独配置环境，</p>
<ul>
<li>把头文件放在 <code>$PROJECT_ROOT%\include\GL</code> 目录下，然后在项目属性的 <em>C/C++</em> –&gt; <em>附加包含目录</em> 中添加 <code>.\include</code>；</li>
<li>把静态库 lib 文件放在 <code>$PROJECT_ROOT%\lib</code> 目录下，然后在项目属性的 <em>链接器</em> –&gt; <em>常规</em> –&gt; <em>附加库目录</em> 中添加 <code>.\lib</code>，在 <em>链接器</em> –&gt; <em>输入</em> 中添加相应库的引用；<blockquote>
<p>如果要同时编译 32 位程序和 64 位程序，可以在项目下建立 <code>.\lib\win32</code> 和 <code>.\lib\x64</code> 两个目录，然后配置 32 位程序链接第一个目录，配置 64 位程序链接第二个目录。</p>
</blockquote>
</li>
<li>把动态库 dll 文件放在可执行程序 exe 同级目录下。</li>
</ul>
<p>如果一个项目想同时编译 32 位和 64 位，则可以分别把 32 位的 lib 文件和 64 位的 lib 文件放在 .\lib\win32 和 .\lib\x64 目录下，然后分别修改附加库目录，再把相应的 dll 文件拷到编译后的 32 位程序和 64 位程序目录下。</p>
<p>关于 VS 配置的详细内容，可参考 <a href="../../coder/vs">Visual Studio 环境配置</a>。</p>
<h1 id="GL-context"><a href="#GL-context" class="headerlink" title="GL context"></a>GL context</h1><p>在开始绘制图形之前，我们必须先了解 GL context 和 GL objects 这两个重要概念，<a href="https://www.khronos.org/opengl/wiki/Main_Page" target="_blank" rel="noopener">参考文档</a>。</p>
<p>上一篇文章讲到 OpenGL 渲染是基于状态(state)的。OpenGL context 是一个重要的概念，只有创建了 context，OpenGL 才存在，context 一旦被销毁了，OpenGL 就不存在了。context 存储了一个 OpenGL 实例的所有状态，类似于一个程序开辟的所有内存空间。context 可以看作进程在操作系统中的一个执行过程，一个进程可以创建多个 context，每一个 context 代表一个可视面，就像一个应用程序的一个界面一样。</p>
<p>简单来讲，context 保存了一个 OpenGL 实例的所有状态，在使用 OpenGL 之前必须先创建一个 context。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *GL_version=(<span class="keyword">char</span> *)glGetString(GL_VERSION);</span><br><span class="line">    <span class="keyword">char</span> *GL_vendor=(<span class="keyword">char</span> *)glGetString(GL_VENDOR);</span><br><span class="line">    <span class="keyword">char</span> *GL_renderer=(<span class="keyword">char</span> *)glGetString(GL_RENDERER);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是想获取一些系统信息，但得到的结果却全是空，这里因为此时还没有创建 context，OpenGL 相当于不存在。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	glutInit(&amp;argc, argv);</span><br><span class="line">	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);</span><br><span class="line"></span><br><span class="line">	glutInitWindowSize(<span class="number">400</span>, <span class="number">400</span>);</span><br><span class="line">	glutInitWindowPosition(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">	glutCreateWindow(<span class="string">"Create Dot"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取 OpenGL 版本号</span></span><br><span class="line">	<span class="keyword">char</span> *GL_version = (<span class="keyword">char</span> *)glGetString(GL_VERSION);</span><br><span class="line">	<span class="comment">//获取本机提供 GL 支持的公司</span></span><br><span class="line">	<span class="keyword">char</span> *GL_vendor = (<span class="keyword">char</span> *)glGetString(GL_VENDOR);</span><br><span class="line">	<span class="comment">//获取渲染器的名称</span></span><br><span class="line">	<span class="keyword">char</span> *GL_renderer = (<span class="keyword">char</span> *)glGetString(GL_RENDERER);</span><br><span class="line">	<span class="comment">//获取着色器的版本号</span></span><br><span class="line">	<span class="keyword">char</span>* GL_shader_version = (<span class="keyword">char</span>*)glGetString(GL_SHADING_LANGUAGE_VERSION);</span><br><span class="line">	<span class="comment">//获取本机硬件支持的最大顶点属性数</span></span><br><span class="line">	GLint max_vertex_attrib;</span><br><span class="line">	glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;max_vertex_attrib);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以正常获取信息了，因为 <code>glutCreateWindow</code> 创建一个窗口的同时就已经创建了一个 OpenGL context。</p>
<h1 id="GL-objects"><a href="#GL-objects" class="headerlink" title="GL objects"></a>GL objects</h1><p>再重申一遍，OpenGL 基于状态来渲染，可以说 OpenGL 被定义成“状态机”，所有的 API 都是修改状态、查询状态或者使用状态来渲染。GL Object 是一些状态的集合，这点看起来跟 GL Context 有点像，也可以这样类比，但要知道 object 和 context 的 state 是相互独立的，context 有一套状态，每个 object 也会有自己的一些状态。只有把 object 绑定到 context 上，它的状态都会映射到 context 上，绑定之后修改 context 的状态，object 也会受影响；相反基于 context 状态的函数也可以使用 object 的状态。</p>
<p>对象可以分成两大类，<strong>regular objects</strong> 和 <strong>container objects</strong>。<br>regular object 包括 <em>Buffer Objects，Query Objects，Renderbuffer Objects，Sampler Objects，Texture Objects</em>。<br>container objects 包括 <em>Vertex Array Objects，Framebuffer Objects，Program Pipeline Objects，Transform Feedback Objects</em>。</p>
<h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>使用 <code>glGen*</code> 函数给对象生成一个名字，就是创建对象了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> glGen*(GLsizei n, GLuint *objects);</span><br></pre></td></tr></table></figure>
<ul>
<li>@param n 表示要创建的对象个数</li>
<li>@param objects 表示对象的地址，如果只创建一个对象，则传这个对象的地址，如果创建多个，则传数组的首地址</li>
</ul>
<p>对象创建成功会生成对象的名字，也就是对象的唯一 ID，这是一个 32 位无符号整型，用于标识这个对象。另外，整数 0 这个名字用于特殊对象，系统给对象起名时是从 1 开始的。</p>
<h2 id="对象销毁"><a href="#对象销毁" class="headerlink" title="对象销毁"></a>对象销毁</h2><p>使用 <code>glDelete*</code> 可以销毁一个或多个对象，参数同创建对象一样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> glDelete*(GLsizei n, <span class="keyword">const</span> GLuint *objects);</span><br></pre></td></tr></table></figure>
<p>关于对象销毁有几点要注意的</p>
<ul>
<li>如果对象已经绑定到 context ，则对象销毁后会自动解绑；但如果对象附加到另一个对象上，则这种附加关系不会解除</li>
<li>对象被 delete 之后并不会立即删除，它的名字还可以使用，但请不要用</li>
</ul>
<h2 id="对象绑定"><a href="#对象绑定" class="headerlink" title="对象绑定"></a>对象绑定</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> glBind*(GLenum target, GLuint object);</span><br></pre></td></tr></table></figure>
<p>这个函数用于把对象绑定到 context。OpenGL 是无法直接对象的，只能操作 context，所以必须先把对象绑定到 context，绑定的时候会指定一个类型，有些对象可以绑定为多个类型，比如一个 buffer obejct 可以绑定为 array buffer，index buffer，pixel buffer，transform buffer 或者其它。</p>
<ul>
<li>@param target 指明了对象要绑定的类型</li>
<li>@param object 要绑定的对象</li>
</ul>
<h1 id="VAO-amp-amp-VBO"><a href="#VAO-amp-amp-VBO" class="headerlink" title="VAO &amp;&amp; VBO"></a>VAO &amp;&amp; VBO</h1><p>我们知道了 OpenGL 是一个状态机，使用 object 来保存数据和状态，通过绑定到 context，将 object 的状态和 context 的状态关联起来，然后使用 context 的状态进行渲染。接下来就着手准备绘制一个点，这里需要用到两个对象 VBO 和 VAO。</p>
<p>VAO 即 Vertex Array Object，它保存了所有顶点数据的状态，并没有保存顶点数据，而是保存了顶点数据的格式和所需 buffer 对象的引用。每一个状态属性都是可以开启和关闭的，使用下面两个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glEnableVertexAttribArray</span><span class="params">(GLuint index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glDisableVertexAttribArray</span><span class="params">(GLuint index)</span></span>;</span><br></pre></td></tr></table></figure>
<p>VBO，即 Vertex Buffer Object，在缓存区保存的就是顶点数据了。为了让 VAO 能使用 VBO 的数据，我们需要告诉 OpenGL，编号为 index 属性使用当前绑定到 GL_ARRAY_BUFFER 的 VBO</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(index, size, type, normalized, stride, pointer);</span><br></pre></td></tr></table></figure>
<p>index 是第几个属性，像顶点的第 0 个属性就是位置；size 指定构成属性的分量个数，像顶点位置由 x,y,z 三个分量组成，所以 size=3；type 指定属性值的类型，像顶点位置为 GL_FLOAT；normalized 指属性在管线中使用之前是否需要被规范化；stride 指两个相同属性值之间间隔的字节数，只有一个属性时间隔为 0；pointer 指存储数据的偏移值，同样只有一个属性时偏移值为 0。</p>
<h1 id="绘制一个点"><a href="#绘制一个点" class="headerlink" title="绘制一个点"></a>绘制一个点</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gl/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gl/glut.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math3d.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renderPerFrame</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	glutInit(&amp;argc, argv);</span><br><span class="line">	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);</span><br><span class="line"></span><br><span class="line">	glutInitWindowSize(<span class="number">400</span>, <span class="number">400</span>);</span><br><span class="line">	glutInitWindowPosition(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">	glutCreateWindow(<span class="string">"Create Dot"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *GL_version = (<span class="keyword">char</span> *)glGetString(GL_VERSION);</span><br><span class="line">	<span class="keyword">char</span> *GL_vendor = (<span class="keyword">char</span> *)glGetString(GL_VENDOR);</span><br><span class="line">	<span class="keyword">char</span> *GL_renderer = (<span class="keyword">char</span> *)glGetString(GL_RENDERER);</span><br><span class="line"></span><br><span class="line">	GLenum res = glewInit();</span><br><span class="line">	<span class="keyword">if</span> (GLEW_OK != res)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"glewInit failed: "</span> &lt;&lt; glewGetErrorString(res) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		system(<span class="string">"pause"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	init();</span><br><span class="line"></span><br><span class="line">	glutDisplayFunc(renderPerFrame);</span><br><span class="line">	glClearColor(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">	glutMainLoop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建 buffer 对象</span></span><br><span class="line">	GLuint VBO;</span><br><span class="line">	glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//绑定 buffer 对象</span></span><br><span class="line">	glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义数据</span></span><br><span class="line">	M3DVector3f vertices[<span class="number">1</span>];</span><br><span class="line">	vertices[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;</span><br><span class="line">	vertices[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;</span><br><span class="line">	vertices[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0.0f</span>;</span><br><span class="line">	<span class="comment">//填充 buffer 的值</span></span><br><span class="line">	glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renderPerFrame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//开启顶点属性</span></span><br><span class="line">	glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//指定属性使用的 buffer</span></span><br><span class="line">	glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//绘制顶点 </span></span><br><span class="line">	glDrawArrays(GL_POINTS, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//关闭顶点属性</span></span><br><span class="line">	glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	glutSwapBuffers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下这个过程：</p>
<p>首先，创建顶点缓冲对象，即 VBO；然后将顶点缓冲对象绑定到 context；最后给顶点缓冲对象赋顶点数据。</p>
<p>经过上面三步之后，在 context 中就已经有了一个顶点缓冲对象，这个对象保存了顶点数据。接下来就是在主回调函数中取顶点数据进行绘制，这里使用的是固定管线，所以不用 VAO，后面主要使用可编程管线。</p>
<p>绘制的时候是基于状态的，要绘制顶点，必须知道每个状态属性从哪里取数据，即把顶点对象(VAO)和顶点缓冲对象(VBO)关联起来。首先，要开启顶点对象的某个属性；然后指定该属性使用的 buffer 对象；然后开始绘制；最后关闭顶点对象属性。</p>
<p><img src="http://img.blog.csdn.net/20170817110614363?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGluZ3hpbm1hbm9uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="绘制一个点"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linjinxin.com/2019/09/10/coder/vs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林锦新">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="B.C. Studio">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/10/coder/vs/" itemprop="url">Visual Studio 环境配置</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-10T18:05:35+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT-日常/" itemprop="url" rel="index">
                    <span itemprop="name">IT 日常</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/09/10/coder/vs/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/09/10/coder/vs/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="链接库"><a href="#链接库" class="headerlink" title="链接库"></a>链接库</h1><p>在 Windows 上开发 C++ 程序，需要 <strong>头文件</strong> 和 <strong>链接库</strong>，头文件大家都很熟，就是包含函数定义的 <code>.h</code> 文件，链接库就是编译好的代码库，供其它程序使用，分为 <strong>动态链接库</strong> 和 <strong>静态链接库</strong>。关于动态链接库和静态链接库的区别，简单来说，就是下面几点</p>
<ol>
<li>静态链接库把所有指令都编译到 <code>.lib</code> 文件中。使用时要把 lib 文件和头文件包含到项目中，生成项目时地把静态链接库的所有指令链接到应用程序 exe 中去；因此应用程序会比较大，但不需要其它库的支持，单独一个 exe 文件就能执行；</li>
<li>动态链接库把所有指令都编译到 <code>.dll</code> 文件中去，另外还会生成一个导入动态库的 lib 文件，这个文件只定义了 dll 文件中哪个指令可以使用，并不包含实际的指令内容，使用时要把 lib 文件和头文件包含到项目中，生成项目时不会把指令链接到 exe 文件中，而是在执行时动态从 dll 文件中加载，因此应用程序会比较小，但必须把 dll 文件放在可执行文件所在目录或程序能找到的系统目录；</li>
<li>lib 文件有两种，一种是静态链接库本身，它包含了所有编译后的指令，文件比较大；另一种是动态链接库的导入库，它只声明了动态库中哪些有哪些导出的指令，不包含实际内容，文件比较小。</li>
</ol>
<p>关于动态链接库和静态链接库更多的细节，可参考 <a href="http://www.cnblogs.com/dongzhiquan/archive/2010/07/22/1994587.html" target="_blank" rel="noopener">动态链接库&amp;静态链接库</a>。</p>
<ul>
<li>使用动态链接库：<strong>头文件 <code>.h</code>，库文件 <code>.dll</code>，导入库文件 <code>.lib</code></strong>；</li>
<li>动态链接库：<strong>头文件 <code>.h</code>，库文件 <code>.lib</code></strong>。</li>
</ul>
<h1 id="C-配置"><a href="#C-配置" class="headerlink" title="C++ 配置"></a>C++ 配置</h1><h2 id="附加包含目录"><a href="#附加包含目录" class="headerlink" title="附加包含目录"></a>附加包含目录</h2><p><code>附加包含目录</code> 存放项目需要用到的额外头文件，在代码中包含一个不属于项目本身的头文件时(一般会写 <code>#include &lt;xxx.h&gt;</code>，而包含项目内的头文件则写 <code>#include &quot;xxx.h&quot;</code>)，VS 会去 <code>附加包含目录</code> 查找有没有这个头文件，如果找不到则会报语法错误。</p>
<p>VS 默认会有一个 <code>附加包含目录</code>，位于 VS 安装目录下，所有 C++ 项目都会默认包含这个目录，所以如果我们把头文件放这个目录下，则所有的项目都无需再另外配置，这种方式暂且称之为 <strong>系统级配置</strong>；另外的方式就是为每个程序单独那个目录存放头文件，然后手动把这个目录包含进来，这种方式暂且称之为 <strong>程序级配置</strong>。</p>
<h3 id="系统级配置"><a href="#系统级配置" class="headerlink" title="系统级配置"></a>系统级配置</h3><p>这种方式很简单，只需要把头文件放在系统定义的附加包含目录 <code>%VS_ROOT%\VC\include</code> 中去即可，可建子目录存放，然后使用的时候加上子目录即可，比如 <code>#include &lt;gl/glew.h&gt;</code>。</p>
<h3 id="程序级配置"><a href="#程序级配置" class="headerlink" title="程序级配置"></a>程序级配置</h3><p>随便找个目录存放头文件，但遵循规范一般都是在工程目录下建个 <code>include</code> 目录，然后打开 <em>项目属性页</em>，在 <em>配置属性 –&gt; C/C++ –&gt; 常规 –&gt; 附加包含目录</em> 中添加我们新建的目录即可，可使用绝对路径和相对路径，推荐使用相对路径，方便项目移植。相对路径是相对于项目文件 <code>xxx.vcxproj</code> 的路径，如果 <code>include</code> 目录和项目文件同层级，则使用 <code>.\include</code>，如果在项目文件上一层，比如多个项目使用同一个头文件库，通常会这样放，则使用 <code>..\include</code>。</p>
<p><img src="/image/coder/vs/include.png" alt="include"></p>
<p>上图中的 <code>%(AdditionalIncludeDiretories)</code> 就是指系统定义的附加包含目录，VS 自动加上的，即使你把它删了也没关系，VS 还是会找到 <code>%VS_ROOT%\VC\include</code> 这个目录。</p>
<h2 id="附加库目录"><a href="#附加库目录" class="headerlink" title="附加库目录"></a>附加库目录</h2><p>库文件在链接的时候使用，如果使用的是静态链接库，则是库文件本身，如果是动态链接库，则是导入库文件，即无论使用哪种库，需要包含的都是 <code>.lib</code> 文件。这些 <code>.lib</code> 文件统一放在 <code>附加库目录</code> 下，和头文件一样，VS 在安装目录下有一个系统的 <code>附加库目录</code>，所有 C++ 项目都会包含这个库目录。</p>
<h3 id="系统级配置-1"><a href="#系统级配置-1" class="headerlink" title="系统级配置"></a>系统级配置</h3><p>和头文件不同，库文件有 32 位和 64 位之分，如果是 32 位库文件则放在 <code>%VS_ROOT%\VC\lib</code> 目录下，如果是 64 位库文件则放在 <code>%VS_ROOT\VC\lib\amd64</code> 目录下。</p>
<h3 id="程序级配置-1"><a href="#程序级配置-1" class="headerlink" title="程序级配置"></a>程序级配置</h3><p>同样找个目录存放库文件，一般在工程目录下建个 <code>lib</code> 目录，然后打开 <em>项目属性页</em>，在 <em>配置属性 –&gt; 链接器 –&gt; 常规 –&gt; 附加库目录</em> 添加新建的目录即可。</p>
<p><img src="/image/coder/vs/lib-include.png" alt="lib-include"></p>
<h2 id="附加依赖项"><a href="#附加依赖项" class="headerlink" title="附加依赖项"></a>附加依赖项</h2><p>库文件和头文件不同，头文件只要放在 <code>附加包含目录</code> 下即可，而库文件不仅要放在 <code>附加库目录</code> 下，还要告诉 VS 这个库需要链接到程序中去，VS 不会把 <code>附加库目录</code> 下所有的库都链接到程序中去，而是指明要链接的库才会进行链接，这些要链接的库称为 <code>附加依赖项</code>。VS 同样会指明一些默认的附加依赖项，这些库是 Windows 程序必须包含的库，比如 <code>kernel32.lib, user32.lib, gdi32.lib</code> 等等。这些库 VS 默认会进行链接，但如果是我们自己添加的库，即使放在系统的 <code>附加库目录</code>，VS 也不会自动链接，而是需要手动添加到 <code>附加依赖项</code>，所以附加依赖项没有系统配置和程序级配置之分。打开 <em>项目属性页</em>，在 <em>配置属性 –&gt; 链接库 –&gt; 输入 –&gt; 附加依赖项</em> 中填入要链接的库文件名即可。</p>
<p><img src="/image/coder/vs/lib.png" alt="lib"></p>
<p><code>%(AdditionalLibraryDirectories)</code> 为系统 <code>包含库目录</code>，<code>%(AdditionalDependencies)</code> 为系统 <code>附加依赖项</code>，都是 VS 默认配置的。</p>
<h2 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h2><p>如果使用的是静态链接库，则不需要这一步，因为所有库代码都被链接到可执行程序 <code>.exe</code> 中去了，单个文件即可执行。反之则需要把动态链接库 <code>.dll</code> 文件放在可执行文件能自动找到的目录下，系统目录或可执行文件所在目录。系统目录在 32 位系统和 64 位系统上有所不同，</p>
<ul>
<li><p>如果是 32 位操作系统，系统目录只有 <code>C:\\Windows\\System32</code> 这个目录，32 位系统可以运行 32 位和 16 位程序，不能运行 64 位程序，但只有 <code>System32</code> 这一个系统目录，Windows 是如何兼容这两种程序的，我们就不深入研究了，毕竟 16 位程序已经很少见了，32 位系统也将逐步淘汰。</p>
</li>
<li><p>如果是 64 位操作系统，32 位程序放在 <code>C:\\Windows\\SysWOW64</code> 目录下，而 64 位程序正常放在 <code>System32</code> 目录下。可能你会奇怪为什么是反过来的，这是为了兼容性，因为以前在 32 位系统开发的程序，引用的都是 <code>System32</code> 目录下的库，为了保持习惯，不管是新开发的 64 位程序还是由 32 位程序升级而来的 64 位程序，仍旧引用 <code>System32</code> 目录下的库，另外把 32 位程序升级到 64 位程序，也不用作任何代码修改。至于在 64 位系统运行的 32 位程序，只能屈尊引用 <code>SysWOW64</code> 目录下的库了，<code>SysWOW64</code> 的全称是 <code>32bit Windows on 64bit Windows(Windows on Windows64)</code>，即 64 位系统上的 32 位系统，由此可见其是专门为 32 位程序准备的，而不是为 64 位准备的。</p>
</li>
</ul>
<h2 id="配置平台"><a href="#配置平台" class="headerlink" title="配置平台"></a>配置平台</h2><p>VS 生成的程序分为 <code>Debug</code> 版本和 <code>Release</code> 版本，平台有 <code>Win32, x64, ARM</code> 三种。<code>ARM</code> 是指使用 <code>ARM</code> 架构的平台，Windows 平台使用的是 <code>X86</code> 架构，一般我们不会涉及到 <code>ARM</code>，所以先不管它。Win32 和 x64 则是 32 位和 64 位的区别，如果发布到 <code>Win32</code> 平台，则必须使用 32 位的库，反之必须使用 64 位的库。根据版本不同和平台不同，有 4 种组合的配置项，</p>
<ul>
<li><strong>Win32-Debug</strong></li>
<li><strong>Win32-Release</strong></li>
<li><strong>x64-Debug</strong></li>
<li><strong>x64-Release</strong></li>
</ul>
<p>在 <em>项目属性页</em> 的顶部，可选择配置版本和平台，之后我们编辑的所有配置都只对当前选中的版本和平台生效，点击 <em>配置管理器</em> 可打开配置管理器，查看所有配置项或者新建配置项。</p>
<p><img src="/image/coder/vs/platform-config.png" alt="配置版本和平台"></p>
<p>生成项目的时候也需要选择对应的发布版本和发布平台，比如 <code>Debug</code> 和 <code>Win32</code>，则本次生成会使用 <code>Win32-Debug</code> 配置项的配置。</p>
<p><img src="/image/coder/vs/platform-select.png" alt="选择版本和平台"></p>
<p>当前选中的版本和平台会在属性页显示 <code>活动</code>，如果想一次配置对所有版本和平台都生效，在属性页选择 <code>所有配置</code> 和 <code>所有平台</code> 即可。</p>
<p><img src="/image/coder/vs/all-platform.png" alt="全部配置"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linjinxin.com/2019/09/10/opengl/window1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林锦新">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="B.C. Studio">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/10/opengl/window1/" itemprop="url">【OpenGL】创建窗口（一）</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-10T17:42:47+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index">
                    <span itemprop="name">OpenGL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/09/10/opengl/window1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/09/10/opengl/window1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><em>没有开始，就永远不会有结果。</em></p>
</blockquote>
<h1 id="使用-glut"><a href="#使用-glut" class="headerlink" title="使用 glut"></a>使用 glut</h1><p>OpenGL 标准并没有提供用于创建和管理窗口的 api，各个主流操作系统都提供了支持 OpenGL 的接口，X 系统提供的接口叫做 <code>GLX</code>，Windows 提供的接口叫 <code>WGL</code>，Mac 系统提供的接口叫做 <code>CGL</code>。我们可以使用 OpenGL 的一个工具库 <code>glut</code>(opengl utility toolkit) 来管理窗口，处理事件，IO 控制和其它设备管理。  </p>
<p>glut 库比较久远，也已经停止维护了，可使用较新替代库 <code>freeglut</code>，两者的接口差不多，<a href="http://www.opengl.org/resources/libraries/glut/glutdlls37beta.zip" target="_blank" rel="noopener">下载 glut</a>，<a href="https://sourceforge.net/projects/freeglut/files/latest/download" target="_blank" rel="noopener">下载 freeglut</a>。下载之后得到五个文件，分别是头文件 <code>glut.h</code>，32 位动态链接库 <code>glut32.lib glut32.dll</code>，64 位动态链接库 <code>glut.lib, glut.dll</code>。接下来就是配置环境变量了，我使用的环境是 <code>Windows + Visual Studio</code>。</p>
<ul>
<li>第一步，把 <code>glut.h</code> 放在 Visual Studio 安装目录下的 <code>VC/include/gl</code> 目录中（默认如果没有 gl 文件夹，自己创建一个）;<blockquote>
<p>基于 VS2012 版本，不同版本位置可能不一样，比如最新的 VS2019 在 <code>VC/Tools/MSVC/14.xxx/include/gl</code> 目录。</p>
</blockquote>
</li>
<li>第二步，把 <code>glut.lib glut32.lib</code> 放在 Visual Studio 安装目录下的 <code>VC/lib</code> 目录下；</li>
<li>第三步，把 <code>glut.dll glut32.dll</code> 放在系统目录下。</li>
</ul>
<p>关于 VS 配置的详细内容，可参考 <a href="../../coder/vs">Visual Studio 环境配置</a>。</p>
<h1 id="基础库"><a href="#基础库" class="headerlink" title="基础库"></a>基础库</h1><p>OpenGL 库有三个基础库，115 个以 <code>gl</code> 开头的函数组成的 OpenGL 核心库，43 个以 <code>glu</code> 开头的函数组成的 OpenGL 实用库，31 个以 <code>aux</code> 开头的函数组成的 OpenGL 辅助库。<br>另外在 Windows 平台下，有 6 个以 <code>wgl</code> 开头的函数是 Windows 专用库函数，还有 5 个无前缀的函数是 win32api 函数。OpenGL 核心库，实用库和辅助库，Windows 操作系统默认已经配置好了，所以这些函数都可以直接使用。我们下载的工具库函数都是以 <code>glut</code> 开头，平时最常用的函数就是核心库函数 (glFunc)，实用库函数 (gluFunc) 和工具库函数 (glutFunc)。</p>
<h1 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h1><p>新建一个 C++ 空项目，控制台或 win32 都行，然后添加一个 <code>main.c</code> 源文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gl/glut.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renderPreFrame</span><span class="params">()</span></span>;</span><br><span class="line">		</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	glutInit(&amp;argc, argv);</span><br><span class="line">	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);</span><br><span class="line"></span><br><span class="line">	glutInitWindowPosition(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">	glutInitWindowSize(<span class="number">400</span>, <span class="number">400</span>);</span><br><span class="line">	glutCreateWindow(<span class="string">"First Window"</span>);</span><br><span class="line"></span><br><span class="line">	glClearColor(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">	glutDisplayFunc(renderPreFrame);</span><br><span class="line">	glutMainLoop();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renderPreFrame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">	glutSwapBuffers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后可以看到一个 400x400 的黑窗口，在距离左上角 (100,100) 的位置。</p>
<p><img src="/image/opengl/window1/win.png" alt="first window"></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ul>
<li><strong>glutInit</strong> 函数用于初始化 glut，其参数可以直接从命令行获取，从命令行启动程序可以带一些有用的参数，比如 <code>-sync</code> 可以关闭 X 异步性质，<code>-gldebug</code> 可以检查 gl 错误并独立地显示它们；</li>
<li><strong>glutInitDisplayMode</strong> 配置 glut 选项，<code>GLUT_DOUBLE</code> 设置双缓冲，即一个缓冲绘制，一个缓冲显示，默认是单缓冲 <code>GLUT_SINGLE</code>；<code>GLUT_RGBA</code> 指定大多数渲染结束位置（比如屏幕）的颜色模式；</li>
<li><strong>glutInitWindowPosition</strong> 指定窗口的位置；</li>
<li><strong>glutInitWindowSize</strong> 指定窗口大小；</li>
<li><strong>glutCreateWindow</strong> 用于创建窗口，其参数是窗口的标题；</li>
<li><strong>glutDisplayFunc</strong> 为 OpenGL 的渲染主回调函数；<blockquote>
<p>glut 提供了一些 OpenGL 与窗口系统交互的函数，glutDisplayFunc 就是其中一个，这个回调函数完成一帧中的所有渲染工作，在 glut 内部循环中不断调用，主回调函数并不会每一帧都绘制，只有窗口发生变化需要重新绘制时才会调用。</p>
</blockquote>
</li>
<li><strong>glClearColor</strong> 设置清除帧缓冲时所用的颜色，颜色有四个通道 RGBA，取值范围为 0~1 之间；<blockquote>
<p>这是一个核心库函数，在这里我们首次接触到 OpenGL 的状态(state)，渲染是一个复杂的过程，不能像普通函数一样接受几个参数就能完成功能，它需要指定 shaders，buffers 和其它各种属性，另外几个渲染操作可能使用同样的属性；因此 OpenGL 引入了 state，渲染命令只使用跟绘制顶点个数和初始化偏移值有关的个别属性，其它属性根据当前状态设置；修改状态后，它的值会一直维持不变直到下次修改。</p>
</blockquote>
</li>
<li><strong>glutMainLoop</strong> 将程序控制权交给 glut 并开启其内部循环；在这个循环中，它监听来自窗口系统的事件并通过设置的回调函数传递给 glut，最常见的就是我们设置的渲染主函数；glutMain 只会调用一次，调用之后窗口系统就在这里阻塞，将控制权移交给 glut；</li>
<li><strong>glClear</strong> 使用前面设置的颜色清除帧缓冲；在每次渲染之前，都得先将之前的帧缓冲进行清除；</li>
<li><strong>glutSwapBuffers</strong> 将前置缓冲和后置缓冲进行交换，这是双缓冲模式调用的函数，如果是单缓冲模式则使用 <strong>glFlush</strong> 函数。</li>
</ul>
<p>至此，一个使用 OpenGL 的窗口就创建完成了，这里使用了 2 个核心库函数和 8 个工具库函数，添加了一个回调函数，处理每一帧的渲染工作，在这个回调函数里添加一些绘制图元的函数，就可以在窗口中显示图形了，在下一篇文章就开始干这件事。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linjinxin.com/2019/09/07/coder/win-sofware/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林锦新">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="B.C. Studio">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/07/coder/win-sofware/" itemprop="url">Windows 常用软件汇总</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-07T10:10:21+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT-日常/" itemprop="url" rel="index">
                    <span itemprop="name">IT 日常</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/09/07/coder/win-sofware/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/09/07/coder/win-sofware/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>==题前话：软件安装路径请不要包含中文！！！！！！！！！！！！！==</p>
<h1 id="大众篇"><a href="#大众篇" class="headerlink" title="大众篇"></a>大众篇</h1><p>一般我们买一台新电脑，除了操作系统之外就只有少数系统自带的软件，当然某些组装机店家可能会帮忙装一些常用软件，但我个人很不喜欢他们预装软件（包括生产商），所以拿到一台新电脑，装上操作系统之后就得开始我们漫长的装机工作。</p>
<p>大众篇列举的是大部分电脑用户（包括电脑小白）可能需要的一些软件。</p>
<h2 id="一个顺手的输入法"><a href="#一个顺手的输入法" class="headerlink" title="一个顺手的输入法"></a>一个顺手的输入法</h2><p>首先，无论你要在电脑上做什么，都离不开打字，所以最首要的任务就是安装一个适合自己的输入法。windows 自带有拼音输入法，win10 还有自带有五笔输入法，好不好用因人而异，可以试着用，用不习惯的话还是自己去网上下载一个别的输入法吧；打开系统自带的浏览器 ie 或 edge，然后搜索下载安装（当然首先电脑要能上网）。</p>
<p>比较大众且好用的输入法应该是搜狗输入法，有拼音和五笔，根据自己爱好选择，这是搜狗五笔输入法的官网：<a href="http://wubi.sogou.com。" target="_blank" rel="noopener">http://wubi.sogou.com。</a></p>
<blockquote>
<p>大部分输入法切换输入法的快捷键是 ctrl+shift，一般除了输入法之外还会启用一个美式英文键盘，用于英文输入；如果是美式键盘+第三方输入法的方式，则直接使用 ctrl+shift 切换即可，如果是 win10 的美式键盘+微软拼音或微软五笔，则美式键盘和输入法为英文和中文两种语言，要使用 win+space 来切换语言，ctrl+shift 仍用于切换输入法。</p>
</blockquote>
<h2 id="一个好用的浏览器"><a href="#一个好用的浏览器" class="headerlink" title="一个好用的浏览器"></a>一个好用的浏览器</h2><p>毫无疑问，无论我们要装什么软件都得上网去下载，所以安装一个好用的浏览器是我们第二件要做的事。windows 自带的浏览器，ie explorer 基本没人用，新推出的 edge 虽然比 ie 好些，但也还是用不习惯。比较常用的浏览器有 chrome 和 firefox，无论是不是电脑行业从事人员，都建议使用这两个浏览器之一，至于 360，百度，QQ 之类的还是算了，除了广告多些，体积大些就没别的什么”优点“了。</p>
<p>我个人比较习惯用 chrome，下载安装之后建议首页设置为新标签页，或者搜索引擎页面，或者另一个简洁的网站地址，不要设置那些乱七八糟的导航，只会增加你电脑下到垃圾软件和病毒的可能性。这是谷歌官方的中文地址：<a href="https://www.google.cn/intl/zh-CN/chrome" target="_blank" rel="noopener">https://www.google.cn/intl/zh-CN/chrome</a>。</p>
<p>如果有谷歌账号的话，登录之后就可以在不同设备的 chrome 上同步书签、历史记录、扩展工具、外观、保存的密码等设置。</p>
<blockquote>
<p>搜索谷歌浏览器的时候可能会搜到一些和 chrome 很相似的浏览器，比如极速浏览器和双核浏览器，这是兼容 ie 内核和 chrome 内核的双核浏览器，但它们和 chrome 不是同一个东西，所以如果一台设备装的 chrome，另一台装的是另外的浏览器，那么是无法进行同步信息的，因为登录的账号不一样，我新电脑一开始装的是双核浏览器，然后登录的时候居然得微信扫码。</p>
</blockquote>
<h2 id="一个强大的播放器"><a href="#一个强大的播放器" class="headerlink" title="一个强大的播放器"></a>一个强大的播放器</h2><p>现在输入法和浏览器都有了，可以为所欲为地下载你喜欢的软件了。对大多数人来说，电脑可能更多的是娱乐作用，所以一个强大的视频播放器和音频播放器就成了当前首要任务。windows 自带的 media player 真的很差，windows 10 新推出的“电影和电视”好些，但功能仍不够强大，界面也不好看。</p>
<p>很多人喜欢下载那些网络视频提供商的客户端，比如腾讯视频、优酷视频等，这些客户端自带视频播放器的，功能也还可以，大部分视频都能解码播放。但我不喜欢这些客户端，这不是纯粹的播放器，只会显得臃肿，如果要看网络视频，一个浏览器足矣。当然，各有喜好，这里只是推荐两个好用的纯粹播放器 kmplayer 和 potplayer，这两个播放器出自同一位作者之手，功能都很强大；我只用过 potplayer，也说不好哪个好，但原作者先做的 kmplayer，接下来跳槽做的 potplayer，之后就不再维护 kmplayer 了，所以硬要说哪个好已经一目了然了。</p>
<p>这是 potplayer 官方的中文下载地址：<a href="http://potplayer.daum.net/?lang=zh_CN。" target="_blank" rel="noopener">http://potplayer.daum.net/?lang=zh_CN。</a></p>
<p>至于音频播放器，就直接下那些提供商的客户端吧，音乐不同于视频，在浏览器上直接听音乐限制太多，体验也很不爽，而且这些音乐客户端没有视频客户端那么臃肿杂乱，体验还是很不错的。比较流行的几款音乐客户端都可以，网易云音乐、QQ音乐、酷狗音乐、虾米音乐等等，网易云音乐最近比较流行，但其音乐库非常匮乏是个致命问题。</p>
<h2 id="解压缩工具"><a href="#解压缩工具" class="headerlink" title="解压缩工具"></a>解压缩工具</h2><p>其实以前 windows 预装的老牌软件 winrar 就够用了，但这东西现在好像是要收费的，每次打开都会弹一个购买的页面，虽不影响使用但也很烦，所以忍受不了就重新装一个解压软件吧，比较 7zip，其优点就是体积非常小，安装文件只有 1m，安装之后也才 5m。</p>
<p>7zip 官方下载地址：<a href="https://www.7-zip.org。" target="_blank" rel="noopener">https://www.7-zip.org。</a></p>
<h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><p>一般的下载直接在浏览器完成就行了，但有时会需要下载一些其它格式来源的内容，比如磁力链接，就得用到特别的下载工具了。国内最知名的应该是迅雷下载，但国内的软件商就一个通病，喜欢把一个软件搞得很臃肿，除了核心功能之外一堆没用的东西，一个操作不当就给你下个游戏盒子，再给你存几个“一刀999”的页游链接；另外，不花钱就别用好他们的软件，没有会员你好意思下载东西？</p>
<p>所以在用了几年迅雷之后，还是决定放弃它，其实可以替代的软件有很多，一个常用的是 Free Download Manager，简称 FDM，它支持FTP，HTTP(S)，还有 BT 下载，还支持远程控制下载，还能直接下载网上的视频，要在 chrome 上装插件，但这功能好像并不好用。</p>
<p>FDM 下载地址：<a href="https://www.freedownloadmanager.org/zh/" target="_blank" rel="noopener">https://www.freedownloadmanager.org/zh/</a>。</p>
<p>FDM 只是知名度高一些，但我用过之后觉得并不是很好用，所以推荐另一个更好用的视频下载工具，Apowersoft 公司的 Video Download Capture，中文名叫视频下载王，中文名是有点俗，但功能是真的强大。这个软件包含了迅雷所有功能，BT 下载，边下边播，还可以直接通过一个 URL 下载网上的视频，国内国外都可以，功能比 FDM 好用。另外，这个软件还带视频转换和录屏功能。</p>
<p>Video Download Capture 下载地址：<a href="https://www.apowersoft.com/video-download-capture.html" target="_blank" rel="noopener">https://www.apowersoft.com/video-download-capture.html</a>。</p>
<p>另外，如果百度云用得多的话，还是下一个百度云客户端吧。</p>
<h2 id="企鹅帝国"><a href="#企鹅帝国" class="headerlink" title="企鹅帝国"></a>企鹅帝国</h2><p>接下来就是企鹅家族的必备产品了，QQ 和 WeChat，这里推荐一下腾讯一直在推的简洁版 QQ，Tim，确实比 QQ 简洁了很多，当然开始用的时候会有些不习惯，习惯了就挺好；当然使用 QQ 会更有怀旧情怀。</p>
<h2 id="广告拦截工具"><a href="#广告拦截工具" class="headerlink" title="广告拦截工具"></a>广告拦截工具</h2><p>我们生活在一个网络发达的时代，也生活在一个广告满天飞的时代，这些广告就像垃圾一下污染着我们的上网环境，阻挡着我们正常看视频，所以一个去广告的工具就显得十分重要。我之前上大学的时候用的是 ADSafe，但后来发现它不行了，新版本已经不能去视频广告了，虽然我原来电脑装的旧版本还能工作，但网上已经找不到旧版本下载了。</p>
<p>所以这里推荐另一个软件，阿呆喵（ADM），其体积比 ADSafe 小很多，用起来也挺不错的。阿呆喵下载地址：<a href="http://www.admflt.com/" target="_blank" rel="noopener">http://www.admflt.com/</a>。</p>
<p>另外，在 chrome 安装一个 ADBlock 插件也能有效去网页广告。</p>
<h2 id="文件搜索神器"><a href="#文件搜索神器" class="headerlink" title="文件搜索神器"></a>文件搜索神器</h2><p>好了，娱乐部分介绍完了，接下来该介绍些“有用”的东西了。Linux 系统自带搜索命令，可以很容易地在整个文件系统中搜索某个文件；但 windows 没有，如果要搜索某个文件，只能先找到所有的文件夹，在进行查找，而且查找速度非常的慢。</p>
<p>这里介绍一个搜索神器，只要输入文件名就可以很快地找到其路径，只要是电脑上有的文件，都能被找到，包括隐藏文件，而且速度非常的快。这个神器就是 Everything，下载地址：<a href="https://everything.en.softonic.com/" target="_blank" rel="noopener">https://everything.en.softonic.com/</a>。</p>
<h2 id="记得常做笔记"><a href="#记得常做笔记" class="headerlink" title="记得常做笔记"></a>记得常做笔记</h2><p>学如逆水行舟，不进则退。好记性不如烂笔头。互联网时代的电脑使用者，不在电脑上记点什么似乎说不过去吧，特别是办公室人员。使用记事本来做笔记是一件特 low 的事，用 word 似乎还不错，但不是写笔记的最佳选择，因为有专门的笔记工具。较为出名的有印象笔记和有道笔记，个人推荐有道笔记，扁平化的界面感觉更好看，功能看起来也更简洁，而且能随时随地同步到远程服务器，在这个机器上写完，换个机器又可以继续写。印象笔记应该也可以同步到服务器，但印象笔记好像不支持 markdown，而有道支持，markdown 不是一个工具或软件，应该是一种规范，或者说是一种语法或语言；使用 markdown 可以非常轻松地写出排版简洁又漂亮的文章，还可以随时插入图片、引用、代码、链接等。这篇文章正是使用有道笔记+markdown 写的。</p>
<p>有道笔记下载地址：<a href="https://note.youdao.com/download.html" target="_blank" rel="noopener">https://note.youdao.com/download.html</a><br>Markdown 学习地址：<a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">https://github.com/younghz/Markdown</a></p>
<p>如果不想下载客户端的话，也可以使用网页版 <a href="https://note.youdao.com/web" target="_blank" rel="noopener">https://note.youdao.com/web</a>。</p>
<p>本文后期已从有道笔记移植到个人博客网站，所以不需要任何笔记工具了，只需要一个能编辑 markdown 文件的编辑器即可，比如非常好用的 vscode。关于如何搭建个人博客，直接网上搜索教程即可，或者参见我上一篇文章 <a href="https://linjinxin.github.io/2018/10/23/coder/hexo" target="_blank" rel="noopener">github + hexo 搭建个人博客</a>。</p>
<h2 id="文档编辑"><a href="#文档编辑" class="headerlink" title="文档编辑"></a>文档编辑</h2><p>microsoft office 或 kingsoft wps。</p>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p>有时候文档无法很好地表达我们想表达的东西，这时候使用思维导图也许能有事半功倍的效果。思维导图最常用的是 XMind，这是<a href="https://www.xmind.net/" target="_blank" rel="noopener">官方网站</a>，<a href="https://www.xmind.cn/" target="_blank" rel="noopener">中文官方网站</a>。</p>
<h2 id="截图工具"><a href="#截图工具" class="headerlink" title="截图工具"></a>截图工具</h2><p>windows 自带的截图工具其实也可以，QQ 的截图功能也挺方便的，使用快捷键 <code>Ctrl+Shift+A</code> 即可截图，但功能终究不够强大，这里再推荐两个第三方截图工具，其最大的优点是会将截图放在剪贴板中，直接显示在屏幕上，当我们切换到其它软件时截图还在，很方便查看。</p>
<p>第一个是 SETUNA，这个软件足够小巧，才 2m 不到，而且免安装，单个 exe 文件直接运行。SETUNA 官网已挂，目前只有他人维护的 <a href="https://github.com/tylearymf/SETUNA2" target="_blank" rel="noopener">github 项目</a>，这是软件的源代码，需要自己编译，如果不懂编程的可以从<a href="https://pan.baidu.com/s/1Ne_CXe5ZsxaoQClYhzknJQ" target="_blank" rel="noopener">网盘</a>下载，提取码 <code>bvct</code>。</p>
<p>第二个是 Snipaste，这个软件稍微大些，但功能也更强大，除了能让截图驻留在屏幕上，还能直接将剪贴板的图像、文本、颜色信息也转换成图片并显示在屏幕上。通过<a href="https://zh.snipaste.com/" target="_blank" rel="noopener">官网</a> 下载软件及查看教程。</p>
<p>另外，如果要制作 gif 动态图，可使用 <a href="https://gifcam.en.softonic.com/" target="_blank" rel="noopener">GifCam</a>，这个软件同样不到 2m 且名安装，单个文件运行，足够小巧方便。</p>
<h2 id="垃圾清理"><a href="#垃圾清理" class="headerlink" title="垃圾清理"></a>垃圾清理</h2><p>ccleaner 足够简洁，使用也方便，功能也足够强大，不仅能清理垃圾，修复注册表，还有磁盘分析、软件卸载等实用工具。这是<a href="https://www.ccleaner.com/ccleaner" target="_blank" rel="noopener">官网地址</a>。</p>
<h1 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h1><p>进阶篇介绍一些相对高级一些的软件或者计算机从业人员（比如码农）会用到的工具。</p>
<h2 id="文件对比工具"><a href="#文件对比工具" class="headerlink" title="文件对比工具"></a>文件对比工具</h2><p><a href="https://www.scootersoftware.com" target="_blank" rel="noopener">Beyond Compare</a> 是一款很好用的文件对比及文件夹对比工具</p>
<h2 id="Windows-远程连接"><a href="#Windows-远程连接" class="headerlink" title="Windows 远程连接"></a>Windows 远程连接</h2><h2 id="SSH-远程工具"><a href="#SSH-远程工具" class="headerlink" title="SSH 远程工具"></a>SSH 远程工具</h2><p>SSH 全称为 Secure Shell，是一种网络协议，用于计算机之间的加密登录。SSH 协议使用加密来保证客户端（本地主机）与服务端（远程主机）之间的连接安全，所有的用户认证、命令、输出和文件传输都会被加密。SSH 工作的过程如下图</p>
<p><img src="https://www.ssh.com/s/how-does-ssh-protocol-work-920x272-SWKuhzNV.png" alt="SSH"></p>
<ul>
<li>首先本地主机发送连接请求给远程主机</li>
<li>远程主机发送自己的公钥给本地主机</li>
<li>本地主机用收到的公钥加密登录密码发送给远程主机</li>
<li>远程主机收到加密后的密码之后使用自己的私钥进行解密</li>
<li>密码验证正确本地主机就连接上远程主机了</li>
</ul>
<h3 id="下载-SSH-Client"><a href="#下载-SSH-Client" class="headerlink" title="下载 SSH Client"></a>下载 SSH Client</h3><h3 id="“中间人攻击”"><a href="#“中间人攻击”" class="headerlink" title="“中间人攻击”"></a>“中间人攻击”</h3><p>SSH 是一种网络安全协议，可以防止登录信息在传输的时候被中途截获，因为登录是使用远程主机的公钥加密过的，即使被截获没有远程主机的私钥也是无法破获的。私钥顾名思义就是私有的，只有远程主机自己知道，除此之外没人知道，即使是合法的远程连接者（也就是我们的本地主机）也不会知道，否则就不是私钥了。</p>
<p>使用 SSH 协议进行远程登录，这个过程本身是安全的，但还是会有一个安全风险，就是所谓的“中间人攻击”。“中间人攻击”是指攻击者扮演远程主机与本地主机之间的中间人，使得本地主机无法正确与远程主机通信。首先，攻击者截获本地主机发送给远程主机的登录请求，然后发送伪造的公钥（它自己的公钥）给本地主机；然后，本地主机收到公钥之后并不知道是伪造的，所以把自己的密码使用公钥加密之后发送出去，攻击者再截获这个密码，使用自己的私钥进行解密，这样攻击者就得到了本地主机的密码；最后，攻击者就可以使用截获的密码与远程主机进行通信了，还可以继续与我们的本地主机进行通信，扮演无耻又无人知晓的“第三者”。</p>
<p>SSH 是怎样解决“中间人攻击”的呢？提供一个凭证，然后让本地主机自己去判断。本地主机第一次连接远程主机时，系统会提示这个远程主机的真伪无法确定，同时给出远程主机的公钥指纹；然后我们可以比对这个指纹和远程主机的指纹是否一致，一致就输入 <code>yes</code> 进行连接，不一致则说明被“中间人”攻击了，则输入 <code>no</code> 取消连接。连接成功之后会把这个远程主机的信息记录在 <code>~/.ssh/know_hosts</code> 中，之后再连接的时候就不会再检查远程主机的指纹了而是直接登录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host <span class="string">'gitlab.xxx.com (192.168.0.xxx)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is SHA256:Mu7Sxxxxxxxxxxxxxxxxx.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure>
<p>我们如何知道远程主机的公钥指纹呢？一般公开的远程主机都会在网上贴出自己的指纹，如果是我们自己的远程主机，也可以登录远程主机，然后执行指令 <code>ssh-keygen -lf /etc/ssh/ssh_host_rsa_key.pub</code> 来获取。</p>
<h3 id="口令登录"><a href="#口令登录" class="headerlink" title="口令登录"></a>口令登录</h3><p>SSH 协议主要用于远程登录，在本地主机使用 SSH Client 登录到远程主机，登录成功之后就可以在本地操作远程主机了，有点类似 windows 的远程登录。使用 SSH 进行远程登录有两种方式，一种方式是普通的口令登录，另一种是安全性更好更便捷的公钥登录。口令登录要求用户提供远程主机的用户名和密码，远程主机验证通过之后就能正常登录了，这个过程跟最开始讲的一样，使用远程主机的公钥进行加密，再使用远程主机的密钥进行解密。使用 SSH 进行远程登录的命令是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -p [portid] user@host</span><br></pre></td></tr></table></figure>
<p>SSH 连接默认的端口号是 22，如果使用默认的端口号则可以忽略不写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@host</span><br></pre></td></tr></table></figure>
<p>如果本地主机用户名和远程主机用户名一致，则用户名也可以省略不写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh host</span><br></pre></td></tr></table></figure>
<p>之后会提示输入用户密码，ip 地址，端口，用户名和密码都正确就能连接成功。</p>
<h3 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h3><p>口令登录需要本地主机提供登录的用户名（可省略）和密码。每次登录都得输入密码，有些麻烦，SSH 提供了另外一种登录方式，“公钥登录”。公钥登录与口令登录刚好相反，口令登录使用远程主机公钥进行加密，再使用远程主机私钥进行解密；而公钥登录使用本地主机私钥进行加密，再使用本地主机的公钥进行解密。首先把本地主机生成的公钥保存在远程主机上，然后本地主机请求登录的时候远程主机会发送一串随机字符串下来，本地主机收到之后使用自己的私钥进行加密发送回远程主机，远程主机收到加密后的字符串使用本地主机提供的公钥进行解密，解密之后的字符串与源字符串一致则认为用户是可信的，直接允许登录而不用再提供密码。</p>
<p>公钥登录也存在“中间人攻击”的风险，解决方案也是一样，第一次登录的时候终端会显示远程主机的公钥指纹，用户确认之后才能进行登录。</p>
<p>使用公钥登录之前要把本地主机的公钥放在远程主机上，如果本地没有密钥，则要先生成一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;ljx&quot; -f &quot;/c/Users/linjinxin/.ssh/xxserver/id_rsa&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-t</code> 参数指定密钥加密的方式，默认就是 <code>rsa</code>，可以省略不写；</li>
<li><code>-C</code> 是指定一个说明，这个说明会附加在公钥的最后，一般是写我们的用户名，如果省略不写的话则默认为 <code>用户名@电脑名</code>，比如我的就是 <code>linjinxin@LAPTOP-4NLDJKB6</code>；</li>
<li><code>-f</code> 指定私钥的存放文件名（公钥的文件名在私钥文件名后面加上.pub），也可以先不指定这个参数，在命令执行之后再指定；默认文件名为 <code>~/.ssh/id_rsa</code>，这里的 <code>~</code> 路径在 windows 上是指 <code>/c/Users/username</code>，但有时候 <code>~</code> 好像识别不了，如果识别不了就写完整路径吧。</li>
</ul>
<p>这三个参数都可以省略，则命令简写为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen</span><br></pre></td></tr></table></figure>
<p>如果文件已存在，则会提示密钥已存在，询问是否重新生成，输入 <code>y</code> 则继续，<code>n</code> 则退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">/c/Users/linjinxin/.ssh/xxserver/id_rsa already exists.</span><br><span class="line">Overwrite (y/n)? y</span><br></pre></td></tr></table></figure></p>
<p>如果前面没有指定私钥存放文件，则这里会提示输入文件名，如果不写则使用括号里的默认文件名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter file in which to save the key (/c/Users/linjinxin/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>
<p>之后会提示输入私钥的口令，这个口令是保护私钥安全的，有了这个口令之后，别人登录你的电脑也看不到私钥，除非它知道这个口令，这个口令可以为空，默认不写就为空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure>
<p>之后密钥就生成了，会在 <code>~/.ssh/xxserver</code> 目录下生成两个文件，<code>id_rsa</code> 为私钥文件，<code>id_rsa.pub</code> 为公钥文件。接下来把公钥复制到远程主机，使用命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-copy-id user@host -i ~/.ssh/xxserver/id_rsa.pub user@host</span><br></pre></td></tr></table></figure>
<p><code>-i</code> 指定要复制到远程的公钥文件，注意不能加引号，如果省略不写的话，默认会把 <code>~/.ssh</code> 目录下的所有 <code>.pub</code> 文件都复制到远程主机，所以如果本地只生成了一个密钥，则这个参数可以省略不写；如果生成了多个密钥，又只要复制一个公钥到远程的话，就必须指定要复制的公钥文件。</p>
<p><code>ssh-copy-id</code> 做的事就是先使用密码登录的方式登录到远程主机，然后把指定的本地公钥文件的内容复制到远程主机 <code>/username/.ssh/authorized_keys</code> 文件中，以追加的方式写入，所以不会覆盖掉别人添加的公钥。如果远程主机 <code>authorized_keys</code> 文件不存在，则会先创建一个再写入，整个命令等价于下面这个命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@host &apos;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&apos; &lt; ~/.ssh/xxserver/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>先使用 <code>ssh user@host</code> 连接到远程主机，然后执行 <code>xxx &lt; ~/.ssh/xxserver/id_rsa.pub</code> 将本地公钥内容重定向到远程，然后在远程执行命令 <code>mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys</code> 创建目录 <code>.ssh</code> （如果不存在的话）并把公钥的内容重定向追加到 <code>authorized_keys</code> 文件中。</p>
<p>输入正确密码之后出现下面提示，则表示公钥已正确保存到远程主机上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@1xx.xx.xx.xx&apos;s password:</span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   &quot;ssh &apos;root@1xx.xx.xx.xx&apos;&quot;</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br></pre></td></tr></table></figure>
<p>这时候再执行 <code>ssh root@1xx.xx.xx.xx</code> 应该能直接登录到远程主机了，不需要输入 <code>root</code> 用户的密码了，然而事实是还会提示你输入密码，具体原因看下一节。登录之后可以使用命令 <code>vim /root/.ssh/authorized_keys</code> 查看我们添加的公钥，如果有多个公钥，则这个文件会有多行，可以看到有一行和我们本地主机的公钥是一致的，说明这个公钥是我们复制上去的。</p>
<h4 id="私钥生效"><a href="#私钥生效" class="headerlink" title="私钥生效"></a>私钥生效</h4><p>把公钥复制到远程之后再进行登录，还是要求我们输入密码，这是因为本地私钥没有“生效”。虽然我们本地已经生成了私钥，远程也有了对应的公钥，但默认本地私钥是没有添加到 ssh 的，也就是不会生效的，所以登录的方式还是口令登录而不是公钥登录。要想使用公钥登录的方式登录，就必须让私钥在 SSH 终端生效，执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add ~/.ssh/xxserver/id_rsa</span><br><span class="line">Could not open a connection to your authentication agent.</span><br></pre></td></tr></table></figure>
<p>提示无法连接代理进程，这是因为 windows 默认不会启动 <code>ssh-agent</code>，<code>ssh-agent</code> 是管理 SSH Keys 的一个代理，对 SSH 私钥的管理都是通过 <code>ssh-agent</code>，因此我们要先启动这个代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-agent bash</span><br></pre></td></tr></table></figure>
<p>启动 <code>ssh-agent</code> 之后，就可以使用 <code>ssh-add</code> 来添加删除私钥了，这里的添加删除是指使私钥生效或不生效，不是修改我们的私钥文件。查看 <code>ssh-add</code> 的用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add -h</span><br><span class="line">ssh-add: unknown option -- h</span><br><span class="line">usage: ssh-add [options] [file ...]</span><br><span class="line">Options:</span><br><span class="line">  -l          List fingerprints of all identities.</span><br><span class="line">  -E hash     Specify hash algorithm used for fingerprints.</span><br><span class="line">  -L          List public key parameters of all identities.</span><br><span class="line">  -k          Load only keys and not certificates.</span><br><span class="line">  -c          Require confirmation to sign using identities</span><br><span class="line">  -t life     Set lifetime (in seconds) when adding identities.</span><br><span class="line">  -d          Delete identity.</span><br><span class="line">  -D          Delete all identities.</span><br><span class="line">  -x          Lock agent.</span><br><span class="line">  -X          Unlock agent.</span><br><span class="line">  -s pkcs11   Add keys from PKCS#11 provider.</span><br><span class="line">  -e pkcs11   Remove keys provided by PKCS#11 provider.</span><br></pre></td></tr></table></figure>
<p>默认不使用参数就是添加私钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add ~/.ssh/xxserver/id_rsa</span><br><span class="line">Identity added: /c/Users/ljx0832/.ssh/xxserver/id_rsa (/c/Users/ljx0832/.ssh/xxserver/id_rsa)</span><br></pre></td></tr></table></figure>
<p>使用参数 <code>-l</code> 可以查看所有已添加的私钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add -l</span><br><span class="line">2048 SHA256:wz1hzL73oaXjmGmhuJmu4wSadjbQ7FXqSlnvVFrAKAo /c/Users/ljx0832/.ssh/xxserver/id_rsa (RSA)</span><br></pre></td></tr></table></figure>
<p>使用参数 <code>-d</code> 可以删除某个私钥，参数 <code>-D</code> 可以删除所有私钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add -d ~/.ssh/xxserver/id_rsa</span><br><span class="line">Identity removed: /c/Users/ljx0832/.ssh/xxserver/id_rsa (ljx0832@175)</span><br><span class="line">$ ssh-add -l</span><br><span class="line">The agent has no identities.</span><br></pre></td></tr></table></figure>
<p>添加私钥生效之后，再进行远程登录就不用输入密码了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-agent bash</span><br><span class="line">$ ssh-add ~/.ssh/xxserver/id_rsa</span><br><span class="line">Identity added: /c/Users/ljx0832/.ssh/xxserver/id_rsa (/c/Users/ljx0832/.ssh/xxserver/id_rsa)</span><br><span class="line">$ ssh root@xxx.xx.xx.xx</span><br><span class="line">Last failed login: Wed May 30 03:44:01 UTC 2018 from xxx.xx.xx.xx on ssh:notty</span><br><span class="line">There was 1 failed login attempt since the last successful login.</span><br><span class="line">Last login: Wed May 30 03:25:43 2018 from xxx.xx.xx.xx</span><br><span class="line">[root@vultr ~]#</span><br></pre></td></tr></table></figure>
<p>每次打开 SSH Client 的时候都得先手动启动 <code>ssh-agent</code> 再使用 <code>ssh-add</code> 添加私钥生效，之后才能使用公钥登录进行远程登录，虽然比口令登录少了输入密码这个步骤，却多了好几个步骤，感觉反而更不便捷了。解决的方法是启动终端的时候自动启动 <code>ssh-agent</code> 并自动添加相应的私钥生效。如果使用的 SSH Client 是 Github 客户端，则不需要做什么，Github 客户端启动的时候会自动 <code>ssh-agent</code>；如果是其它终端，则要运行相应的脚本来自动启动 <code>ssh-agent</code>。比如我使用的是 Git bash，则新建一个文件 <code>~/.bashrc</code> 或 <code>~/.profile</code>，把下面的内容复制进去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">env=~/.ssh/agent.env</span><br><span class="line"></span><br><span class="line">agent_load_env () &#123; test -f &quot;$env&quot; &amp;&amp; . &quot;$env&quot; &gt;| /dev/null ; &#125;</span><br><span class="line"></span><br><span class="line">agent_start () &#123;</span><br><span class="line">    (umask 077; ssh-agent &gt;| &quot;$env&quot;)</span><br><span class="line">    . &quot;$env&quot; &gt;| /dev/null ; &#125;</span><br><span class="line"></span><br><span class="line">agent_load_env</span><br><span class="line"></span><br><span class="line"># agent_run_state: 0=agent running w/ key; 1=agent w/o key; 2= agent not running</span><br><span class="line">agent_run_state=$(ssh-add -l &gt;| /dev/null 2&gt;&amp;1; echo $?)</span><br><span class="line"></span><br><span class="line">if [ ! &quot;$SSH_AUTH_SOCK&quot; ] || [ $agent_run_state = 2 ]; then</span><br><span class="line">    agent_start</span><br><span class="line">    #ssh-add</span><br><span class="line">elif [ &quot;$SSH_AUTH_SOCK&quot; ] &amp;&amp; [ $agent_run_state = 1 ]; then</span><br><span class="line">    #ssh-add</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">unset env</span><br></pre></td></tr></table></figure>
<p><code>#ssh-add</code> 这里写你要添加的私钥，比如我在 <code>~/.ssh/</code> 下有 5 个密钥，则 <code>#ssh-add</code> 这里进行下面的替换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if [ ! &quot;$SSH_AUTH_SOCK&quot; ] || [ $agent_run_state = 2 ]; then</span><br><span class="line">    agent_start</span><br><span class="line">    ssh-add ~/.ssh/github/id_rsa</span><br><span class="line">    ssh-add ~/.ssh/gitlab/id_rsa</span><br><span class="line">    ssh-add ~/.ssh/oschina/id_rsa</span><br><span class="line">    ssh-add ~/.ssh/csdn/id_rsa</span><br><span class="line">    ssh-add ~/.ssh/xxserver/id_rsa</span><br><span class="line">elif [ &quot;$SSH_AUTH_SOCK&quot; ] &amp;&amp; [ $agent_run_state = 1 ]; then</span><br><span class="line">    ssh-add ~/.ssh/github/id_rsa</span><br><span class="line">    ssh-add ~/.ssh/gitlab/id_rsa</span><br><span class="line">    ssh-add ~/.ssh/oschina/id_rsa</span><br><span class="line">    ssh-add ~/.ssh/csdn/id_rsa</span><br><span class="line">    ssh-add ~/.ssh/xxserver/id_rsa</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>保存之后重新打开 Git bash，会有下面的提示，表示 <code>ssh-agent</code> 已经自动启动，并自动添加了我的 5 个密钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Identity added: /c/Users/ljx0832/.ssh/github/id_rsa (/c/Users/ljx0832/.ssh/github/id_rsa)</span><br><span class="line">Identity added: /c/Users/ljx0832/.ssh/gitlab/id_rsa (/c/Users/ljx0832/.ssh/gitlab/id_rsa)</span><br><span class="line">Identity added: /c/Users/ljx0832/.ssh/oschina/id_rsa (/c/Users/ljx0832/.ssh/oschina/id_rsa)</span><br><span class="line">Identity added: /c/Users/ljx0832/.ssh/csdn/id_rsa (/c/Users/ljx0832/.ssh/csdn/id_rsa)</span><br><span class="line">Identity added: /c/Users/ljx0832/.ssh/xxserver/id_rsa (/c/Users/ljx0832/.ssh/xxserver/id_rsa)</span><br></pre></td></tr></table></figure>
<p>只有第一次启动 Git bash 的时候会有上面的提示，之后就算关掉终端，<code>ssh-agent</code> 还是运行的，直到电脑关机或者进程被杀死。所以之后打开终端不会再有任何提示，但此时密钥已经添加了，直接进行公钥登录即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ssh root@xxx.xx.xx.xx</span><br><span class="line">Last failed login: Wed May 30 11:45:54 UTC 2018 from xxx.xx.xx.xx on ssh:notty</span><br><span class="line">There were 300 failed login attempts since the last successful login.</span><br><span class="line">Last login: Wed May 30 03:56:39 2018 from xxx.xx.xx.xx</span><br><span class="line">[root@vultr ~]#</span><br></pre></td></tr></table></figure>
<p>Github 官方文档：<a href="https://help.github.com/articles/working-with-ssh-key-passphrases/#auto-launching-ssh-agent-on-msysgit" target="_blank" rel="noopener">https://help.github.com/articles/working-with-ssh-key-passphrases/#auto-launching-ssh-agent-on-msysgit</a></p>
<h2 id="Git-版本控制工具"><a href="#Git-版本控制工具" class="headerlink" title="Git 版本控制工具"></a>Git 版本控制工具</h2><h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><p>前面说过 SSH 连接的一个主要应用场景就是远程登录，还有一个重要应用场景就是 git 连接，git 有两种连接方式，传统的 https 连接和更加安全的 ssh 连接。下面是使用 https 连接 clone 仓库的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/linjinxin_scau/OpenGL_Light.git</span><br></pre></td></tr></table></figure>
<p>克隆之后本地仓库自动关联了两个远程仓库地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https://gitee.com/linjinxin_scau/OpenGL_Light.git (fetch)</span><br><span class="line">origin  https://gitee.com/linjinxin_scau/OpenGL_Light.git (push)</span><br></pre></td></tr></table></figure>
<p>使用 ssh 连接 clone 仓库的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@gitee.com:linjinxin_scau/OpenGL_Light.git</span><br></pre></td></tr></table></figure>
<p>同样克隆之后本地仓库自动关联了两个远程仓库地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@gitee.com:linjinxin_scau/OpenGL_Light.git (fetch)</span><br><span class="line">origin  git@gitee.com:linjinxin_scau/OpenGL_Light.git (push)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 https 连接，每次 push 都必须输入用户名和密码，clone 项目（私有项目除外）和 pull 操作无需输入用户名和密码。</li>
<li>使用 ssh 连接，只要把公钥放在远程主机（代码托管网站）上，且本地添加了私钥生效，接下来任何 git 操作都无需输入密码。</li>
</ul>
<p>这两种连接方式，很明显 ssh 连接更好，一来 ssh 连接的安全性更有保障，二来使用 ssh 连接可省去输入密码的麻烦，当然是前提是要先生成密钥并配置好密钥环境。</p>
<h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p>既然推荐使用 ssh 连接，那就得先配置好 ssh 连接所需的密钥环境，首先使用命令生成一对公钥和私钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;email&quot; -f &quot;~/.ssh/id_rsa&quot;</span><br></pre></td></tr></table></figure>
<p><code>-C</code> 是对这个密钥的描述，会附加到公钥最后面，如果密钥用于登录远程主机，则这个说明一般会是我们的用户名，用以表明我们的身份；如果密钥用于 git 操作，则这个说明一般是我们的邮箱，也就是我们在代码托管网站上注册的账号，因为我们在 <code>push/pull</code> 的时候也是用的这个邮箱，所以用这个作说明更加明了。当然，这个说明仅是一个描述而已，使用户名和邮箱作说明只是一个规范，并不是强制要求，实际上这个说明是可以写任意东西的。这个命令前面已经介绍过了，关于更多请看 <em>SSH 远程工具/公钥登录</em> 章节。</p>
<p>生成之后把公钥拷到相应的代码托管网站上，直接找到这些网站的 <code>settings/ssh keys</code> 进行添加即可，然后生效本地的私钥，之后就能在不使用密码的情况下操作这个代码托管网站上的仓库（当然他人的私有项目除外）。</p>
<h3 id="重新生成密钥"><a href="#重新生成密钥" class="headerlink" title="重新生成密钥"></a>重新生成密钥</h3><p>如果想要修改我们的密钥，直接使用上述的命令重新生成一个进行覆盖即可，然后再把新的公钥拷贝到代码托管网站上，把旧的公钥删掉。要注意的是，重新生效密钥之后，本地新的私钥并不会立即生效，因为 <code>ssh-agent</code> 已经启动并且使用添加了旧的私钥，所以现在生效的是旧的，即使这个旧的私钥文件已经被删除了。如果要使新私钥立即生效，就必须得重启 <code>ssh-agent</code>，使用下面命令即可杀死 <code>ssh-agent</code> 进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-agent -k</span><br></pre></td></tr></table></figure>
<p>之后使用下面命令启动 <code>ssh-agent</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-agent bash</span><br></pre></td></tr></table></figure>
<p>再使用下面命令添加新的私钥生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<p>上面这种重启 <code>ssh-agent</code> 和添加私钥生效的方法比较麻烦且只对当前终端生效，终端关闭之后 <code>ssh-agent</code> 也就关闭了。更好的方法是使用配置文件 <code>~/.bashrc</code> 或 <code>~/.profile</code> ，这样在启动 Git bash 的时候都会自动启动 <code>ssh-agent</code> 并自动添加私钥生效 ，且是永久生效的（直到电脑关机或进程被杀），具体看上面 <em>SSH 远程工具/公钥登录/私钥生效</em> 章节介绍。</p>
<h3 id="clone-仓库"><a href="#clone-仓库" class="headerlink" title="clone 仓库"></a>clone 仓库</h3><p>无论是哪种连接方式，我们都可以随意 clone 网上开源的项目，但如果是私有的项目，那我们只能 clone 自己的私有项目，那 git 是如何判断项目是不是我们自己的呢？</p>
<p>如果是 ssh 地址，则判断本地主机是否能与远程主机的某个地址（通过链接中的账号信息找到这个地址）建立连接，即密钥环境有没有配置好，如果没有配置好密钥环境，本地是无法正常连接远程的，ssh 会直接拒绝了服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@gitee.com:linjinxin_scau/OpenGL_Light.git</span><br><span class="line">Cloning into &apos;OpenGL_Light&apos;...</span><br><span class="line">Permission denied (publickey).</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure>
<p>这个例子会找到 <code>linjinxin_scau</code> 这个账号在 <code>oschina</code> 上的地址，然后就能找个这个地址上的公钥，匹配这个公钥和本地的私钥，发现不匹配所以无法 clone。</p>
<p>要注意的是，使用 ssh 连接，如果没有生成密钥或者本地私钥和远程公钥对不上或者没有使私钥生效，是无法进行任何操作的，不仅 clone 不了私有项目，连开源项目也 clone 不了。因为 ssh 会检查本地的私钥和远程主机(github、gitlab 等)的公钥是否匹配，不匹配是无法进行网络连接的，这也是 ssh 更加安全的地方。</p>
<p>如果是 https 地址，则判断提供的账号与项目的归属账号是否一致。在 clone 的时候会弹出一个输入框，让我们输入用户名和密码，如果我们关闭了弹出框，则会在 bash 终端再次提示输入用户名和密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://gitee.com/linjinxin_scau/OpenGL_Light.git</span><br><span class="line">Cloning into &apos;OpenGL_Light&apos;...</span><br><span class="line">Logon failed, use ctrl+c to cancel basic credential prompt.</span><br><span class="line">Username for &apos;https://gitee.com/&apos;: linjinxin_scau@126.com</span><br><span class="line">error: unable to read askpass response from &apos;E:/Program Filles/Git/mingw64/libexec/git-core/git-gui--askpass&apos;</span><br><span class="line">Password for &apos;https://linjinxin_scau@126.com@gitee.com/&apos;:</span><br><span class="line">remote: Counting objects: 346, done.</span><br><span class="line">remote: Compressing objects: 100% (286/286), done.</span><br><span class="line">Rremote: Total 346 (delta 87), reused 273 (delta 54)</span><br><span class="line">Receiving objects: 100% (346/346), 250.89 KiB | 0 bytes/s, done.</span><br><span class="line">Resolving deltas: 100% (87/87), done.</span><br></pre></td></tr></table></figure>
<p>有时候，你会发现使用 https 连接操作私有项目时并不需要输入用户名和密码，那是因为你在这台电脑上输入过密码，且被电脑记录下来了。在 <code>控制面板--&gt;用户账户--&gt;管理你的凭据--&gt;Windows凭据</code> 可以看到你的 git 账户和密码。把这个账户信息删掉，再操作私有项目就会提示你输入用户名和密码了。</p>
<p>总结一下，</p>
<ul>
<li>对于 ssh 连接，无论是开源项目还是自己的私有项目，都需要配置好密钥环境才能 clone，不需要输入用户名和密码。</li>
<li>对于 https 连接，开源项目直接 clone，自己的私有项目需要输入正确用户名和密码才能 clone。</li>
<li>对于别人的私有项目，不能 clone。</li>
</ul>
<blockquote>
<p>注意，上面讲的用户名其实是指邮箱地址，因为 git 远程仓库账号的唯一凭据都是邮箱地址而不是用户名或者其它。</p>
</blockquote>
<h3 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h3><h4 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h4><p>使用 https 连接，每次 push 的时候都会要求输入用户名和密码，无论是开源项目还有私有项目；而 ssh 连接 push 的时候则不需要，那它使用的用户名从哪读来的呢？答案是不需要用户名，有密钥足以。密钥里面虽然没有包含我们的账户信息，但使用 ssh 连接本身就是为了跳过账号的，即使用 ssh 连接是不需要 git 账号的。为什么不需要提供账号，因为远程仓库地址中包含了账号地址，然后平台通过这个账号地址就能找到账号的信息，当然也能找到这个账号在平台上面的公钥，公钥和私钥都有了，自然就能进行通信了，还要账号干嘛。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@gitee.com:linjinxin_scau/AStar.git (fetch)</span><br><span class="line">origin  git@gitee.com:linjinxin_scau/AStar.git (push)</span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure>
<p>从远程地址 <a href="mailto:`git@gitee.com" target="_blank" rel="noopener">`git@gitee.com</a>:linjinxin_scau/AStar.git<code>中可以知道仓库</code>AStar<code>是账号</code>linjinxin_scau<code>所有，所以在进行</code>git push<code>的时候会向</code>oschina:linjinxin<code>进行请求，这个过程会进行相关的密钥操作。具体的操作不清楚，但我个人猜测应该是跟远程登录是一样的，即本地向远程请求</code>push` 操作，远程发一串随机字符串下来，本地使用私钥加密之后发送到远程，远程使用记录的公钥进行解密，解密之后的字符串与源字符串一致则认为用户可信，这时候就允许本地向远程推送东西了。</p>
<p>这时候可能会有个疑问，不需要验证账号会不会不安全啊？肯定不会，事实上 ssh 更安全，因为它传输的任何数据都是通过私钥加密的，即使被拦截也不会被破译。而一台主机能够使用 ssh 来连接 git 远程，则说明这台主机的主人已经拷贝了一份公钥到远程地址了，能在远程地址添加公钥，则说明这个人能使用账号密码直接登录远程地址，如果这个人不是账号拥有者的话，那说明这个账号已经被盗了，这时候还说什么安全不安全的，这完全不是 ssh 的锅啊。</p>
<p>可以得出这样一个结论，无论是哪种连接方式，都不需要在本地配置任何账号信息的，https 连接会在 push 的时候要求输入用户名（也就是邮箱）和密码，而 ssh 直接通过密钥解决了，不需要账号验证。事实上，还是需要在本地配置 git 账号的，这个账号不是用在 <code>push</code> 或 <code>clone</code> 的时候，而是用在 <code>commit</code> 的时候。如果本地 git 没有配置账号，则执行 commit 操作的时候会报下面错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;for test&quot;</span><br><span class="line"></span><br><span class="line">*** Please tell me who you are.</span><br><span class="line"></span><br><span class="line">Run</span><br><span class="line"></span><br><span class="line">  git config --global user.email &quot;you@example.com&quot;</span><br><span class="line">  git config --global user.name &quot;Your Name&quot;</span><br><span class="line"></span><br><span class="line">to set your account&apos;s default identity.</span><br><span class="line">Omit --global to set the identity only in this repository.</span><br><span class="line"></span><br><span class="line">fatal: unable to auto-detect email address (got &apos;ljx0832@ljx0832-PC.(none)&apos;)</span><br></pre></td></tr></table></figure>
<p>我们看提示信息的第一句，“请告诉我你是谁”，也就是说 git 不允许一个身份不明的人进行提交修改，即使我们拥有合法的对项目的操作权，但仍必须表明身份，因为这个身份信息会记录在提交记录中，如果不表明身份，那这一条提交记录就不知道是谁的。要知道到 commit 这一步的时候还不需要任何账号验证，用户名密码验证或密钥验证，所以 commit 信息里没包含任何有关提交者的信息；也许有人会说在 commit comment 里面说明啊，这样做是可以，但很不专业也很不规范，很多人可以选择不表明身份，即使表明了，别人还得去一串长长的说明里面去寻找你的身份信息，这绝对不是团队协作需要的；也许还会有人说 push 的时候不是有账号信息吗，把这个账号信息写进去不就行了，但要知道 commit 信息是在 push 之前就已经生成好了，在 push 之后再回过头去修改这个信息，这种操作是反常的，git 也不愿意做。</p>
<p>所以，在 commit 之前要配置好账号信息，包括邮箱地址和姓名。commit 时优先检查邮箱地址是否合法，如果邮箱地址没配置的话，git 会自动检测一个，检测的结果就是 <code>电脑用户名@电脑名</code>，如果这个结果是个合法的邮箱地址，那 git 就以这个地址作为我们的邮箱凭证。这里的合法地址并不一定是真实注册的邮箱地址，只要符合邮箱地址的形式即可，即 <code>name@host</code>，所以如果我们的电脑名是一个域名，那检测的结果应该是可用的，但即便如此还是配置我们真正使用的邮箱才能真正表明我们的身份。从最后的提示 <code>got &#39;ljx0832@ljx0832-PC.(none)</code> 可以看出，git 自动检测的结果不是一个合法的邮箱地址，所以 commit 的时候报错了。</p>
<p>现在先把邮箱地址设置好了，再找执行 commit 操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.email &quot;lin@126.com&quot;</span><br><span class="line">$ git commit -m &quot;test&quot;</span><br><span class="line"></span><br><span class="line">*** Please tell me who you are.</span><br><span class="line"></span><br><span class="line">Run</span><br><span class="line"></span><br><span class="line">  git config --global user.email &quot;you@example.com&quot;</span><br><span class="line">  git config --global user.name &quot;Your Name&quot;</span><br><span class="line"></span><br><span class="line">to set your account&apos;s default identity.</span><br><span class="line">Omit --global to set the identity only in this repository.</span><br><span class="line"></span><br><span class="line">fatal: empty ident name (for &lt;lin@126.com&gt;) not allowed</span><br></pre></td></tr></table></figure>
<p>可以看到还是提示说不知道我的身份，但这回是不知道我的名字，并没有提示邮箱不存在，即便我配置的邮箱地址是随便写的。所以，commit 的时候会先检查邮箱地址，再检查名字，两者缺一不可。我们可以在 commit log 中看到每条记录的作者名和邮箱地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit d79f5676af723bdf615053be6631cb275cbd785f (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: washimanong &lt;lin@126.com&gt;</span><br><span class="line">Date:   Fri Jun 1 01:16:51 2018 +0800</span><br><span class="line"></span><br><span class="line">    for test</span><br></pre></td></tr></table></figure>
<h4 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h4><p>上面的报错提示已经清晰地说明要怎么配置账号信息，事实上 <code>git config</code> 除了配置账号信息之外还可以配置很多东西，具体的看网上的 git 教程吧。<code>git config</code> 配置的东西是永久的，这说明这些配置是保存在文件中的，至于要保存在哪里，就得先知道 git config 的三种等级，分别是 <strong>System Config, Global Config, Local Config</strong>。</p>
<ul>
<li>系统配置，就是对这台电脑上所有用户的所有仓库都生效，这些配置保存在 <code>$(git path)/etc/gitconfig</code> 或 <code>$(git path)/mingw64/etc/gitconfig</code> 中，如果要读取或修改系统配置，则使用 <code>--system</code> 参数</li>
<li>全局配置，也叫用户配置，就是对这台电脑的当前用户的所有仓库生效，这些配置保存在 <code>~/.gitconfig</code> 或 <code>~/.config/git/confg</code> 中，如果要读取或修改全局配置，则使用 <code>--global</code> 参数</li>
<li>局部配置，就是只对当前仓库生效的配置，保存在 <code>$(repository)/.git/config</code> 中，如果要读取或修改局部配置，使用 <code>--local</code> 或省略不写，默认就是对局部生效，注意要进入在仓库里面才能操作</li>
</ul>
<p>这三种配置的作用范围是 <em>系统配置&gt;全局配置&gt;局部配置</em>，但生效的时候是范围小的优先生效，即局部配置存在则使用局部配置，否则全局配置存在就使用全局配置，最后才考虑使用系统配置。</p>
<p><code>git config</code> 还有很多参数，比如 <code>--get</code> 用于查看某个配置项的值，<code>--unset</code> 用于删掉某个配置项，更多的参数通过 <code>-h</code> 查看或查阅网上资料。</p>
<h3 id="多账号配置"><a href="#多账号配置" class="headerlink" title="多账号配置"></a>多账号配置</h3><p>这里说的多账号是指同时对不同代码托管网站的仓库进行贡献，比如我们可能会在同一台电脑上处理 github 上面的项目，gitlab 上面的项目，oschina 上面的项目和 csdn 上面的项目，在这些网站上注册的账号可能不一致，所以就涉及到多账号了。有两件事要做，commit 时需要的账号信息和 push 时需要验证的密钥。</p>
<p>对账号信息的处理非常简单，涉及到多账号就使用局部配置呗，每初始化或克隆一个项目，就为这个项目单独配置一个邮箱和用户名字。当然，也可以结合全局配置一起使用，即把一个其中托管网站的账号作为全局配置，之后这个网站上的仓库就不需要单独配置局部账号了，比如我在 github 上注册的邮箱是 <a href="mailto:`linjinxin_scau@126.com" target="_blank" rel="noopener">`linjinxin_scau@126.com</a>`，则可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.email &quot;linjinxin_scau@126.com&quot;</span><br><span class="line">$ git config --global user.name &quot;linjinxin&quot;</span><br><span class="line">$ cat ~/.gitconfig</span><br><span class="line">[user]</span><br><span class="line">[user]</span><br><span class="line">        email = linjinxin_scau@126.com</span><br><span class="line">        name = linjinxin</span><br></pre></td></tr></table></figure>
<p>对密钥的处理也可以很简单，可以只生成一对密钥，然后把这个公钥拷贝到所有的代码托管网站上，之后只需要生效这一个私钥就能访问所有的代码托管网站。当然，如果你想为每一个网站都生效一对密钥也是可以的，只是会复杂一点。</p>
<p>首先这些密钥要找到合适的地方放，可以修改密钥的命名（密钥不一定得叫 id_rsa 的)，或者在 <code>~/.ssh</code> 目录建个目录存放，我采用的是后者，比如用于访问 github 的私钥文件名为 <code>~/.ssh/github/id_rsa</code>，访问 gitlab 的叫 <code>~/.ssh/gitlab/id_rsa</code>。</p>
<p>然后，访问哪个网站就得使相应的那个私钥生效，比如要访问 github 的某个仓库，则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-agent bash</span><br><span class="line">$ ssh-add ~/.ssh/github/id_rsa</span><br><span class="line">Identity added: /c/Users/ljx0832/.ssh/github/id_rsa (/c/Users/ljx0832/.ssh/github/id_rsa)</span><br></pre></td></tr></table></figure>
<p>可以使用 ssh 命令来检测是否能正常连接到远程嗠器 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi linjinxin! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<p>输出上面的信息就表明可以正常连接 github 服务器了，这里测试的地址是 <code>git@合法域名</code> 或 <code>git@ip 地址</code>。当然另一种方式是上面讲过很多次的 <code>~/.bashrc</code> 或 <code>~/.profile</code> 脚本来自动启动 <code>ssh-agent</code> 并添加所有私钥生效，这种方式的好处就量方便，当然有时候我们可能并不想使所有的密钥都生效，只需要修改脚本删掉不想生效的密钥，或者不使用脚本，手动来添加生效。</p>
<h3 id="轮流检测"><a href="#轮流检测" class="headerlink" title="轮流检测"></a>轮流检测</h3><p>有时候在执行 ssh 命令的时候会出现下面这个错误信息 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@192.168.0.166</span><br><span class="line">Received disconnect from 192.168.0.166 port 22:2: Too many authentication failures for git</span><br><span class="line">Connection to 192.168.0.166 closed by remote host.</span><br></pre></td></tr></table></figure>
<p>从提示得知不能连接的原因是太多次验证失败，<code>too many authentication failures</code>，这是因为 ssh 为了安全，如果一个主机在一次连接里使用多个密钥进行尝试匹配，失败次数达到一个阈值时就不允许再连接了，直接 <code>disconnect</code> 掉，目的是防止暴力暴力破解。问题是我好像没有尝试使用多个密钥去匹配啊，其实是有的，因为我现在电脑上已经有五六个密钥了，当我连接 github 的时候 ssh 并不知道要使用哪个密钥，所以只能每个密钥都去匹配一次，暂时称之为轮流检测。有什么证据可以说明 ssh 拿每个密钥都去尝试了呢，加上 <code>-v</code> 参数，ssh 会详细的请求连接过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@192.168.0.166 -v</span><br><span class="line">OpenSSH_7.3p1, OpenSSL 1.0.2k  26 Jan 2017</span><br><span class="line">debug1: Reading configuration data /etc/ssh/ssh_config</span><br><span class="line">debug1: Connecting to 192.168.0.166 [192.168.0.166] port 22.</span><br><span class="line">debug1: Connection established.</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /c/Users/ljx0832/.ssh/id_rsa type -1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /c/Users/ljx0832/.ssh/id_rsa-cert type -1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /c/Users/ljx0832/.ssh/id_dsa type -1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /c/Users/ljx0832/.ssh/id_dsa-cert type -1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /c/Users/ljx0832/.ssh/id_ecdsa type -1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /c/Users/ljx0832/.ssh/id_ecdsa-cert type -1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /c/Users/ljx0832/.ssh/id_ed25519 type -1</span><br><span class="line">debug1: key_load_public: No such file or directory</span><br><span class="line">debug1: identity file /c/Users/ljx0832/.ssh/id_ed25519-cert type -1</span><br><span class="line">debug1: Enabling compatibility mode for protocol 2.0</span><br><span class="line">debug1: Local version string SSH-2.0-OpenSSH_7.3</span><br><span class="line">debug1: Remote protocol version 2.0, remote software version OpenSSH_5.3</span><br><span class="line">debug1: match: OpenSSH_5.3 pat OpenSSH_5* compat 0x0c000000</span><br><span class="line">debug1: Authenticating to 192.168.0.166:22 as &apos;git&apos;</span><br><span class="line">debug1: SSH2_MSG_KEXINIT sent</span><br><span class="line">debug1: SSH2_MSG_KEXINIT received</span><br><span class="line">debug1: kex: algorithm: diffie-hellman-group-exchange-sha256</span><br><span class="line">debug1: kex: host key algorithm: ssh-rsa</span><br><span class="line">debug1: kex: server-&gt;client cipher: aes128-ctr MAC: umac-64@openssh.com compress                                                                              ion: none</span><br><span class="line">debug1: kex: client-&gt;server cipher: aes128-ctr MAC: umac-64@openssh.com compress                                                                              ion: none</span><br><span class="line">debug1: SSH2_MSG_KEX_DH_GEX_REQUEST(2048&lt;3072&lt;8192) sent</span><br><span class="line">debug1: got SSH2_MSG_KEX_DH_GEX_GROUP</span><br><span class="line">debug1: SSH2_MSG_KEX_DH_GEX_INIT sent</span><br><span class="line">debug1: got SSH2_MSG_KEX_DH_GEX_REPLY</span><br><span class="line">debug1: Server host key: ssh-rsa SHA256:kR3uzR6d/Q7eKlbrkIYdFCA3cEHzP1wmX7bNp9g1                                                                              cmc</span><br><span class="line">debug1: Host &apos;192.168.0.166&apos; is known and matches the RSA host key.</span><br><span class="line">debug1: Found key in /c/Users/ljx0832/.ssh/known_hosts:9</span><br><span class="line">debug1: rekey after 4294967296 blocks</span><br><span class="line">debug1: SSH2_MSG_NEWKEYS sent</span><br><span class="line">debug1: expecting SSH2_MSG_NEWKEYS</span><br><span class="line">debug1: rekey after 4294967296 blocks</span><br><span class="line">debug1: SSH2_MSG_NEWKEYS received</span><br><span class="line">debug1: SSH2_MSG_SERVICE_ACCEPT received</span><br><span class="line">debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mi                                                                              c</span><br><span class="line">debug1: Next authentication method: publickey</span><br><span class="line">debug1: Offering RSA public key: /c/Users/ljx0832/.ssh/github/id_rsa</span><br><span class="line">debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mi                                                                              c</span><br><span class="line">debug1: Offering RSA public key: /c/Users/ljx0832/.ssh/gitlab/id_rsa</span><br><span class="line">debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mi                                                                              c</span><br><span class="line">debug1: Offering RSA public key: /c/Users/ljx0832/.ssh/oschina/id_rsa</span><br><span class="line">debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mi                                                                              c</span><br><span class="line">debug1: Offering RSA public key: /c/Users/ljx0832/.ssh/csdn/id_rsa</span><br><span class="line">debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mi                                                                              c</span><br><span class="line">debug1: Offering RSA public key: /c/Users/ljx0832/.ssh/xxserver/id_rsa</span><br><span class="line">debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mi                                                                              c</span><br><span class="line">debug1: Offering RSA public key: /c/Users/ljx0832/.ssh/q2server/id_rsa</span><br><span class="line">Received disconnect from 192.168.0.166 port 22:2: Too many authentication failur                                                                              es for git</span><br><span class="line">debug1: Authentication succeeded (publickey).</span><br><span class="line">Authenticated to 192.168.0.166 ([192.168.0.166]:22).</span><br><span class="line">debug1: channel 0: new [client-session]</span><br><span class="line">debug1: Requesting no-more-sessions@openssh.com</span><br><span class="line">debug1: Entering interactive session.</span><br><span class="line">debug1: pledge: network</span><br><span class="line">debug1: channel 0: free: client-session, nchannels 1</span><br><span class="line">Connection to 192.168.0.166 closed by remote host.</span><br><span class="line">Transferred: sent 4208, received 2704 bytes, in 0.0 seconds</span><br><span class="line">debug1: Exit status -1</span><br></pre></td></tr></table></figure>
<p>log 非常长，但也很容易看懂，在开始处有很多条 <code>key_load_public: No such file or directory</code> 信息，这里并不是报错，只是正常的信息。ssh 只是想鉴定有没有默认的公钥而已，即 <code>~/.ssh/id_rsa</code>, <code>~/.ssh/id_rsa-cert</code>, <code>~/.ssh/id_dsa</code> 等等这些公钥文件是否存在，这里不同的公钥文件对应不同的加密方式，我们常用的是 <code>rsa</code> 加密，所以默认的文件名是 <code>id_rsa</code>。这些默认文件不存在并不会影响连接，所以直接忽略就行。接下来 <code>host key algorithm: ssh-rsa</code> 由加密算法得出加密方式是 <code>ssh-rsa</code>，并且和远程对应上了 <code>Host &#39;192.168.0.166&#39; is known and matches the RSA host key.</code>。接下来就是轮流去检测 <code>~/.ssh</code> 目录下的所有 rsa 私钥，发现检测到最后一个的时候是已经验证成功了 <code>Authentication succeeded (publickey).</code>。但接下来一个很不幸的消息，连接被关闭了，就因为检测次数太多了 <code>Connection to 192.168.0.166 closed by remote host.</code>。</p>
<h1 id="开发篇"><a href="#开发篇" class="headerlink" title="开发篇"></a>开发篇</h1><h1 id="游戏篇"><a href="#游戏篇" class="headerlink" title="游戏篇"></a>游戏篇</h1><h2 id="配置-OpenGL-开发环境"><a href="#配置-OpenGL-开发环境" class="headerlink" title="配置 OpenGL 开发环境"></a>配置 OpenGL 开发环境</h2><p>OpenGL是用于渲染 2D、3D 矢量图形的跨语言、跨平台的应用程序编程接口。它是一个底层图形库，不是引擎，也不是上层接口，它不负责窗口创建和管理，只负责底层的图形渲染。因此，开发 OpenGL 还需要其它许多库的支持。</p>
<p>现代的 Windows 操作系统都自带 OpenGL 库，所以很多用 OpenGL 开发的程序或游戏都可以在我们的电脑上正常运行（当然有些程序为了保险起见也会在安装包中加上运行库）。</p>
<p><code>C:\Program Files (x86)\Microsoft SDKs\Windows\v7.1A\Lib</code></p>
<ul>
<li>32 位程序  || 64 位程序</li>
<li>Debug || Release</li>
<li>动态链接库 || 静态链接库</li>
<li></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linjinxin.com/2019/09/05/coder/git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林锦新">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="B.C. Studio">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/05/coder/git/" itemprop="url">Git 基础用法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-05T18:20:33+08:00">
                2019-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT-日常/" itemprop="url" rel="index">
                    <span itemprop="name">IT 日常</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/09/05/coder/git/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/09/05/coder/git/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><em>你要相信，机会不来是因为你还没准备好。</em></p>
</blockquote>
<h1 id="git-基础"><a href="#git-基础" class="headerlink" title="git 基础"></a>git 基础</h1><ul>
<li>文件状态： <strong>未跟踪(untracked)、已提交(committed)、已修改(modified)、已暂存(staged)</strong></li>
<li>工作区域： <strong>远程仓库、工作目录、暂存区域</strong></li>
</ul>
<ul>
<li>在工作目录修改文件 –&gt; <strong>committed ot modified</strong></li>
<li>将文件快照放入暂存区域 –&gt; <strong>modified to staged</strong></li>
<li>提交更新 –&gt; <strong>staged to commited</strong></li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>git 配置有三个作用域，其应用优先级：<strong>local &gt; global &gt; system</strong>。</p>
<ul>
<li><code>--system</code> 配置文件为 <code>/etc/gitconfig</code> 下，所有用户的配置</li>
<li><code>--global</code> 配置文件为 <code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 下，当前用户的配置</li>
<li><code>--local</code> 配置文件为 <code>proj/.git/config</code>，当前仓库的配置</li>
</ul>
<h3 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h3><ul>
<li>查看所有配置项 <code>git config [--system|--global|--local] --list</code></li>
<li>查看特定配置项 <code>git config [--system|--global|--local] user.name</code></li>
</ul>
<p>如果不指定作用域，则按优先级获取，即在 <code>local</code> 取不到该项的值再从 <code>global</code> 取，还是取不到再从 <code>system</code> 取，如果 <code>system</code> 中也没配置，则返回空。</p>
<h3 id="设置配置"><a href="#设置配置" class="headerlink" title="设置配置"></a>设置配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name xxx</span><br><span class="line">git config --global user.email xxx@example.com</span><br><span class="line">git config --system core.editor vim</span><br><span class="line">git config --<span class="built_in">local</span> core.ignorecase <span class="literal">false</span></span><br><span class="line">git config --system core.commentchar *</span><br></pre></td></tr></table></figure>
<p>如果不指定作用域，则默认为 <code>--local</code>。</p>
<h3 id="删除配置项"><a href="#删除配置项" class="headerlink" title="删除配置项"></a>删除配置项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> user.name</span><br><span class="line">git config --<span class="built_in">local</span> --<span class="built_in">unset</span> user.email</span><br></pre></td></tr></table></figure>
<p>如果不指定作用域，则默认为 <code>--local</code>。</p>
<h2 id="短命令"><a href="#短命令" class="headerlink" title="短命令"></a>短命令</h2><p>有些命令经常使用，如果可以使用更短的命令代替会方便很多，git alias 提供了给命令设置别名的功能，打开系统配置文件 <code>/etc/gitconfig</code>，添加下面的配置项，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[alias]</span><br><span class="line">co = checkout</span><br><span class="line">st = status</span><br><span class="line">ci = commit</span><br><span class="line">br = branch</span><br><span class="line">bm = branch -m</span><br><span class="line">bd = branch -d </span><br><span class="line">cb = checkout -b</span><br><span class="line">df = diff</span><br><span class="line">ls = log --stat</span><br><span class="line">lp = log -p</span><br><span class="line">plo = pull origin</span><br><span class="line">pho = push origin</span><br></pre></td></tr></table></figure>
<h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>在 <code>.gitignore</code> 中指定哪些文件不需要跟踪。空目录默认不会跟踪。</p>
<ul>
<li><strong>*.[oa]</strong>            所有以 <code>.o</code>或 <code>.a</code> 结尾的文件</li>
<li><strong>*~</strong>                所有以 <code>~</code> 结尾的文件</li>
<li><strong>build/</strong>              所有 <code>build</code> 目录及目录下所有文件</li>
<li><strong>/build/</strong>           根目录下的 <code>build</code> 目录及目录下所有文件</li>
<li><strong>build</strong>             所有 <code>build</code> 文件</li>
<li><strong>/build</strong>            根目录下的 <code>build</code> 文件</li>
<li><strong>doc/*.txt</strong>            <code>doc</code> 根目录下的所有文本文件</li>
<li><strong>doc/*<em>/</em>.txt</strong>      <code>doc</code> 目录下的所有文本文件</li>
</ul>
<h2 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> [verb]</span><br><span class="line">git [verb] --<span class="built_in">help</span>  </span><br><span class="line">man git-[verb]</span><br></pre></td></tr></table></figure>
<h1 id="git-仓库"><a href="#git-仓库" class="headerlink" title="git 仓库"></a>git 仓库</h1><h2 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h2><p>本地仓库就是本地的一个文件夹，在这个文件夹下生成一个 <code>.git</code> 目录，这个文件夹就变成了一个本地 git 仓库。创建一个本地仓库有两种方式，第一种是在该目录下执行 <code>git init</code> 即可，这种方式创建创建的本地仓库不与任何远程仓库关联。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> xxxdir</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>第二种是使用 <code>git clone</code> 直接拉取一个远程仓库到本地，会自动根据远程仓库名在本地创建一个同名的文件夹，且文件夹下有 <code>.git</code> 目录，这种方式创建的本地仓库默认会与拉取的远程仓库关联。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:xxx/xxx.git</span><br></pre></td></tr></table></figure>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>远程仓库是指放在远程服务器上的 <code>respository</code>，通常是放在使用 Git 远程版本控制的软件源代码托管平台上，比如 Github, Gitlab, Gitee 等等网站。远程仓库需要我们到托管平台上创建。</p>
<h3 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h3><ul>
<li><code>git remote add &lt;remote-name&gt; &lt;url&gt;</code></li>
</ul>
<p>通过 <code>git remote add</code> 命令可以将本地仓库关联到远程仓库，一个本地仓库可关联多个远程仓库。<code>remote-name</code> 是我们给远程仓库取的名字，之后对该远程仓库的所有操作都使用这个名字，<code>url</code> 则是远程仓库的地址。</p>
<blockquote>
<p>使用 <code>get clone</code> 拉取远程仓库到本地，默认就会关联这个远程仓库，使用的是默认名字 <code>origin</code>。</p>
</blockquote>
<h3 id="取消关联远程仓库"><a href="#取消关联远程仓库" class="headerlink" title="取消关联远程仓库"></a>取消关联远程仓库</h3><ul>
<li><code>git remote remove/rm &lt;name&gt;</code></li>
</ul>
<h3 id="查看关联的远程仓库"><a href="#查看关联的远程仓库" class="headerlink" title="查看关联的远程仓库"></a>查看关联的远程仓库</h3><ul>
<li><code>git remote</code>  </li>
<li><code>git remote -v/--verbose</code> 显示 url</li>
<li><code>git remote show &lt;name&gt;</code> 显示某一远程仓库的详细信息</li>
</ul>
<h3 id="重命名远程仓库"><a href="#重命名远程仓库" class="headerlink" title="重命名远程仓库"></a>重命名远程仓库</h3><ul>
<li><code>git remote rename &lt;old-name&gt; &lt;new-name&gt;</code></li>
</ul>
<h1 id="git-分支"><a href="#git-分支" class="headerlink" title="git 分支"></a>git 分支</h1><h2 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h2><ul>
<li>git 分支本质上仅仅是指向提交对象的可变指针，提交对象提交时分支会自动向前移动；</li>
<li><code>git init</code> 会默认创建一个名为 <code>master</code> 的分支，这个分支和普通分支没什么区别；</li>
<li><code>HEAD</code> 才是特别的分支，它指向当前所在的本地分支，可看作当前分支的别名。切换分支时 <code>HEAD</code> 会指向另一个分支，同时把本地目录的文件替换为另一个分支指向的文件。</li>
</ul>
<h2 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h2><ul>
<li><code>git branch &lt;name&gt;</code></li>
</ul>
<h2 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h2><ul>
<li><code>git checkout &lt;name&gt;</code>  </li>
<li><code>git checkout -b &lt;name&gt;</code> 创建新分支并切换到该分支，等价于<br><code>git branch &lt;name&gt;</code><br><code>git checkout &lt;name&gt;</code></li>
</ul>
<p><code>checkout</code> 即查看的意思，如果参数带的是分支名，即表示查看这个分支的内容——切换到该分支；如果参数带的是文件名，即查看远程上该文件的内容，即检出该文件到本地。</p>
<h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><ul>
<li>查看所有分支：<code>git branch</code></li>
<li>查看所有分支最后一次提交：<code>git branch -v</code></li>
<li>查看所有已合并分支：<code>git branch --merged</code></li>
<li>查看所有未合并分支：<code>git branch --no-merged</code></li>
<li>查看所有分支包含远程分支和已删除分支： <code>git branch -a</code></li>
</ul>
<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><ul>
<li><code>git branch -d &lt;name&gt;</code>  只能删除那些已经合并的分支</li>
<li><code>git branch -D &lt;name&gt;</code> 能删除已合并或未合并的分支</li>
<li><code>git push &lt;remote&gt; --delete &lt;branch&gt;</code> 删除远程分支</li>
</ul>
<h2 id="重命名分支"><a href="#重命名分支" class="headerlink" title="重命名分支"></a>重命名分支</h2><ul>
<li><code>git branch -m &lt;old-name&gt; &lt;new-name&gt;</code> 如果 <code>&lt;new-name&gt;</code> 分支已存在则重命名不成功</li>
<li><code>git branch -M &lt;old-name&gt; &lt;new-name&gt;</code> 强制重命名，即使分支 <code>&lt;new-name&gt;</code> 已存在</li>
</ul>
<h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><ul>
<li><code>git merge &lt;other&gt;</code></li>
</ul>
<p>将 <code>other</code> 分支合并到当前分支，合并后 <code>other</code> 分支的状态就是 <code>merged</code>，可放心删除。合并时，先切换到要合并到的分支，再 merge 要合并的分支，比如要将 <code>hotfix</code> 分支合并到 <code>master</code> 分支，则</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge hotfix</span><br></pre></td></tr></table></figure>
<p>合并的时候有两种情况，一是要合并到的分支 <code>master</code> 是要合并的分支 <code>hotfix</code> 的直接祖先，如下图所示，这种情况 merge 的时候会出现 <code>Fast-forward</code>(快进) 的提示，这种情况的合并很简单，不需要任何额外的处理，因为不会有冲突，<code>hotfix</code> 本身就是从 <code>master</code> 分化出来的，内容只会比 <code>master</code> 新，不存在两个分支同时修改的内容。</p>
<p><img src="/image/coder/git/merge-fast-forward.png" alt="fast-forward"></p>
<p>第二种情况是要合并到的分支不是要合并的分支的直接祖先，如下图一所示，把分支 <code>iss53</code> 合并到分支 <code>master</code>，这两个分支在某个时间点出现了分叉，无直接关系，只有共同的祖先 <code>C2</code> 快照。这种情况 Git 会自动拿 <code>C2, C4, C5</code> 三个快照进行合并生成一个新的快照 <code>C6</code>，然后让 <code>master</code> 分支指向 <code>C6</code> 快照，如下图二所示。</p>
<p><img src="/image/coder/git/merge-advanced.png" alt="maybe-conflict"><br><img src="/image/coder/git/after-merge.png" alt="after-merge"></p>
<p><code>merge</code> 操作是 Git 自动完成的，通过快照对比修改本地文件，如果没冲突则自动将修改过的文件加入到暂存区，文件状态变为 <code>staged</code>；有冲突的文件则会为 <code>conflict</code>，需要我们手动处理冲突，处理完成后标记为 <code>modified</code>，然后手动添加到暂存区变为 <code>staged</code>。merge 之后只是我们本地的文件做了修改，所以还需要执行 <code>git commit</code> 将修改提交到远程。</p>
<h2 id="关联远程分支"><a href="#关联远程分支" class="headerlink" title="关联远程分支"></a>关联远程分支</h2><p>本地分支在两种情况下会自动关联远程分支，一是使用 <code>git checkout &lt;branch&gt;</code> 从远程检出分支到本地，检出的本地分支自动与远程分支关联，二是在本地新创建的分支，默认是没有与远程分支关联的，当有 push 新的 commit 到远程的时候，就会将本地分支关联到远程的同名分支，<code>git push &lt;remote&gt; &lt;branch&gt;</code> 会将 <code>&lt;branch&gt;</code> 关联到 <code>&lt;remote&gt;/&lt;branch&gt;</code>，如果远程分支不存在，则会创建一个。</p>
<p>有时候需要修改本地分支关联的远程分支，比如修改了远程仓库的地址，从 <code>remote1</code> 变为了 <code>remote2</code>，原来的 <code>master</code> 分支关联的是 <code>remote1/master</code>，需要将其变更为 <code>remote2/master</code> 才能正常进行 push 或 pull 操作。</p>
<p>手动关联远程分支：<code>git branch --set-upstream-to=origin/&lt;branch&gt; &lt;branch&gt;</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin</span><br><span class="line">git remote add origin &lt;new-url&gt;</span><br><span class="line">git branch --<span class="built_in">set</span>-upstreasm-to=origin/master master</span><br></pre></td></tr></table></figure>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="检查文件状态"><a href="#检查文件状态" class="headerlink" title="检查文件状态"></a>检查文件状态</h2><ul>
<li><code>git status</code></li>
<li><code>git status -s/--short</code></li>
</ul>
<p><code>-s</code> 只列出所有差异文件及其状态，状态以符号的形式显示在文件前面，<code>??</code> 表示未加入暂存区的新文件，<code>A</code> 表示已加入暂存区的新文件，<code>M</code> 表示已修改，<code>D</code> 表示已删除。符号为红色表示未添加到暂存区，绿色表示已添加到暂存区。其中 <code>??</code> 只会显示为红色，<code>A</code> 只会显示为绿色。</p>
<h2 id="跟踪文件"><a href="#跟踪文件" class="headerlink" title="跟踪文件"></a>跟踪文件</h2><p><code>git add &lt;file&gt;</code> 添加文件到暂存区</p>
<ul>
<li>跟踪新文件，从 <code>untracked</code> 到 <code>staged</code>，<code>??</code> to <code>A</code>(红变绿)；</li>
<li>跟踪修改的旧文件，从 <code>modified</code> 到 <code>staged</code>，<code>M</code> to <code>M</code>(红变绿)；</li>
<li>跟踪删除的旧文件，从 <code>modified</code> 到 <code>staged</code>，<code>D</code> to <code>D</code>(红变绿)；</li>
<li>当然也可以跟踪未修改的旧文件，只是没意义而已，跟踪之后也不会有什么变化；</li>
<li>每次文件修改后，提交更新前都要重新跟踪，因为提交更新时是暂存区的版本，而不是本地目录的版本。</li>
</ul>
<h2 id="取消跟踪"><a href="#取消跟踪" class="headerlink" title="取消跟踪"></a>取消跟踪</h2><p><code>git reset HEAD &lt;file&gt;</code> 将文件从暂存区移除，保留文件状态，如果是新文件则从已跟踪重新变成未跟踪，旧文件已修改仍是已修改，已删除仍是已删除。</p>
<blockquote>
<p><code>HEAD</code> 可以省略，但如果是是取消跟踪已删除文件则不能省略，因为在本地找不到该文件，也可以用 <code>--</code> 来代替 <code>HEAD</code>。</p>
</blockquote>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>删除文件 <code>git rm</code> 及下面介绍的移动文件 <code>git mv</code> 是对 Linux 命令的“扩展”，如果文件未跟踪，即在版本中不存在，是本地新增的文件，则用 Linux 命令即可，而且只能用 Linux 命令，用 git 命令会报找不到文件的错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch <span class="built_in">test</span></span><br><span class="line">$ git rm <span class="built_in">test</span></span><br><span class="line">fatal: pathspec <span class="string">'test'</span> did not match any files</span><br></pre></td></tr></table></figure>
<p><code>git rm &lt;file&gt;</code> 先使用 Linux 命令删除本地文件，再跟踪删除的文件，即添加到暂存区，相当于下面几条命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rm package.json</span><br><span class="line">$ git add package.json</span><br></pre></td></tr></table></figure>
<ul>
<li>文件未跟踪 <code>rm &lt;file&gt;</code></li>
<li>文件未修改未删除 <code>git rm &lt;file&gt;</code></li>
<li>文件已修改 <code>git rm -f &lt;file&gt;</code><blockquote>
<p>强制删除，无论文件原来是否在暂存区，都从本地删除并重新加入暂存区</p>
</blockquote>
</li>
<li>文件已修改 <code>git rm --cached &lt;file&gt;</code> <blockquote>
<p>从版本中移除，保留在本地目录成为未跟踪文件</p>
</blockquote>
</li>
<li>文件已删除，未加入暂存区 <code>git rm &lt;file&gt;</code><blockquote>
<p>加入暂存区，相当于只执行 <code>git rm</code> 的第二步操作</p>
</blockquote>
</li>
<li>文件已删除，已加入暂存区，无法再进行任何删除操作</li>
</ul>
<h2 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h2><p><code>git mv &lt;old-name&gt; &lt;new-name&gt;</code> 文件重命名并将修改加入暂存区，其实就是将旧文件删除，然后建一个新文件，再将两个文件添加到暂存区，等价于下面几条命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv &lt;oldfile&gt; &lt;newfile&gt;</span><br><span class="line">$ git add &lt;oldfile&gt;</span><br><span class="line">$ git add &lt;newfile&gt;</span><br></pre></td></tr></table></figure>
<p>同 <code>git rm</code> 一样，如果是版本中不存在的新文件，不能使用 <code>git mv</code> 来重命名（也没意义），直接使用 Linux 命令 <code>mv</code> 即可。</p>
<h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><ul>
<li><code>git push &lt;remote&gt; &lt;branch&gt;</code>  </li>
</ul>
<p>当前 <code>&lt;remote&gt;-&lt;branch&gt;</code> 没人抢先推送时才能推送成功，否则必须先拉取远程分支内容合并后再推送。</p>
<h2 id="从远程仓库拉取"><a href="#从远程仓库拉取" class="headerlink" title="从远程仓库拉取"></a>从远程仓库拉取</h2><ul>
<li><code>git fetch &lt;remote&gt;</code> 拉取远程仓库的所有分支的引用，不会进行合并，必须手动合并分支；</li>
<li><code>git pull &lt;remote&gt; &lt;branch&gt;</code> 拉取某个远程分支的内容并合并到本地分支。</li>
</ul>
<h2 id="查看-diff"><a href="#查看-diff" class="headerlink" title="查看 diff"></a>查看 diff</h2><ol>
<li>查看未暂存文件的修改信息 <code>git diff</code></li>
<li>查看已暂存文件的修改信息 <code>git diff -cached</code> or <code>git diff -staged</code></li>
<li>查看距离某次 commit 的修改信息 <code>git diff &lt;commit&gt;</code></li>
<li>查看单个文件的修改信息 <code>git diff -- &lt;file&gt;</code></li>
<li>查看单个距离某次 commit 的修改信息 <code>git diff &lt;commit&gt; -- &lt;file&gt;</code></li>
</ol>
<ul>
<li>如果要查看某个文件的修改信息，直接带上文件名即可 <code>git diff &lt;file&gt;</code>，不带文件名则查看所有有更改文件的 diff；</li>
<li>只列出有更改的行及上下文，删除的行在最前面加上 <code>-</code> 并显示为红色，新增的行在最前面加上 <code>+</code> 并显示为绿色；</li>
</ul>
<h2 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h2><ol>
<li>在编辑器中编辑提交信息 <code>git commit</code></li>
<li>直接输入提交信息 <code>git commit -m &lt;statement&gt;</code></li>
<li>跳过暂存区域直接提交 <code>git commit -a</code></li>
</ol>
<h2 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h2><p><code>git log</code></p>
<ul>
<li><code>-p</code> 显示每次提交的内容差异</li>
<li><code>-3</code> 只显示最新的 3 次提交</li>
<li><code>--stat</code>    显示简略的统计信息</li>
<li><code>--pretty</code> 指定显示的格式</li>
<li><code>--author=[xxx]</code> 按提交作者筛选</li>
</ul>
<p>默认查看所有提交日志，如果要查看某个文件的提交日志，带上文件名即可 <code>git log -- &lt;file&gt;</code>。</p>
<ul>
<li><code>git shortlog</code> 列出所有提交记录，只显示 commit 说明，按作者分类；</li>
<li><code>git shortlog --author=[xxx]</code> 只列出某位作者或某几位作者的日志，这个命令比较常用，比如查看自己的提交日志。</li>
</ul>
<h2 id="储藏文件"><a href="#储藏文件" class="headerlink" title="储藏文件"></a>储藏文件</h2><p>有时候在本地做了一些修改后，想切换到其它分支或者从远程拉取最新代码，而本地的修改暂时又不想提交，则可以将本地修改储藏起来，储藏之后本地又恢复成干净状态（即无修改状态），这时候 pull 代码或 checkout 分支都不会有冲突出现。之后需要的时候再从储藏中将文件恢复到本地，恢复的时候如果修改的文件有更新，则可能会出现冲突，所以一般是想更新远程较新文件且这些文件在本地没修改，本地修改的是远程无更新文件，才会使用储藏操作。</p>
<ul>
<li>储藏本地修改文件 <code>git stash</code></li>
<li>查看储藏列表 <code>git stash list</code></li>
<li>应用储藏 <code>git stash apply</code><blockquote>
<p>如果要恢复指定的储藏，带上名字即可，比如 <code>git stash aaply stash@{1}</code>，默认从最近一次的储藏进行恢复，等价于 <code>git stash apply stash@{0}</code>。</p>
</blockquote>
</li>
<li>取消储藏 <code>git stash show -p | git apply -R</code><blockquote>
<p>git 没有提供 <code>stash unapply</code> 的命令，但是可以通过取消该储藏的补丁达到同样的效果，如果要取消指定的储藏，带上名字即可，<code>git stash show -p stash@{1} | git apply -R</code>。</p>
</blockquote>
</li>
<li>移除储藏 <code>git stash drop</code><blockquote>
<p><code>stash apply</code> 只是应用储藏，应用之后储藏的内容还在栈中，需要手动移除，<code>drop</code> 默认移除最近一次的储藏，<code>git stash drop stash@{1}</code> 移除上上次的储藏。</p>
</blockquote>
</li>
<li>应用并移除储藏 <code>git stash pop</code><blockquote>
<p><code>stash pop</code> 应用储藏的同时将其从栈中移除，等价于 <code>stash apply</code> + <code>stash drop</code>，<code>git stash pop stash@{1}</code> 可应用并移除上上次的储藏。</p>
</blockquote>
</li>
<li>移除所有储藏 <code>git stash clear</code></li>
</ul>
<h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><h3 id="撤销暂存"><a href="#撤销暂存" class="headerlink" title="撤销暂存"></a>撤销暂存</h3><p><code>git reset HEAD &lt;file&gt;</code></p>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p><code>git checkout -- &lt;file&gt;</code>  </p>
<p>将文件修改为上次提交的样子或者刚放入工作目录时的样子，直接拿版本快照中的文件来覆盖本地，因此很危险。</p>
<h3 id="撤销提交"><a href="#撤销提交" class="headerlink" title="撤销提交"></a>撤销提交</h3><p><code>git reset [--soft/--mixed/--hard] HEAD^</code></p>
<p>恢复到当前版本状态，<code>--soft</code> 只撤销 commit，文件仍在暂存区中，<code>--mixed</code> 撤销 commit 和 add，文件恢复到工作目录，<code>--hard</code> 最粗暴，不仅撤销 commit 和 add，还将本地修改直接撤销了，即完全恢复到上次提交的状态，要慎用。默认参数是 <code>--mixed</code>，也是最常用的参数。</p>
<h3 id="重新提交"><a href="#重新提交" class="headerlink" title="重新提交"></a>重新提交</h3><p><code>git commit --amend</code>  </p>
<p>第二次提交会覆盖上一次的提交，如果第二次提交没有新的修改，就会使用第一次的快照，只覆盖提交信息。</p>
<h2 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h2><p>有时候会丢失一些 commit 信息，比如强制删除了一个没 merge 的分支，则这个分支上的 commit 就丢失了，或者 hard-reset 到某个版本，则这个版本之后的 commit 就丢失了。这些丢失的数据是可以找回的，因为这些操作并不是真正的删除，只是从 git 仓库中移除了，数据还保留在 <code>.git</code> 目录下；git 会不定时的执行 <code>git gc</code> 命令，将不被引用且存在数月的垃圾删除，所以如果是误操作丢失了数据，不要慌，只要不是太久都可以找回的。</p>
<p>找回 commit 其实很简单，比方在这个 commit 上创建一个新分支就把它恢复过来了，关键是得知道我们弄丢的是哪个 commit，<code>git log</code> 只会显示当前的所有 commit，不包含已删除的，这时候可以用 <code>git relog</code>，可以查看所有分支的所有操作记录，包括已删除的 commit 和 reset 的操作，relog 只显示简单的 commit 信息，这时可以再执行下 <code>git log -g</code> 来输出 relog 的正常日志，这样就能看到我们要恢复的是哪个 commit。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git relog</span><br><span class="line">git <span class="built_in">log</span> -g</span><br><span class="line">git branch recover-branch [commmit]</span><br></pre></td></tr></table></figure>
<p>relog 数据保存在 <code>.git/logs</code> 目录下，如果这个目录被删了，则 <code>git relog</code> 就帮不了我们了，这时候可以使用 <code>git fsck</code> 命令，该命令会检查仓库的数据完整性和一致性，如果指定选项 <code>--full</code>，该命令显示所有未被其它对象引用的所有对象。通过 <code>git fsck --full</code> 也能找到被删除的 commit 信息。</p>
<p>有时候会误删 stash，比如想应用并移除储藏的时候，脑子一热将 <code>git stash pop</code> 打成了 <code>git stash drop</code>，这时储藏没应用，却已经从栈中移除了。但别慌，只是从栈中移除了，stash 的数据还是在的，只是无法在 <code>git stash list</code> 中列出来，即没有 stash 名字而已，但我们仍可以通过 commit 信息来恢复。其实在移除储藏的时候，从移除的结果就可以看到这条储藏的 commit 信息，如果马上意识到自己误操作，这时想恢复十分简单，直接使用这条 commit 信息进行恢复即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on mission-guide: 7c7e6fb6 <span class="comment">#feature update info</span></span><br><span class="line">$ git stash drop</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (6703c50483b213a0bad3cff09ed804515ff93b78)</span><br><span class="line">$ git stash list</span><br><span class="line"></span><br><span class="line">$ git stash apply 6703c50</span><br><span class="line">On branch feature/mission-guide</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">        modified:   scripts/data/guide.lua</span><br></pre></td></tr></table></figure>
<p>这是在刚移除 stash 的时候恢复，这时我们知道 commit 信息，如果隔了一段时间不知道 commit 信息了，也可以通过 <code>git fsck</code> 来列出所有 commit，但列出来的 commit 是无序的，只能通过 <code>git show [commit]</code> 来一条条查看 commit 的 diff，找到需要的 commit 之后再进行恢复，相对会麻烦挺多。</p>
<h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><h2 id="commit-规范"><a href="#commit-规范" class="headerlink" title="commit 规范"></a>commit 规范</h2><p><strong>标题：</strong><code>#[type] message</code></p>
<p>一般使用 <code>#[type]</code> 来表示这次提交内容的类型，比如 <code>#feature</code> 代码功能开发，<code>#bugfix</code> 代表 bug 修复，或者在一个博客系统中， <code>#newpost</code> 代表新文章，<code>#newpage</code> 代表新页面，<code>#newdraft</code> 代表新草稿，<code>#amend</code> 代表文章修改，<code>#feature</code> 代表其它修改。</p>
<blockquote>
<p>默认 <code>#</code> 为 commit 信息的注释符号，通过配置 <code>git config core.commentchar *</code> 将其设置为 <code>*</code> 或其它符号。</p>
</blockquote>
<p><strong>单一职责</strong>，一次 commit 只处理一件事，方便查看和回退，多提交几次 commit 并没有不好的。</p>
<h2 id="分支命名规范"><a href="#分支命名规范" class="headerlink" title="分支命名规范"></a>分支命名规范</h2><ul>
<li><code>master</code> 主干分支，一般不在这个分支上直接改东西；</li>
<li><code>feature/xxx</code> 功能开发分支；</li>
<li><code>bugfix/xxx</code> bug 修复分支；</li>
<li><code>release/xxx</code> 发行分支。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linjinxin.com/2018/10/23/coder/hexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林锦新">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="B.C. Studio">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/23/coder/hexo/" itemprop="url">使用 Github + Hexo 搭建个人博客</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-23T13:43:45+08:00">
                2018-10-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT-日常/" itemprop="url" rel="index">
                    <span itemprop="name">IT 日常</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/23/coder/hexo/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/10/23/coder/hexo/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为本站的第一篇文章，当然是介绍本站是如何搭建的啦！</p>
<p>和网上大部分的教程一样，本站使用 Github Pages + Hexo + Next theme 搭建。其实并没有什么工作量，都是前人做好的工具，我们无非就是把工具放在一起罢了。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="注册一个-github-账号"><a href="#注册一个-github-账号" class="headerlink" title="注册一个 github 账号"></a>注册一个 github 账号</h2><p>为了让别人可以访问我们的网站，必须将我们的网站部署到服务器上而不是在本地；但我们并没有自己的服务器（大部分人），所以一种很实惠又方便的做法是将我们的网站部署到 github 上，由 github 来托管我们的项目，并提供一个可访问的 url。每个 github 账号可以创建多个 github Page 仓库，每个仓库都是一个个人网站，这个仓库里的内容就是我们托管在 github 上的网页。</p>
<p>注册 github 账号没什么好说了，只要你有一个邮箱就行，打开 <a href="`https://github.com`">Github</a>，点击 <code>sign up</code>，然后按要求一步步输入信息即可。</p>
<h2 id="安装-git-客户端"><a href="#安装-git-客户端" class="headerlink" title="安装 git 客户端"></a>安装 git 客户端</h2><p>github 是一个代码托管平台，使用 git 版本控制系统来管理代码，因此我们要在自己的电脑上下载一个 git 客户端，可以是图形界面也可以是命令行工具。常用的 git 客户端有 github desktop 和 git bash，没有好坏之分，看你喜欢用哪个，这两个客户端安装的时候都可以选择安装图形界面和命令行终端，建议终端必须要装。</p>
<h2 id="配置-git-环境"><a href="#配置-git-环境" class="headerlink" title="配置 git 环境"></a>配置 git 环境</h2><p>安装完 git 客户端之后，还需要进行一些环境配置。最常见的就两步，添加 ssh 密钥和配置账号信息。</p>
<p>添加 ssh 密钥，首先要在本地生成一对 ssh 密钥，包括一个公钥和一个私钥，私钥存放在本地计算机，公钥拷贝到你的 github 账号上；然后每次访问 github 仓库时只要本地使私钥生效，就无需输入用户名和密码，因为使用的是 ssh 协议，只要本地私钥和远程公钥对应上就行。也可以不添加 ssh 密钥，这样的话就只能以 http 协议去访问 github 仓库，安全性没有使用 ssh 协议高，而且每次操作都得输入用户名和密码。</p>
<p>配置账号信息是指在本地的 git 配置文件中指明你的身份，这个身份包括一个邮箱和一个用户名，提交修改到远程的时候需要用到这些信息，否则远程仓库不知道你的身份，不知道这次修改是谁提交的。</p>
<p>关于 git 和 ssh 的更多信息可以参考网上的教程，也可以看我的<a href="">这篇文章</a>。因为这不是这篇文章的重点，所以在这里就不深入说了。</p>
<h2 id="安装-node-js"><a href="#安装-node-js" class="headerlink" title="安装 node.js"></a>安装 node.js</h2><p>如果只是想搭建一个个人网站，这一步并不是必需的。但因为我们想要搭建一个个人博客，即将我们的网站设计成一个博客系统，所以需要用到前人做好的优秀博客框架，比如下面要介绍的 Hexo 博客框架（当然，前端大神完全可以自己手撸，但对于像我这种不懂前端的，还是站在巨人的肩膀上吧）。而下载 Hexo 需要用到 Node.js，所以我们需要先将 Node.js 准备好。同样，安装工作没什么好说的，直接去官网下载一个和操作系统匹配的版本安装即可。</p>
<h1 id="创建-github-pages"><a href="#创建-github-pages" class="headerlink" title="创建 github pages"></a>创建 github pages</h1><p>github pages 就是我们在 github 展示的个人页面，github pages 其实就是一个 github repository，只是这个 respository 的命名比较特殊，要求是 <code>name.github.io</code>，只有以这个形式命名的仓库才会被当成 github pages，这里的 <code>name</code> 最好写我们的账号用户名或组织名，原因下面再讲。</p>
<p>首先，创建一个 github 仓库。点击 <code>New repository</code> 按钮（点击右上角的加号就会弹出），然后分别填写仓库名，添加仓库描述，设置项目公开或私有，是否以 <code>readme</code> 文件初始化仓库，是否添加 <code>.gitignore</code> 文件，是否添加 <code>license</code> 文件，最后点击 <code>Create repository</code> 按钮即可。除了仓库名，其它都是可省略的，但仓库描述最好写一下。</p>
<p><img src="/image/coder/hexo/new_repository.png" alt="new repository"></p>
<p>创建成功之后就可以通过 <code>https://name.github.io</code> 来访问我们的网站。 下面是几点要注意的事项：</p>
<ul>
<li><p>再次重复一下仓库名必须是 <code>name.github.io</code>，只有这种格式的仓库才会被 github 当成 github pages。</p>
</li>
<li><p>仓库的 <code>private</code> 和 <code>public</code> 只是设置仓库代码的私有性，即别人是否能克隆修改我们的代码；发布的网站都是公开的，否则这个网站就没意义了。</p>
</li>
<li><p>关于仓库名中的 <code>name</code>，网上很多教程说只能使用我们的账号名 <code>username</code>，其实不然，这个名字是可以随便起的，只是取不同的名字会有些区别。</p>
</li>
</ul>
<p>如果仓库名是 <code>username.github.io</code>，则可以直接通过 <code>https://username.github.io</code> 来访问我们的网站；<br>如果仓库名是 <code>orgname.github.io</code>，也可以直接通过 <code>https://orgname.github.io</code> 来访问我们的网站，这里的 <code>orgname</code> 指的是组织名 Organization，而且这个仓库必须是这个组织的仓库。比如我们有一个 Organization 叫 <code>MyStudio</code>，然后在这个 Organization 下面创建一个 Repository，也叫 <code>MyStudio</code>，则可以直接通过 <code>https://MyStudio.github.io</code> 来访问我们的网址。但如果仓库 <code>MyStudio</code> 属于这个账号而不是这个组织，那就不能以这种方式直接访问了；<br>如果仓库名不和用户名一致（用户的仓库），或者仓库名不和组织名一致（组织的仓库），则必须通过 <code>https://username.github.io/xxx.github.io</code> 或 <code>https://orgname.github.io/xxx.github.io</code> 来访问。很长也很不好看是不是，这就是上面说的最好以用户名或组织名来命名仓库原因。</p>
<p>因此，仓库名（这里说的仓库名是指前缀 <code>name</code> 部分，不包含后面的 <code>.github.io</code>）有两种命名方式，一种是跟用户名或组织一致，另一种则是不一致，我们姑且把和用户名或组织名一致的命名名方式叫做“直接方式”，不一致的叫做”间接方式“。</p>
<ul>
<li>仓库创建完成之后，这时候访问我们的网址，可能会得出 404 错误；这是因为没有指定 github pages 的 source 分支，但这并不是一定会出现，有些仓库会有些不会。为什么呢？还是仓库名的原因。</li>
</ul>
<p>如果仓库名是以“直接方式”命名的，则仓库自动指定了 <code>master</code> 分支为 github pages 的 source 分支，而且不能更改，所以这时候直接去访问是可以访问的；<br>如果仓库是以“间接方式”命名的，则默认是没有指定 github pages 的 source 分支的，所以这时候直接去访问就会报 404 错误。</p>
<p>对于“间接方式”命名的仓库，需要我们手动去设置 github pages 的 source 分支；打开仓库，点击 <code>Settings</code>，找到 <code>Github Pages</code> 分页，可以看到 source 下面是一个 <code>none</code>；</p>
<p> <img src="/image/coder/hexo/github_page_is_disabled.png" alt="github pages is disabled"></p>
<p> 这时我们手动选择一个分支，并点击 <code>Save</code> 按钮即可。注意，只能选 <code>master</code> 或 <code>gh-pages</code> 分支，其实选项里就没有别的分支可选，如果没有这两个分支，就先创建分支（默认 <code>master</code> 分支一定有的）。具体的可以看 github 的官方文档 <a href="https://help.github.com/articles/configuring-a-publishing-source-for-github-pages" target="_blank" rel="noopener">github pages</a>。保存之后，就可以看到 github pages 可用了，而且访问地址也列出来，这里也可以看到访问地址并不是直接用的仓库名，而是用户名+仓库名。</p>
<p> <img src="/image/coder/hexo/github_page_enable.png" alt="enable github pages"></p>
<h1 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h1><p>hexo 是一个流行的静态博客框架，安装 hexo 需要先安装 node.js 和 git 客户端；至于 hexo 的安装则非常简单，打开 git cmd，输入下面命令即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h1 id="hexo-简单用法"><a href="#hexo-简单用法" class="headerlink" title="hexo 简单用法"></a>hexo 简单用法</h1><p>关于 hexo 更详细的信息请参考官方文档 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo 文档</a>。</p>
<h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>首先，选择一个空文件夹作为我们博客存放的地方，然后在这个文件夹下右键打开 git cmd，输入下面命令，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>这样就把这个文件夹初始化为 hexo 的工作站，这步操作会把 hexo 的模板文件 clone 到这个文件夹下，可以看到主要目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- themes</span><br><span class="line">- source</span><br><span class="line">- scaffolds</span><br><span class="line">- package.json</span><br><span class="line">- _config.yml</span><br></pre></td></tr></table></figure>
<ul>
<li><code>themes</code> 文件夹下保存所有可用的主题，默认只有一个主题 <code>landscape</code>，我们可以下载别的主题，然后拷贝到这个文件夹下。</li>
<li><code>scaffolds</code> 文件夹保存文章的模板，使用 <code>hexo new</code> 新建文件的时候就会使用这个文件夹下的模板进行创建。</li>
<li><code>source</code> 就是存放我们文章的地方了，除了 <code>_post</code> 外，其它以下划线 <code>_</code> 开头的文件夹或文件都会被忽略；生成的时候，这个文件夹下的 markdown 文件和 html 文件会被解析并放到 <code>public</code> 文件夹下，其它文件则被直接拷贝到 <code>public</code> 文件夹下。</li>
<li><code>package.json</code> 文件配置了已安装的程序，默认安装了 <code>EJS, Stylus, Markdown render</code>。</li>
<li><code>_config.yml</code> 则是 hexo 的配置文件，大部分参数都是这个文件配置的。</li>
</ul>
<p>建完站之后部署到我们的 github pages，就可以 github pages 生成的 url 来访问我们的网站了。<br>首先，打开 <code>_config.yml</code> 文件，添加部署相关的配置，我们使用 git 来部署，填写 git 仓库地址和要部署的分支即可（上面说过 github pages 只能使用 <code>master</code> 分支或 <code>gh-pages</code> 分支，所以这里也只能部署到这两个分支）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:linjinxin/linjinxin.github.io.git</span><br><span class="line">  brance: master</span><br></pre></td></tr></table></figure>
<p>然后，安装 <code>hexo-deploy-git</code>，如果有多个站点，每个站点都得安装一次。在站点目录下打开 git cmd，输入 <code>npm install hexo-deployer-git --save</code> 即可。<br>最后，执行 <code>hexo d -g</code> 即可部署。<br>至此，网站就部署完了，因为我们没有添加任何文章，所以 Hexo 会自动添加一篇 <code>hello-world.md</code> 文章，所以打开 <code>https://linjinxin.github.io</code>，会看到这样的网页。</p>
<p><img src="/image/coder/hexo/hello-world.png" alt="hello-world"></p>
<p>最后的最后，把网站变成我们自己想要的样子，通过换主题、修改配置，然后新增文章，修改文章，部署，不断地重复重复又重复，我们心目中理想的个人博客就有了。接下来介绍下 Hexo 的常用配置和常用命令，看看这个重复重复又重复的过程该怎么做。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>打开 <code>_config.yml</code> 文件，修改或添加下面的参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>tile</td>
<td>网站标题</td>
<td>显示在网站显眼的地方</td>
</tr>
<tr>
<td>subtitle</td>
<td>网站副标题</td>
<td>显示在网站比较显眼的地方</td>
</tr>
<tr>
<td>author</td>
<td>你的名字</td>
<td>在网站在显示作者的名字</td>
</tr>
<tr>
<td>description</td>
<td>网站描述</td>
<td>用于 SEO，告诉搜索引擎你的网站信息</td>
</tr>
<tr>
<td>language</td>
<td>网站使用的语言</td>
<td>中文或英文等，不是指开发语言，指定的语言必须是主题支持的</td>
</tr>
<tr>
<td>timezone</td>
<td>网站时区</td>
<td>默认为电脑的时区</td>
</tr>
</tbody>
</table>
<p>更多参数请参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a>。</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li><p>建站 <code>hexo init</code></p>
</li>
<li><p>新建文章 <code>hexo new [layout] --path &lt;filename&gt; &lt;title&gt;</code></p>
<blockquote>
<p>新建文章的时候会根据指定的文章类型 <code>layout</code> 到 <code>scaffolds</code> 文件夹下对应的模板来创建文件，如果不指定 <code>layout</code>，则使用配置中的 <code>default_layout</code>；<br>Hexo 定义了三种 <code>layout</code>：<code>post, draft, page</code>，也可以自定义 <code>layout</code>；  </p>
<ul>
<li><code>post</code> 指默认的文章，使用这种 <code>layout</code> 创建的文章会放在 <code>source/_posts</code> 目录下。</li>
<li><code>draft</code> 指草稿，使用这种 <code>layout</code> 创建的文章会放在 <code>source/_drafts</code> 目录下；草稿默认不会生成并显示在页面上，可以在生成的时候加上 <code>--draft</code> 参数或者在配置文件中设置 <code>render_drafts: true</code>，又或者使用下面将要介绍的命令将草稿变成正式文章。</li>
<li><code>page</code> 则是创建其它的页面，比如在主页显示的标签页、分类页等，使用这种 <code>layout</code> 创建的页面会直接放在 <code>source</code> 目录下。</li>
<li>在 <code>scaffolds</code> 目录下添加一个 <code>mylayout.md</code> 就可以添加一个 <code>mylayout</code> 的自定义模板，使用方法和别的模板完全一样，生成的文章也放在 <code>source/_posts</code> 下，所以可以认为自定义 <code>layout</code> 是 <code>post</code> <code>layout</code> 的一个扩展。</li>
</ul>
</blockquote>
</li>
<li><p>生成静态文件 <code>hexo generate</code> 或 <code>hexo g</code></p>
<blockquote>
<p>参数 <code>--deploy</code> 或 <code>-d</code>：生成后立即部署；<br>参数 <code>--watch</code> 或 <code>-w</code>：监视文件变动。</p>
</blockquote>
</li>
<li><p>启动服务 <code>hexo server</code> 或 <code>hexo s</code></p>
<blockquote>
<p>启动服务后，就可以在本地通过 <code>localhost:4000</code> 来预览我们的网站，这样就不用每次都部署到服务器才能看到效果；<br>参数 <code>--static</code> 或 <code>-s</code>：只使用静态文件；<br>参数 <code>--port</code> 或 <code>-p</code>：重设端口；<br>参数 <code>--log</code> 或 <code>-l</code>：启动日志记录。</p>
</blockquote>
</li>
<li><p>部署网站 <code>hexo deploy</code> 或 <code>hexo d</code></p>
<blockquote>
<p>参数 <code>--generate</code> 或 <code>-g</code>：部署之前先生成静态文件；<br>部署之前必须先在 <code>_config.yml</code> 中填写部署的相关配置，否则不知道该部署到哪里去。</p>
</blockquote>
</li>
<li><p>把草稿发布成正式文章 <code>hexo publish [layout] &lt;filename&gt;</code></p>
</li>
<li><p>从其它博客系统迁移内容 <code>hexo migrate</code></p>
</li>
<li><p>清除缓存和已生成的静态文件 <code>hexo clean</code></p>
<blockquote>
<p>有时候发现更改不生效的话，先执行这个命令再生成生成静态文件。</p>
</blockquote>
</li>
<li><p>列出网站资料 <code>hexo list &lt;type&gt;</code></p>
</li>
<li><p>显示 Hexo 版本 <code>hexo version</code></p>
</li>
</ul>
<p>一般的工作流程是 <code>hexo init</code> –&gt; <code>hexo new</code> –&gt; [<code>hexo clean</code>] –&gt; <code>hexo g</code> –&gt; <code>hexo s(d)</code>，即 <strong>建站–&gt;添加文章–&gt;[清理]–&gt;生成–&gt;调试(部署)</strong>。其实经常操作的就是后面两步，这两步可以通过参数简写成一步，即 <code>hexo s -g</code>，生成后启动服务，<code>hexo d -g</code> 生成后部署。</p>
<h1 id="next-主题"><a href="#next-主题" class="headerlink" title="next 主题"></a>next 主题</h1><p>Hexo 默认使用主题 <code>landscape</code>，如果你不喜欢这个主题，可以到网上下载别的主题，放到 <code>themes</code> 目录，然后在配置文件中设置 <code>theme:&lt;your-theme&gt;</code> 即可。我使用的是网上广泛使用的 <a href="https://github.com/iissnan/hexo-theme-next.git" target="_blank" rel="noopener">Next</a> 主题，下面简单介绍 <code>Next</code> 主题的功能。</p>
<p>主题的目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- language</span><br><span class="line">- layout</span><br><span class="line">- scripts</span><br><span class="line">- source</span><br><span class="line">- _config.yml</span><br></pre></td></tr></table></figure>
<ul>
<li><code>_config.yml</code> 主题的配置文件，和主题相关的配置都放在这里面；要注意的是在 Hexo 根目录下也有一个配置文件叫 <code>_config.yml</code>，这是整个站点的配置文件。</li>
<li><code>language</code> 语言文件夹，包含所有可用的语言包，在站点配置文件中配置的语言必须是这个文件夹中存在的语言。</li>
<li><code>layout</code> 布局文件夹，存放主题的模板文件，决定了网站的呈现方式，即整个网站是如何布局显示的。注意和 Hexo 中的 <code>layout</code> 区分开，前者是指创建的文章类型，而这里的 <code>layout</code> 才是布局的意思。</li>
<li><code>scripts</code> 脚本文件夹，存放主题执行的所有 javascript 脚本。</li>
<li><code>source</code> 资源文件夹，存放主题用到的所有资源，比如 css 文件，javascript 文件，字体，图片等。和 Hexo 根目录的 <code>source</code> 文件夹一样，这里的文件如果可以渲染的话，会经过解析之后放到 <code>public</code> 目录下，不能渲染的直接拷贝到 <code>public</code> 目录下；同样的以下划线 <code>_</code> 开关的文件或文件夹会被忽略。站点的 <code>source</code> 文件夹和主题的 <code>source</code> 都是存放源文件的地方，不同的是前者存放的是我们编写的文章及文章用到的资源，后者存放的是主题内部用到的资源。</li>
</ul>
<h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>看完主题的目录结构，我们知道主题的所有配置也在一个 <code>_config.yml</code> 文件中，这个文件可以配置的东西很多，接下来简单介绍下常用的配置，更详细的信息请访问<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">官方网站</a> 或者直接看配置文件。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>favicon</td>
<td>网站图标</td>
<td>显示在浏览器的标签页里</td>
</tr>
<tr>
<td>avatar</td>
<td>头像</td>
<td>有两个存放位置，站点的 <code>source/uploads</code> 目录下，或者主题的 <code>source/images</code> 目录下</td>
</tr>
<tr>
<td>footer/icon</td>
<td>页脚图标</td>
<td></td>
</tr>
<tr>
<td>footer/copyright</td>
<td>版权信息</td>
<td>不填默认为网站作者名</td>
</tr>
<tr>
<td>footer/powered</td>
<td>是否在页脚显示“由 Hexo 强力驱动”</td>
<td></td>
</tr>
<tr>
<td>footer/theme/enable</td>
<td>是否在页脚显示 Next 信息</td>
<td></td>
</tr>
<tr>
<td>footer/theme/version</td>
<td>是否在页脚显示 Next 版本号</td>
<td></td>
</tr>
<tr>
<td>scheme</td>
<td>网页的展示方案</td>
<td>可选的方案有 <code>muse, mist, pisces, gemini</code></td>
</tr>
<tr>
<td>sidebar/position</td>
<td>侧边栏的显示位置</td>
<td>部分方案可用，<code>left</code> 或 <code>right</code></td>
</tr>
<tr>
<td>sidebar/display</td>
<td>侧边栏的显示方式</td>
<td>部分方案可用，<code>post, always, hide, remove</code></td>
</tr>
<tr>
<td>hightlight_theme</td>
<td>代码的高亮主题</td>
<td>可选 <code>normal, night, night eighties, night blue, night bright</code></td>
</tr>
<tr>
<td>font</td>
<td>可以分别为 <code>global, headings, posts, logo, codes</code> 设置字体和大小</td>
<td>建议使用 web 安全字体</td>
</tr>
<tr>
<td>index_with_subtitle</td>
<td>是否在主页显示副标题</td>
<td>部分方案可用，要在站点配置中填写副标题</td>
</tr>
<tr>
<td>seo</td>
<td>是否开启 seo</td>
<td>开启后网站上的标题层次结构将被更改，以便更好地进行 SEO 搜索</td>
</tr>
<tr>
<td>baidu_push</td>
<td>是否自动推送文章链接到百度</td>
<td>开启后可让别人通过百度搜到我们的文章</td>
</tr>
<tr>
<td><strong>第三方插件集成：</strong></td>
<td></td>
</tr>
<tr>
<td>social</td>
<td>关联外部链接</td>
<td></td>
</tr>
<tr>
<td>social_icons/enable</td>
<td>是否显示关联链接图标</td>
<td></td>
</tr>
<tr>
<td>social_icons/icons_only</td>
<td>是否只显示关联链接图标</td>
<td>隐藏文本</td>
</tr>
<tr>
<td>disqus/eanble</td>
<td>接入 <code>disqus</code> 评论系统</td>
<td><code>disqus</code> 系统需要翻墙才能访问</td>
</tr>
<tr>
<td>disqus/shortname</td>
<td>注册 <code>disqus</code> 时填的一个全网唯一 id</td>
<td></td>
</tr>
<tr>
<td><strong>设置菜单项：</strong></td>
<td></td>
</tr>
<tr>
<td>menu</td>
<td>菜单项</td>
<td></td>
</tr>
<tr>
<td>menu_icons</td>
<td>是否显示菜单图标</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="菜单项"><a href="#菜单项" class="headerlink" title="菜单项"></a>菜单项</h2><p>菜单项以 <code>key: link || icon</code> 的形式配置，<code>key</code> 是菜单的名字，显示的时候会从语言中找对应的翻译，<code>link</code> 是点击菜单项之后要跳转到的页面，<code>icon</code> 则是菜单项的图标。这里 <code>link</code> 跳转的页面默认是没有的，所以点击菜单项之后会在新页面看到一句错误信息 <code>Cannot GET /tags/</code>，所以我们要为每个菜单项创建一个新的页面，幸运的是 Hexo 已有现在的命令。之前说到新建文章的时候有三种 <code>layout</code> 可选，<code>post</code> 表示普通文章，<code>draft</code> 表示草稿，唯独 <code>page</code> 的用处不太清楚；而到了这里，<code>page</code> 的用处就很明了了，没错就是给我们创建除了主页和文章之外的其它页面。</p>
<p>比如我们要添加一个菜单项 <code>categories</code>(分类)，首先在命令行输入命令 <code>hexo new page &quot;categories&quot;</code>，会创建一个 <code>source/categories</code> 目录，这个目录下会有一个 <code>index.md</code> 文件，这就是分类菜单项点击之后要跳转到的页面，另外还有一个 <code>index</code> 目录，保存这个页面用到的资源（和普通文章一样）。<code>index.md</code> 创建的时候默认会添加文件头，包含标题和创建日期。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2018-10-29 15:14:57</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>我们可以继续编辑文件内容，将页面设计成我们的样子，比如添加一个页面类型，这样 Hexo 可以自动帮我们创建对应的功能，下面是分类页面的文件头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2018-10-29 15:14:41</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>下面是标签页面的文件头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-10-29 15:14:57</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h2><p>Markdown 可以直接解析显示图片，只需要提供一个链接即可，因此我们要先将图片上传到某个服务器上，然后再把 url 拷贝到文章中。github 没有专门上传图片的功能，我们可以自己找个仓库来上传图片，也可以找专门的 CDN 服务器来上传，比如 <a href="https://cloudinary.com/" target="_blank" rel="noopener">Cloudinary</a>。另一种方式是把图片放在本地，Markdown 不仅可以解析 url，还可以解析文件路径，我们可以把图片放在本地，通过本地路径来加载图片。</p>
<p>理论上图片可以放在本地的任意位置，只要填写正确的文件路径即可。但为了让 Hexo 能够正确解析（其实就是把图片拷贝到发布目录，并让生成的 html 文件能够正确链接到），图片的存放位置还是有要求的。</p>
<p>第一种方式是使用绝对路径，这种方式把图片放在 <code>source</code> 目录下，然后在链接那里写 <code>/...</code>。比如可以统一把图片放在 <code>source/image</code> 目录下，则链接的写法是 <code>![text](/image/xxx.png)</code>。 这种方式的图片在首页和文章都可以显示。</p>
<p>第二种方式是使用相对路径，这种方式创建一个和文章同名的文件夹，和文章放在同一层目录，图片则放在这个文件夹下，比如有一篇文章 <code>source/_posts/test.md</code>，则创建一个文件夹 <code>source/_posts/test/</code>，然后把图片放在这个文件夹下，通过 <code>![test](xxx.png)</code> 就能直接找到。这种方式的图片只能在文章中显示，在首页无法显示。</p>
<blockquote>
<p>Hexo 默认是不能使用相对路径来解析图片的，必须在配置文件中设置 <code>post_asset_folder: true</code> 才行，设置之后使用 <code>hexo new</code> 创建新文章的同时也会创建对应的文件夹。</p>
</blockquote>
<h2 id="显示流程图"><a href="#显示流程图" class="headerlink" title="显示流程图"></a>显示流程图</h2><p>通过安装插件 <code>hexo-filter-mermaid-diagrams</code> 来使我们的博客支持 mermaid 图显示。</p>
<ol>
<li>进入博客所在根目录，打开控制台，输入命令 <code>npm install hexo-filter-mermaid-diagrams</code>，如果没有错误会在 <code>node_modules</code> 目录下多出一个 <code>hexo-filter-mermaid-diagrams</code> 目录，表示安装插件成功了；</li>
<li>打开站点配置 <code>_config.yaml</code>，在最后添加下面代码，</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mermaid chart</span></span><br><span class="line">mermaid: ## mermaid url https://github.com/knsv/mermaid</span><br><span class="line">  enable: true  # default true</span><br><span class="line">  version: "7.1.2" # default v7.1.2</span><br><span class="line">  options:  # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span><br><span class="line">  <span class="comment"># startOnload: true  // default true</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>打开 <code>themes/next/layout/_partials/footer.swin</code>，在最后添加下面代码：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.mermaid.enable %&#125;</span><br><span class="line">  &lt;script src=<span class="string">'https://unpkg.com/mermaid@&#123;&#123; theme.mermaid.version &#125;&#125;/dist/mermaid.min.js'</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.mermaid) &#123;</span><br><span class="line">      mermaid.initialize(&#123;<span class="attr">theme</span>: <span class="string">'forest'</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>网上有文章说要修改站点配置 <code>_config.yaml</code> 中的 <code>external_link: false</code>，不过我试了不需要，如果你显示不成功不妨试一一下；</li>
<li>最后，重新生成，<code>hexo clean --&gt; hexo g --&gt; hexo s/d</code>，执行清理、生成、部署，就可以看效果了，注意这三步缺一不可，尤其是后面两步，一开始我没执行 <code>hexo s</code>，所以一直看不到效果。</li>
</ol>
<h3 id="修改样式"><a href="#修改样式" class="headerlink" title="修改样式"></a>修改样式</h3><p>打开 <code>themes/next/source/css/_custom/custom.styl</code>，添加对 mermaid 样式的定义，比如下面的样式将流程图的背景设置为透明。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mermaid</span> &#123;</span><br><span class="line"> <span class="attribute">background</span>: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改主页"><a href="#修改主页" class="headerlink" title="修改主页"></a>修改主页</h2><p>默认主页会显示所有文章的完全内容，但更多的时候我们想只显示文章的摘要，有三种方式来修改主页的显示。</p>
<ol>
<li><p>修改主题配置 <code>theme/next/_config.yaml</code>，找到 <code>auto_excerpt</code> 选项，设置 <code>enable: true</code> 即可开启摘要显示，<code>length</code> 为要显示的字符数量。</p>
</li>
<li><p>在文章中加入一行 <code>&lt;!-- more --&gt;</code>，则在这一行前面的内容会显示在首页摘要中，这一行后面的内容则不会显示首页摘要。</p>
</li>
<li><p>在文章标题栏中添加字段 <code>description: xxx</code>，标题栏的东西是文章的标题部分，所以 <code>description</code> 的内容在文章的详情页中显示在标题下面。</p>
</li>
</ol>
<p>第一种方式不推荐使用，这种方式是所有文章都显示固定的字符数，不好控制，而且显示的内容也不是文章的摘要部分。第二种方式和第三种方式差不多，都是要我们为每篇文章单独写个摘要，不同的是第二种方式摘要的内容在打开文章后会显示为正常内容，而第三种方式摘要的内容则在打开文章后会显示在标题栏，根据自己的需求选择第二种或第三种方式。</p>
<p>如果选用第三种方式，可以把 <code>description</code> 字段加入到文章的模板中，即修改 <code>scaffolds/post.md</code> 的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags: []</span><br><span class="line">categories: </span><br><span class="line">description: </span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h2 id="显示背景动画"><a href="#显示背景动画" class="headerlink" title="显示背景动画"></a>显示背景动画</h2><p>next 主题默认提供了一个花里胡哨的效果，就是在页面背景显示一个几何动画，开启这个动画很简单，打开主题配置 <code>theme/next/_config.yaml</code>，设置 <code>canvas_nest: true</code> 即可。注意配置文件里有两个 <code>canvas_nest</code> 配置项，第一个原来的内容是 <code>canvas_nest: false</code>，将这个改为 <code>true</code>，另一个原来的内容是 <code>canvas_nest:</code>，这是用于配置具体的动画效果的，默认不填读的是 <code>theme/next/source/lib/canvas-nest/canvas-nest.min.js</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="林锦新" />
            
              <p class="site-author-name" itemprop="name">林锦新</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/linjinxin" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">林锦新</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>





  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://ljx.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
