<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Times New Roman:300,300italic,400,400italic,700,700italic|Courier New:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="学海无涯">
<meta name="keywords" content="coding game">
<meta property="og:type" content="website">
<meta property="og:title" content="Welcome to Code World">
<meta property="og:url" content="http://linjinxin.com/index.html">
<meta property="og:site_name" content="Welcome to Code World">
<meta property="og:description" content="学海无涯">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Welcome to Code World">
<meta name="twitter:description" content="学海无涯">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://linjinxin.com/">





  <title>Welcome to Code World - Learning the ocean without boundaries</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Welcome to Code World</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Learning the ocean without boundaries</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linjinxin.com/2019/12/10/cocos2dx/scheduler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林锦新">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome to Code World">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/10/cocos2dx/scheduler/" itemprop="url">【Cocos2d-x】Cocos2d-x3.x 定时器 Scheduler 的用法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-10T21:31:43+08:00">
                2019-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cocos2d-x/" itemprop="url" rel="index">
                    <span itemprop="name">Cocos2d-x</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/10/cocos2dx/scheduler/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/12/10/cocos2dx/scheduler/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>**</p>
</blockquote>
<h1 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h1><p><code>Scheduler</code> 是定义在 <code>Director</code> 下的全局定时器，在任何地方任何时候都可以通过导演类来取得定时器实例指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scheduler *scheduler = Director::getInstance()-&gt;getScheduler();</span><br></pre></td></tr></table></figure>
<p><code>Scheuler</code> 提供以下接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">const</span> ccSchedulerFunc&amp; callback, <span class="keyword">void</span> *target, <span class="keyword">float</span> interval, <span class="keyword">unsigned</span> <span class="keyword">int</span> repeat, <span class="keyword">float</span> delay, <span class="keyword">bool</span> paused, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">const</span> ccSchedulerFunc&amp; callback, <span class="keyword">void</span> *target, <span class="keyword">float</span> interval, <span class="keyword">bool</span> paused, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(SEL_SCHEDULE selector, Ref *target, <span class="keyword">float</span> interval, <span class="keyword">unsigned</span> <span class="keyword">int</span> repeat, <span class="keyword">float</span> delay, <span class="keyword">bool</span> paused)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(SEL_SCHEDULE selector, Ref *target, <span class="keyword">float</span> interval, <span class="keyword">bool</span> paused)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleUpdate</span><span class="params">(T *target, <span class="keyword">int</span> priority, <span class="keyword">bool</span> paused)</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">scheduleScriptFunc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> handler, <span class="keyword">float</span> interval, <span class="keyword">bool</span> paused)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unschedule</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; key, <span class="keyword">void</span> *target)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unschedule</span><span class="params">(SEL_SCHEDULE selector, Ref *target)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unscheduleUpdate</span><span class="params">(<span class="keyword">void</span> *target)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unscheduleScriptEntry</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> scheduleScriptEntryID)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unscheduleAllForTarget</span><span class="params">(<span class="keyword">void</span> *target)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unscheduleAll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unscheduleAllWithMinPriority</span><span class="params">(<span class="keyword">int</span> minPriority)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isScheduled</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; key, <span class="keyword">const</span> <span class="keyword">void</span> *target)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isScheduled</span><span class="params">(SEL_SCHEDULE selector, <span class="keyword">const</span> Ref *target)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pauseTarget</span><span class="params">(<span class="keyword">void</span> *target)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">void</span>*&gt; pauseAllTargets();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">void</span>*&gt; pauseAllTargetsWithMinPriority(<span class="keyword">int</span> minPriority);</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isTargetPaused</span><span class="params">(<span class="keyword">void</span> *target)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resumeTarget</span><span class="params">(<span class="keyword">void</span> *target)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resumeTargets</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">void</span>*&gt;&amp; targetsToResume)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">CC_DEPRECATED_ATTRIBUTE <span class="keyword">void</span> <span class="title">scheduleSelector</span><span class="params">(SEL_SCHEDULE selector, Ref *target, <span class="keyword">float</span> interval, <span class="keyword">bool</span> paused)</span></span>;</span><br><span class="line"><span class="function">CC_DEPRECATED_ATTRIBUTE <span class="keyword">void</span> <span class="title">scheduleSelector</span><span class="params">(SEL_SCHEDULE selector, Ref *target, <span class="keyword">float</span> interval, <span class="keyword">unsigned</span> <span class="keyword">int</span> repeat, <span class="keyword">float</span> delay, <span class="keyword">bool</span> paused)</span></span>;</span><br><span class="line"><span class="function">CC_DEPRECATED_ATTRIBUTE <span class="keyword">void</span> <span class="title">scheduleUpdateForTarget</span><span class="params">(T* target, <span class="keyword">int</span> priority, <span class="keyword">bool</span> paused)</span></span>;</span><br><span class="line"><span class="function">CC_DEPRECATED_ATTRIBUTE <span class="keyword">void</span> <span class="title">unscheduleSelector</span><span class="params">(SEL_SCHEDULE selector, Ref *target)</span></span>;</span><br><span class="line"><span class="function">CC_DEPRECATED_ATTRIBUTE <span class="keyword">void</span> <span class="title">unscheduleUpdateForTarget</span><span class="params">(Ref *target)</span></span>;</span><br><span class="line"><span class="function">CC_DEPRECATED_ATTRIBUTE <span class="keyword">bool</span> <span class="title">isScheduledForTarget</span><span class="params">(Ref *target, SEL_SCHEDULE selector)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这些接口分为四组，第一组接口为注册定时器，第二组接口为反注册定时器，第三组为包括判断是否注册了定时器、暂停定时器和恢复定时器，最后一组的 6 个接口前面都有修饰符 <code>CC_DEPRECATED_ATTRIBUTE</code>，表示这是一个废弃的接口，之所以还留着是为了兼容旧版本引擎，所以这几个接口直接忽略就行。最常用的是第一组和第二组，注册和反注册是成对的，我们重点看下注册定时器就行。</p>
<ol>
<li><code>schedule</code> 注册自定义定时器，分为两组，每个组有两个函数，一个完整参数的函数和一个简化参数的函数。第一组的回调函数类型为 <code>ccScheduleFunc</code>，接收一个非成员函数，然后定义一个 <code>key</code> 用于标识这个定时器；第二组的回调函数类型为 <code>SEL_SCHEDULE</code>，接收一个成员函数，关于这两个回调函数类型，下面再详细讲。</li>
</ol>
<ul>
<li><code>@param ccScheduleFunc</code> 定时器触发时的回调函数，非成员函数；</li>
<li><code>@param SEL_SCHEDULE</code> 定时器触发时的回调函数，成员函数；</li>
<li><code>@param target</code> 注册定时器的目标对象，通常是定义回调函数的对象；</li>
<li><code>@param interval</code> 触发间隔；</li>
<li><code>@param repeat</code> 触发次数，1 为单次触发，<code>CC_REPEAT_FOREVER</code> 为永久触发，其值其实是 <code>unsigned int</code> 的最大值；</li>
<li><code>@param delay</code> 首次触发的延迟时间；</li>
<li><code>@param paused</code> 是否暂停；</li>
<li><code>@param key</code> 定时器的唯一标识，通过这个 key 可以拿到对应的定时器，比如反注册的时候。</li>
</ul>
<ol start="2">
<li><code>sheduleUpdate</code> 注册每帧调度的定时器，不需要指定回调函数，触发时会自动回调到目标对象的 <code>update</code> 方法，如果目标对象没有 <code>update</code> 方法，则编译的时候就会报错。</li>
</ol>
<ul>
<li><code>@param target</code> 注册定时器的目标对象；</li>
<li><code>@param priority</code> 回调的优先级，数字越小越先回调，因为 <code>Scheduler</code> 可以为多个对象注册每帧调度，所以需要说明哪个对象的 <code>update</code> 方法先执行，哪个后执行；</li>
<li><code>@param paused</code> 是否暂停。</li>
</ul>
<ol start="3">
<li><code>scheduleScriptFunc</code> 这是绑定到脚本的接口，提供给 Lua 代码使用，一般不会在 C++ 层调用。</li>
</ol>
<ul>
<li><code>@param handler</code> 回调函数；</li>
<li><code>@param interval</code> 触发间隔；</li>
<li><code>@param paused</code> 是否暂停。</li>
</ul>
<p>下面是具体的用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BaseScene::update(<span class="keyword">float</span> delta)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"update per frame, delta = %f"</span>, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BaseScene::updateOnce(<span class="keyword">float</span> delta)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"update once, delta = %f"</span>, delta);</span><br><span class="line">    Scheduler *scheduler = Director::getInstance()-&gt;getScheduler();</span><br><span class="line">    scheduler-&gt;unschedule(CC_SCHEDULE_SELECTOR(BaseScene::updateOnce), <span class="keyword">this</span>);</span><br><span class="line">    scheduler-&gt;unschedule(CC_SCHEDULE_SELECTOR(BaseScene::onProgress), <span class="keyword">this</span>);</span><br><span class="line">    scheduler-&gt;unschedule(<span class="string">"func"</span>, <span class="keyword">this</span>);</span><br><span class="line">    scheduler-&gt;unscheduleUpdate(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BaseScene::onProgress(<span class="keyword">float</span> delta)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"update with target, delta = %f"</span>, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onProgress2</span><span class="params">(<span class="keyword">float</span> delta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"update with function, delta = %f"</span>, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BaseScene::testScheduler()</span><br><span class="line">&#123;</span><br><span class="line">    Scheduler *scheduler = Director::getInstance()-&gt;getScheduler();</span><br><span class="line">    scheduler-&gt;schedule(CC_SCHEDULE_SELECTOR(BaseScene::updateOnce), <span class="keyword">this</span>, <span class="number">0.5f</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">    scheduler-&gt;schedule(CC_SCHEDULE_SELECTOR(BaseScene::onProgress), <span class="keyword">this</span>, <span class="number">0.1f</span>, <span class="literal">false</span>);</span><br><span class="line">    scheduler-&gt;schedule(onProgress2, <span class="keyword">this</span>, <span class="number">0.2f</span>, kRepeatForever, <span class="number">0</span>, <span class="literal">false</span>, <span class="string">"func"</span>);</span><br><span class="line">    scheduler-&gt;scheduleUpdate(<span class="keyword">this</span>, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">update per frame, delta = 0.016666</span><br><span class="line">update per frame, delta = 0.062076</span><br><span class="line">update per frame, delta = 0.016666</span><br><span class="line">update per frame, delta = 0.016666</span><br><span class="line">update per frame, delta = 0.016666</span><br><span class="line">update with target, delta = 0.100000</span><br><span class="line">update per frame, delta = 0.016666</span><br><span class="line">update per frame, delta = 0.016667</span><br><span class="line">update per frame, delta = 0.016667</span><br><span class="line">update per frame, delta = 0.016666</span><br><span class="line">update per frame, delta = 0.016666</span><br><span class="line">update per frame, delta = 0.016666</span><br><span class="line">update with target, delta = 0.100000</span><br><span class="line">update with function, delta = 0.200000</span><br><span class="line">update per frame, delta = 0.016666</span><br><span class="line">update per frame, delta = 0.016666</span><br><span class="line">update per frame, delta = 0.016666</span><br><span class="line">update per frame, delta = 0.016666</span><br><span class="line">update per frame, delta = 0.016666</span><br><span class="line">update per frame, delta = 0.016668</span><br><span class="line">update with target, delta = 0.100000</span><br><span class="line">update per frame, delta = 0.016666</span><br><span class="line">update per frame, delta = 0.016666</span><br><span class="line">update per frame, delta = 0.016667</span><br><span class="line">update per frame, delta = 0.016664</span><br><span class="line">update per frame, delta = 0.016666</span><br><span class="line">update per frame, delta = 0.016667</span><br><span class="line">update with target, delta = 0.100000</span><br><span class="line">update with function, delta = 0.200000</span><br><span class="line">update per frame, delta = 0.016666</span><br><span class="line">update per frame, delta = 0.016666</span><br><span class="line">update per frame, delta = 0.016681</span><br><span class="line">update per frame, delta = 0.016666</span><br><span class="line">update per frame, delta = 0.016666</span><br><span class="line">update per frame, delta = 0.016667</span><br><span class="line">update once, delta = 0.500000</span><br></pre></td></tr></table></figure>
<p>Lua 使用方法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> callback1 = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> callback2 = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> timerId1 = Scheduler:scheduleScriptFunc(callback1, <span class="number">0.1</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">local</span> timerId2 = Scheduler.scheduleUpdate(callback2)</span><br><span class="line"></span><br><span class="line">Scheduler:unscheduleScriptEntry(timerId1)</span><br><span class="line">Scheduler:unscheduleScriptEntry(timerId2)</span><br></pre></td></tr></table></figure>
<h1 id="私有定时器"><a href="#私有定时器" class="headerlink" title="私有定时器"></a>私有定时器</h1><p>除了导演管理的全局定时器，每个 <code>Node</code> 还有自己的私有定时器，这个私有定时器是个指针，默认指向的还是 <code>Director</code> 管理的全局定时器，只是为了方便使用，不用每次都去 <code>Director</code> 中去获取 <code>Scheduler</code> 实例。因此，默认情况下整个游戏还是只有一个定时器，那就是导演类管理下的”全局定时器“，这个定时器的刷新由导演控制，即导演刷新的时候刷新定时器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Node::Node()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    _director = Director::getInstance();</span><br><span class="line">    _scheduler = _director-&gt;getScheduler();</span><br><span class="line">    _scheduler-&gt;retain();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Director::init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    _scheduler = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) Scheduler();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Director::mainLoop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    drawScene();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Director::drawScene()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    _scheduler-&gt;update(_deltaTime);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过接口 <code>setScheduler</code> 来给 <code>Node</code> 设置一个新的 <code>Scheduler</code>，但要注意的是这个自定义的 <code>Scheduler</code> 默认是不会刷新的，不会刷新就意味着不会调度，是个死的调度器，所以要自己在合适地方调用 <code>scheduler-&gt;update(dt)</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> scheduler = <span class="keyword">new</span> Scheduler();</span><br><span class="line">node-&gt;setScheduler(scheduler);</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">customLoop</span><span class="params">(dt)</span></span></span><br><span class="line">    scheduler-&gt;update(dt);</span><br></pre></td></tr></table></figure>
<p><code>Node</code> 提供的接口和 <code>Scheduler</code> 基本一样，需要用的时候去查 API 或源码即可，这些接口的内部还是调用的 <code>Scheduler</code> 的相关接口来实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Node::schedule(<span class="keyword">const</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">float</span>)&gt;&amp; callback, <span class="keyword">float</span> interval, <span class="keyword">unsigned</span> <span class="keyword">int</span> repeat, <span class="keyword">float</span> delay, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;key)</span><br><span class="line">&#123;</span><br><span class="line">    _scheduler-&gt;schedule(callback, <span class="keyword">this</span>, interval, repeat, delay, !_running, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>Node</code> 没有自定义 <code>Scheduler</code>，则下面语句是等价的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Scheduler *scheduler = Director::getInstance()-&gt;getScheduler();</span><br><span class="line">scheduler-&gt;schedule(CC_SCHEDULE_SELECTOR(BaseScene::updateOnce), <span class="keyword">this</span>, <span class="number">0.5f</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">scheduler-&gt;schedule(CC_SCHEDULE_SELECTOR(BaseScene::onProgress), <span class="keyword">this</span>, <span class="number">0.1f</span>, <span class="literal">false</span>);</span><br><span class="line">scheduler-&gt;schedule(onProgress2, <span class="keyword">this</span>, <span class="number">0.2f</span>, kRepeatForever, <span class="number">0</span>, <span class="literal">false</span>, <span class="string">"func"</span>);</span><br><span class="line">scheduler-&gt;scheduleUpdate(<span class="keyword">this</span>, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;schedule(CC_SCHEDULE_SELECTOR(BaseScene::updateOnce), <span class="number">0.5f</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;schedule(CC_SCHEDULE_SELECTOR(BaseScene::onProgress), <span class="number">0.1f</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;schedule(onProgress2, <span class="number">0.2f</span>, <span class="string">"func"</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;scheduleUpdate();</span><br></pre></td></tr></table></figure>
<h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><p>接下来我们回过头来看 <code>schedule</code> 的回调函数类型 <code>ccScheduleFunc</code> 和 <code>SEL_SCHEDULE</code>，无论是哪种，<code>schedule</code> 接收的第一个参数都是一个“函数”，调度器调度的时候执行这个函数。</p>
<h2 id="SEL-SCHEDULE"><a href="#SEL-SCHEDULE" class="headerlink" title="SEL_SCHEDULE"></a>SEL_SCHEDULE</h2><p>首先让我们一步步了解一下 C++ 中的宏定义、类型重定义、函数指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZERO 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> INT;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*FUNC)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">float</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(DemoClass::*FUNC2)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">float</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>宏定义 <code>#define A B</code>，定义一个宏 <code>A</code>，用这个宏来表示 <code>B</code>，编译的时候会把宏替换成对应的值，比如 <code>#define ZERO 0</code>，则代码里可用 <code>ZERO</code> 来表示 0，但编译的时候会统一将 <code>ZERO</code> 替换成 0。</p>
<p>类型重定义 <code>typedef B A;</code>，<code>typedef</code> 则刚好相反，它是给数据类型 <code>B</code> 起一个别名 <code>A</code>，比如 <code>typedef int INT;</code>。</p>
<p><code>define</code> 与 <code>typedef</code> 的区别：</p>
<ol>
<li>宏定义是预处理语句，编译的时候处理，结尾无分号；类型重定义是代码语句，结尾必须分号。</li>
<li>定义宏 A 表示 B，给类型 B 起别名 A，宏定义是宏在前面，值在后面；类型重定义是值在前面，别名在后面。</li>
</ol>
<p><code>typedef</code> 可以给数据类型起一个别名，还可以用于定义函数指针，用一个简短的名字表示一个函数原型，其语法为 <code>typedef void(*FUNC)(int, float)</code>，这么一看很难理解，调整一下顺序就好理解多了，<code>typedef void(int, float) (*FUNC)</code>，<code>void(int, float)</code> 是一个函数原型，给其起个别名 <code>FUNC</code>，<code>*</code> 表示这是一个指针类型，即 <code>FUNC</code> 是一个函数指针类型，这个函数指针只能赋值原型为 <code>void(int, float)</code> 的函数地址。只是语法要求把别名 <code>FUNC</code> 放在返回值 <code>void</code> 和参数列表 <code>(int, float)</code> 之间，所以最后的形式为 <code>typedef void(*FUNC)(int, float)</code>。</p>
<p><code>FUNC</code> 现在是一个数据类型了，直接用其定义变量即可，直接赋值一个函数地址即可，看下面例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">float</span> b)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"foo  "</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*FUNC)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">float</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FUNC f = foo;</span><br><span class="line">    f(<span class="number">3</span>, <span class="number">3.14</span>); <span class="comment">// foo  6.14</span></span><br><span class="line">    foo(<span class="number">3</span>, <span class="number">3.14</span>); <span class="comment">// foo  6.14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了全局函数，<code>typedef</code> 定义函数指针同样适用于类成员函数，只需要在类型前面加上类名，<code>typedef void(DemoClass::*FUNC2)(int, float)</code>，这样只有类 <code>DemoClass</code> 和其子类的原型为 <code>void(float, int)</code> 的方法才能赋值给函数指针类型 <code>FUNC2</code>。类静态函数指针和全局函数指针一样，不需要类名，如果函数原型一样，则一个函数指针类型既可以接收全局函数，也可以接收类静态方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">float</span> b)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"foo  "</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">float</span> b)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"static foo  "</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(DemoClass::*FUNC2)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">float</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FUNC fc = &amp;DemoClass::foo2;</span><br><span class="line">    fc(<span class="number">1</span>, <span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">    FUNC2 f = &amp;DemoClass::foo;</span><br><span class="line"></span><br><span class="line">    DemoClass *demo = <span class="keyword">new</span> DemoClass();</span><br><span class="line">    (demo-&gt;*f)(<span class="number">1</span>, <span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">    DemoClass demo2 = DemoClass();</span><br><span class="line">    (demo2.*f)(<span class="number">1</span>, <span class="number">3.14</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FUNC</code> 是前面定义的一个函数指针类型，用于赋值全局函数，在这里赋值一个类的静态函数也是可以的。<code>FUNC2</code> 是用于赋值 <code>DemoClass</code> 成员函数的函数指针类型，要注意的是类成员函数，执行的时候需要一个类实例对象，指针也好，对象也好，然后函数指针前面需要加上一个 <code>*</code>，比如 <code>demo-&gt;*f()</code>，<code>demo.*f()</code>。还有一点，无论是类静态方法还是成员方法，赋值给函数指针的时候都需要在前面加上 <code>&amp;</code>，用于取其地址，而全局函数加不加都行，对应的全局函数调用的时候前面加不加 <code>*</code> 都行。</p>
<p>准备工作完了，接下来看看 <code>SEL_SCHEDULE</code> 的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(Ref::*SEL_SCHEDULE)</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CC_SCHEDULE_SELECTOR(_SELECTOR) static_cast<span class="meta-string">&lt;cocos2d::SEL_SCHEDULE&gt;(&amp;_SELECTOR)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(SEL_SCHEDULE selector, Ref *target, <span class="keyword">float</span> interval, <span class="keyword">unsigned</span> <span class="keyword">int</span> repeat, <span class="keyword">float</span> delay, <span class="keyword">bool</span> paused)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一行定义函数指针类型 <code>SEL_SCHEDULE</code>，这个函数指针接收类 <code>Ref</code> 及其子类的原型为 <code>void(float)</code> 的成员函数。</p>
<p>第二行定义一个宏 <code>CC_SCHEDULE_SELECTOR</code>，它的值是 <code>static_cast&lt;SEL_SCHEDULE&gt;(&amp;_SELECTOR)</code>，即将传进来的值强制转换成 <code>SEL_SCHEDULE</code> 类型，<code>cocos2d::</code> 是 <code>SEL_SCHEDULE</code> 所在的命名空间而已。之所以需要 <code>static_cast</code> 作强制类型转换，是因为传进来的函数可以是 <code>Ref</code> 子类的方法，如果是 <code>Ref</code> 的方法，这一步也是可以省的。</p>
<p>一般注册一个定时器是这样写的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduler-&gt;schedule(CC_SCHEDULE_SELECTOR(BaseScene::onProgress), <span class="keyword">this</span>, <span class="number">0.1f</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduler-&gt;schedule(<span class="keyword">static_cast</span>&lt;SEL_SCHEDULE&gt;(&amp;BaseScene::onProgress), <span class="keyword">this</span>, <span class="number">0.1f</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>如果是 <code>Ref</code> 对象，还等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduler-&gt;schedule(&amp;Ref::onProgress, <span class="keyword">this</span>, <span class="number">0.1f</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>归根到底，<code>SEL_SCHEDULE</code> 表示的是一个函数指针，调用 <code>scheule</code> 的时候传一个函数名进行即可，只是这个函数必须是 <code>Ref</code> 类的原型为 <code>void(float)</code> 的函数，而且如果是 <code>Ref</code> 子类的方法，还必须使用 <code>static_cast</code> 作一下强制类型转换。</p>
<h2 id="ccSchedulerFunc"><a href="#ccSchedulerFunc" class="headerlink" title="ccSchedulerFunc"></a>ccSchedulerFunc</h2><p><code>&lt;functional&gt;</code> 库中有一种定义函数指针更简便的方法，即使用数据类型 <code>std::function&lt;函数原型&gt;</code> ，使用 <code>typedef</code> 给其自定义一个别名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" + "</span> &lt;&lt; b &lt;&lt; <span class="string">" = "</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; FOO;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; func1 = foo;</span><br><span class="line">    FOO func2 = foo;</span><br><span class="line">    <span class="comment">// func1 == func2 == foo</span></span><br><span class="line">    foo(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    func1(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    func2(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了全局函数，<code>std::function</code> 对类成员函数和类静态函数也是适用的，语法是<code>typedef std::function&lt;void(DemoClass, int)&gt; FOO2;</code>，不过 cocos2d-x 中只有全局函数用了 <code>std::function</code>，这里就不展开讲了。<code>ccSchedulerFunc</code> 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">float</span>)&gt; ccSchedulerFunc;</span><br></pre></td></tr></table></figure>
<p>特别简单，这是一个函数指针类型，接收原型为 <code>void(float)</code> 的全局函数；使用也很简单，直接赋值函数名即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onProgress2</span><span class="params">(<span class="keyword">float</span> delta)</span> </span>&#123;&#125;</span><br><span class="line">scheduler-&gt;schedule(onProgress2, <span class="keyword">this</span>, <span class="number">0.2f</span>, kRepeatForever, <span class="number">0</span>, <span class="literal">false</span>, <span class="string">"func"</span>);</span><br></pre></td></tr></table></figure>
<p>总结一下，如果回调函数是类成员函数，则将其转成 <code>SEL_SCHEDULE</code> 类型，通过宏 <code>CC_SCHEDULE_SELECTOR</code> 进行强制转换；反之则为 <code>ccSchedulerFunc</code> 类型。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linjinxin.com/2019/12/07/cocos2dx/dev-env/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林锦新">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome to Code World">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/07/cocos2dx/dev-env/" itemprop="url">【Cocos2d-x】Cocos2d-x 开发环境</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-07T17:40:26+08:00">
                2019-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cocos2d-x/" itemprop="url" rel="index">
                    <span itemprop="name">Cocos2d-x</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/07/cocos2dx/dev-env/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/12/07/cocos2dx/dev-env/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>**</p>
</blockquote>
<h1 id="安装-Android"><a href="#安装-Android" class="headerlink" title="安装 Android"></a>安装 Android</h1><h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><h3 id="Java-JDK"><a href="#Java-JDK" class="headerlink" title="Java(JDK)"></a>Java(JDK)</h3><p><strong>Java Development Kit</strong>：Java 开发工具包。</p>
<p>环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> JAVA_HOME = D:\Android\jdk8</span><br><span class="line"><span class="built_in">set</span> CLASSPATH =  .;%JAVA_HOME%\lib</span><br><span class="line"><span class="built_in">set</span> Path = %Path%;D:\Android\jdk8\bin</span><br></pre></td></tr></table></figure>
<h3 id="Android-SDK"><a href="#Android-SDK" class="headerlink" title="Android(SDK)"></a>Android(SDK)</h3><p><strong>Android Sofeware Development Kit</strong>：Android 软件开发工具包。</p>
<p>环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> ANDROID_SDK_ROOT = D:\Android\SDK</span><br></pre></td></tr></table></figure>
<h2 id="原生编译环境"><a href="#原生编译环境" class="headerlink" title="原生编译环境"></a>原生编译环境</h2><h3 id="C-to-Java-NDK"><a href="#C-to-Java-NDK" class="headerlink" title="C++ to Java(NDK)"></a>C++ to Java(NDK)</h3><p><strong>Native Development Kit</strong>：原生开发工具包。</p>
<p>环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> ANDROID_NDK_ROOT = D:\Android\android-ndk-r10e</span><br></pre></td></tr></table></figure>
<h2 id="编译打包"><a href="#编译打包" class="headerlink" title="编译打包"></a>编译打包</h2><p>两种打包工具，<strong>ant</strong> 和 <strong>gradle</strong>，ant 比较早期，<strong>eclipse</strong> 使用；gradle 是目前主流的 android 打包工具，<strong>android studio</strong> 使用。</p>
<h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><p>这是 Gradle 的 <a href="http://tools.android.com/tech-docs/new-build-system/user-guide" target="_blank" rel="noopener">官方文档</a> 以及一篇 <a href="https://www.jianshu.com/p/001abe1d8e95" target="_blank" rel="noopener">参考教程</a>。</p>
<p>一个 Gradle 框架的 multi-project 结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">project</span><br><span class="line">├── project1(app)</span><br><span class="line">│   ├── build.gradle #构建脚本</span><br><span class="line">├── project2(module1)</span><br><span class="line">│   ├── build.gradle #构建脚本</span><br><span class="line">├── gradle</span><br><span class="line">│   └── wrapper    #gradle包装</span><br><span class="line">├── build.gradle   #工程构建脚本</span><br><span class="line">├── gradlew         #gradle wrapper linux shell脚本</span><br><span class="line">├── gradlew.bat     #gradle wrapper windows bat脚本</span><br><span class="line">|—— settings.gradle #工程配置</span><br><span class="line">|__ gradle.properties #本地配置</span><br></pre></td></tr></table></figure>
<p>这里的 project 对应 Android Studio 项目中的 moudle，进一步对应到 cocos2dx 的工程，app 即为工程主模块，module1 即为 libcocos2dx，一个 cocos2dx 项目在 Android Studio 中的基本项目结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">proj.gradle</span><br><span class="line">|—— projandroid</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">|   |—— src</span><br><span class="line">├── libcocos2dx</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">|   |—— src</span><br><span class="line">├── gradle</span><br><span class="line">│   └── wrapper</span><br><span class="line">├── build.gradle</span><br><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br><span class="line">|—— settings.gradle</span><br><span class="line">|__ local.properties</span><br></pre></td></tr></table></figure>
<p><code>src</code> 目录为源文件目录，包括 java 源代码 <code>java</code>、android 工程资源 <code>res</code>、资源目录 <code>assets</code>(游戏的全部内容包括 lua 代码，资源、音效全放这里)、依赖的库文件 <code>jniLibs</code> 等等，结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">|—— main</span><br><span class="line">│   ├── java</span><br><span class="line">│   ├── res</span><br><span class="line">│   ├── assets</span><br><span class="line">│   ├── jniLibs</span><br></pre></td></tr></table></figure>
<p>除了 <code>src</code> 目录，最重要的就是 gradle 打包需要的脚本文件 <code>build.gradle</code> 及相关的配置文件，每一个 module 都有一个 <code>build.grade</code>，主工程也需要一个 <code>build.grade</code>。</p>
<p>主工程的 <code>build.grade</code> 定义了对所有 module 都生效的配置和动作，其中最重要的是定义了使用的 grade 工具版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    classpath &apos;com.android.tools.build:gradle:3.5.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 module 各自定义自己的打包配置和动作，下面列几个主要的项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line">apply plugin: &apos;com.android.library&apos;</span><br></pre></td></tr></table></figure>
<p>这里配置了该模块的性质，<code>application</code> 表示是可运行的主模块，比如上面的 <code>projandroid</code>，<code>library</code> 表示不能独立运行的库，由其它模块包含使用，比如上面的 <code>libcocos2dx</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation project(path: &apos;:libcocos2dx&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义模块之间的依赖性，如 <code>projandroid</code> 依赖于 <code>libcocos2dx</code>，有了这层依赖关系，<code>projandroid</code> 生成的时候就会先生成 <code>libcocos2dx</code>，然后将其生成的文件作为一个库保存在其 <code>src/main/jniLibs</code> 下，然后一起打包进 apk 包。</p>
<p><code>settings.grade</code> 定义了该工程包括的模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include &apos;:libcocos2dx&apos;</span><br><span class="line">include &apos;:projandroid&apos;</span><br></pre></td></tr></table></figure>
<p><code>local.properties</code> 做一些本地配置，主要保存了 sdk 和 ndk 的路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ndk.dir=D\:\\Android\\android-ndk-r10e</span><br><span class="line">sdk.dir=D\:\\Android\\SDK</span><br></pre></td></tr></table></figure>
<h3 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h3><p>安装 Android Studio。</p>
<h1 id="安装-Visual-Studio"><a href="#安装-Visual-Studio" class="headerlink" title="安装 Visual Studio"></a>安装 Visual Studio</h1><p>没啥好说的，装就是了。建议安装 2015 版本或 2017 版本，2015 以下有点老了，2019 有点太新了，当然现在电脑配置高了，安装多个版本也是一个不错的选择。</p>
<h1 id="安装-Python27"><a href="#安装-Python27" class="headerlink" title="安装 Python27"></a>安装 Python27</h1><p>Python 要安装 2.x 的版本，安装完配置环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> PYTHON_BIN = C:\Python27\python.exe</span><br><span class="line"><span class="built_in">set</span> Path = %Path%;C:\Python27;C:\Python27\Scripts</span><br></pre></td></tr></table></figure>
<h1 id="安装-Cocos2d-x3-17"><a href="#安装-Cocos2d-x3-17" class="headerlink" title="安装 Cocos2d-x3.17"></a>安装 Cocos2d-x3.17</h1><p>从官网下载最新版本的 Cocos2d-x3.17，解压之后运行 <code>setup.py</code>，这个脚本会自动检查环境变量并补全以下环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> COCOS_X_ROOT = D:\engine</span><br><span class="line"><span class="built_in">set</span> COCOS_CONSOLE_ROOT = D:\engine\cocos2d-x-3.17.2\tools\cocos2d-console\bin</span><br><span class="line"><span class="built_in">set</span> COCOS_TEMPLATES_ROOT = D:\engine\cocos2d-x-3.17.2\templates</span><br></pre></td></tr></table></figure>
<p>引擎的目录结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|-cocos2d-x-3.17</span><br><span class="line">    |-build</span><br><span class="line">    |-docs</span><br><span class="line">    |-tests</span><br><span class="line">    |-templates</span><br><span class="line">    |-extensions</span><br><span class="line">    |-external</span><br><span class="line">    |-tools</span><br><span class="line">    |-cocos</span><br></pre></td></tr></table></figure>
<p>源码在 <code>cocos, extensions, external</code> 这三个目录下，<code>extensions</code> 为一些扩展，<code>external</code> 主要是第三方库。<code>tests</code> 目录下有官方提供的例子，<code>c++, lua, js</code> 三种语言的例子都有，可打开运行看看。</p>
<p>创建工程的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">usage: cocos new [-h] [-p PACKAGE_NAME] [-d DIRECTORY] [-t TEMPLATE_NAME]</span><br><span class="line">                 [--ios-bundleid IOS_BUNDLEID] [--mac-bundleid MAC_BUNDLEID]</span><br><span class="line">                 [-e ENGINE_PATH] [--portrait] -l &#123;cpp,lua,js&#125;</span><br><span class="line">                 [PROJECT_NAME]</span><br></pre></td></tr></table></figure>
<p>打开命令行，输入 <code>cocos new -p com.xxx.game.mygame -d d:/learn/cocos -l cpp mygame</code> 即可创建一个 C++ 工程。</p>
<h2 id="工程配置"><a href="#工程配置" class="headerlink" title="工程配置"></a>工程配置</h2><p>创建的工程默认是不开控制台，打开 <code>main.cpp</code>，添加下面代码开启控制台。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> WINAPI _tWinMain(HINSTANCE hInstance,</span><br><span class="line">                       HINSTANCE hPrevInstance,</span><br><span class="line">                       LPTSTR    lpCmdLine,</span><br><span class="line">                       <span class="keyword">int</span>       nCmdShow)</span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(hPrevInstance);</span><br><span class="line">    UNREFERENCED_PARAMETER(lpCmdLine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add to open console</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> USE_WIN32_CONSOLE</span></span><br><span class="line">        AllocConsole();</span><br><span class="line">        freopen(<span class="string">"CONIN$"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">"CONOUT$"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        freopen(<span class="string">"CONOUT$"</span>, <span class="string">"w"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line">    AppDelegate app;</span><br><span class="line">    <span class="keyword">return</span> Application::getInstance()-&gt;run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加宏定义 <code>USE_WIN_CONSOLE</code> 即可开启控制台，去掉这个宏定义就关闭控制台。在代码中定义 <code>#define USER_WIN_CONSOLE</code>，或者在 <em>项目属性-&gt;C/C++-&gt;预处理器-&gt;预处理器定义</em> 中添加 <code>USE_WIN32_CONSOLE</code>。</p>
<p>这是 C++ 工程的做法，Lua 工程也可以这么做，但有更好的做法，定义宏 <code>#define SIMULATOR_WITH_CONSOLE_AND_MENU 1</code> 即可，不仅可以开启控制台，还开启了菜单栏，可以在运行时改变分辨率以及按 F5 刷新。这个宏在 <code>SimulatorWin.cpp</code> 中定义，默认是定义为 0，把它改成 1 即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linjinxin.com/2019/12/07/lua/c++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林锦新">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome to Code World">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/07/lua/c++/" itemprop="url">【Lua】Lua 与 C++ 交互及 Lua 绑定</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-07T17:38:21+08:00">
                2019-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Lua/" itemprop="url" rel="index">
                    <span itemprop="name">Lua</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/07/lua/c++/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/12/07/lua/c++/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>**</p>
</blockquote>
<p>Lua 是一个用 C 编写的库，但这个库不仅能编译成动态链接库和静态链接库给其它 C 程序使用，也能编译成单独的可执行文件，比如用于编译 Lua 源代码的 <strong>Lua编译器</strong> 和 Lua 独立运行环境 <strong>Lua解释器</strong>。有了解释器，理论上 Lua 代码是可以独立执行的，不需要嵌入到任何高级语言的程序中去，而且，反过来 Lua 代码还可以访问 C 代码编写的一些库。但是，现实中 Lua 解释器的运用场景并不多，更多的还是将 Lua 代码嵌入到高级语言程序中去，同时 Lua 也会调用高级程序语言的一些库，也就是 <strong>Lua 和 C 相互调用</strong>。比如在使用 cocos2dx 引擎实现的游戏中，游戏引擎使用 C++ 实现，游戏逻辑使用 Lua 实现，然后引擎执行 Lua 代码(C++调用Lua)，而 Lua 代码又会使用到引擎库的功能(Lua调用C++)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">cocos2dx引擎 --&gt; |执行| game[游戏逻辑]</span><br><span class="line">game --&gt; |调用| cocos2dx库</span><br><span class="line">C++程序 --&gt; |执行| lua[Lua代码]</span><br><span class="line">lua --&gt; |调用| C++库</span><br></pre></td></tr></table></figure>
<h1 id="C-调-Lua"><a href="#C-调-Lua" class="headerlink" title="C 调 Lua"></a>C 调 Lua</h1><p>Lua 源码是用 C 语言写的，可以把 Lua 源码看成是一个 C 语言库，C 程序只要包含了这个库，就具备了与 Lua 交互的条件。C 程序通过 C API 创建 Lua 执行环境、执行 Lua 代码、访问 Lua 变量和函数。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>首先，C 程序会创建一个 Lua 执行环境 <code>lua_State</code>，这个执行环境会维护一个栈，所有的 Lua&amp;C 交互都基于这个栈。</p>
<p>栈的索引有两种，栈底为 1，然后往栈顶递增，栈顶索引未知，即从栈底到栈顶索引为 1,2,3,…；栈顶为 -1，然后往栈底递减，栈底索引未知，即从栈顶到栈底索引为 -1,-2,-3,…。</p>
<h2 id="C-API"><a href="#C-API" class="headerlink" title="C API"></a>C API</h2><p>基础操作</p>
<ul>
<li><strong>luaL_newstate</strong> 创建 Lua 执行环境</li>
<li><strong>luaL_openlibs</strong> 打开所有 Lua 标准库</li>
<li><strong>lua_loadbuffer</strong> 加载 Lua 代码块并压入栈中</li>
<li><strong>lua_pcall</strong> 将代码块从栈中弹出并执行</li>
<li><strong>lua_close</strong> 关闭 Lua 执行环境</li>
</ul>
<p>操作栈</p>
<ul>
<li><strong>lua_pushinteger</strong> 压入某种数据类型的值进栈</li>
<li><strong>lua_isinteger</strong> 判断某个栈索引的值是否是某种数据类型</li>
<li><strong>lua_tointeger</strong> 获取某个栈索引的值</li>
<li><strong>lua_gettop</strong> 获取栈顶索引，即栈元素个数</li>
<li><strong>lua_settop</strong> 设置栈顶索引，即栈元素个数，多删少补nil</li>
<li><strong>lua_pop</strong> 从栈顶删除几个元素</li>
</ul>
<p>访问 Lua 变量</p>
<ul>
<li><strong>lua_getglobal</strong> 用于获取 Lua 全局变量的值，获取之后压入栈中，即为栈顶元素的值。<blockquote>
<p><code>lua_getglobal(L, &quot;id&quot;)</code></p>
</blockquote>
</li>
<li>如果要获取 table 的某个域，则先获取 table 的引用压入栈中，再把 key 压入栈中，最后通过 <strong>lua_gettable</strong> 获取对应的域值<blockquote>
<p><code>lua_getglobal(L, &quot;tbl&quot;) lua_pushstring(L, &quot;key&quot;) lua_gettable(L, -1)</code></p>
</blockquote>
</li>
<li><strong>lua_getfield</strong> 可简化获取 table 域值的操作<blockquote>
<p><code>lua_getglobal(L, &quot;tbl&quot;) lua_getfield(L, &quot;key&quot;)</code></p>
</blockquote>
</li>
<li><strong>lua_setglobal</strong> 设置 Lua 全局变量的值，在此之前先将值压入栈中<blockquote>
<p><code>lua_pushnumber(L, 10) lua_setglobal(L, &quot;id&quot;)</code></p>
</blockquote>
</li>
<li><strong>lua_settable</strong> 用于设置 table 的某个域的值，在些之前先将 key 和要设置的值压入栈中<blockquote>
<p><code>lua_getglobal(L, &quot;tbl&quot;) lua_pushstring(L, &quot;key&quot;) lua_pushstring(L, &quot;test&quot;) lua_settable(L, -3)</code></p>
</blockquote>
</li>
<li><strong>lua_setfield</strong> 可以简化设置 table 域值的操作<blockquote>
<p><code>lua_getglobal(L, &quot;tbl&quot;) lua_pushstring(&quot;test&quot;) lua_setfield(L, -2, &quot;key&quot;)</code></p>
</blockquote>
</li>
</ul>
<p>执行 Lua 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lua_getglobal(L, <span class="string">"func"</span>);</span><br><span class="line">lua_pushinteger(L, <span class="number">5</span>);</span><br><span class="line">lua_pushinteger(L, <span class="number">2</span>);</span><br><span class="line">lua_pcall(L, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">lua_tointeger(L, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <strong>lua_getglobal</strong> 获取全局变量 func（lua 中函数也是一种数据类型，当变量处理），压入栈中；</li>
<li>使用 <strong>lua_pushxxx</strong> 将函数需要的参数依次压入栈中，第一个参数最先压入；</li>
<li>使用 <strong>lua_pcall</strong> 执行函数，执行完之后会将函数变量、参数都会栈中移除，将返回结果压入栈中；</li>
<li>使用 <strong>lua_toxxx</strong> 从栈中取出返回值，有多个返回依次获取即可，第一个返回值最先压入栈中，最后一个返回值在栈顶。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Lua 作为 C 语言实现的一个库，使得 C 程序调用 Lua 非常简单。首先，环境配置十分简单，只需要将 Lua 库包含到项目中即可，无论是源代码的形式，还是动态链接库或静态链接库的形式。然后，通过 <code>luaL_newstate</code> 创建一个 Lua 执行环境，加载标准库或其它自定义库。最后，通过 C API 执行 Lua 代码或随意的操作 Lua 环境中的全局变量和全局函数。</p>
<h1 id="Lua-调-C"><a href="#Lua-调-C" class="headerlink" title="Lua 调 C"></a>Lua 调 C</h1><h2 id="注册-C-函数"><a href="#注册-C-函数" class="headerlink" title="注册 C 函数"></a>注册 C 函数</h2><p>和 C 调用 Lua 一样，Lua 调用 C 同样通过 <strong>栈和 C API</strong> 实现，C 程序调用 Lua 函数时，需要手动将函数和参数依次压入栈中，Lua 函数执行完会自动将返回值压入栈中，C 调用者再从栈中取出返回值；类似的，Lua 调用 C 函数时，会自动将参数压入栈中，C 函数再从栈中取出参数，执行完函数体之后手动将返回值压入栈中，Lua 调用者自动从栈中取出返回值。可以看出，C 调用 Lua 时，需要调用者手动压入参数和取出返回值，而 Lua 调用 C 时，需要被调用函数手动取出参数和压入返回值。其实很好理解，因为 Lua 源码是 C 编写的，只提供 C API，所有 Lua 和 C 的交互都在 C 端处理，而 Lua 只是运行在 C 程序提供的一个 Lua 环境上而已。</p>
<p>所以，Lua 调用 C 函数不用做任何处理，像调用 Lua 函数一样简单，只是被调用的 C 函数需要遵循一定的协议：</p>
<p> i. 定义 C 函数</p>
<ol>
<li>函数原型 <code>int (*lua_CFunction)(lua_State *L);</code>；</li>
<li>函数体从 Lua 栈中取出参数；</li>
<li>函数体执行具体操作；</li>
<li>函数体将执行完的结果压入栈中；</li>
<li><p>返回结果的个数，所以函数原型的返回值必须是 <code>int</code>。</p>
<p>ii. 将 C 函数注册到 Lua 环境</p>
</li>
<li>使用 <code>lua_pushfunction</code> 将函数引用压入栈；</li>
<li><p>使用 <code>lua_setglobal</code> 将函数引用从栈中取出并赋值给一个 Lua 全局变量。</p>
<p>一个简单的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//定义 C 函数</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(lua_State *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = lua_gettop(L);</span><br><span class="line">	<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(lua_isnumber(L, i))</span><br><span class="line">		&#123;</span><br><span class="line">			sum += lua_tonumber(L, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lua_pushnumber(L, sum);</span><br><span class="line">	lua_pushnumber(L, sum / n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	lua_State *L = luaL_newstate();</span><br><span class="line">	luaL_openlibs(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注册 C 函数</span></span><br><span class="line">	lua_pushcfunction(L, sum);</span><br><span class="line">	lua_setglobal(L, <span class="string">"csum"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在 Lua 中使用 C 函数</span></span><br><span class="line">	luaL_dostring(L, <span class="string">"return csum(5, 8.5, 9.7)"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%f %f \n"</span>, lua_tonumber(L, <span class="number">-1</span>), lua_tonumber(L, <span class="number">-2</span>));</span><br><span class="line"></span><br><span class="line">	lua_close(L);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>除了函数，变量也可以注册到 Lua 环境中去，同样使用 <code>lua_setglobal</code> 设置一个 Lua 全局变量即可；事实上，函数在 Lua 中也是一种数据类型，也是通过变量来保存函数引用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id = <span class="number">999</span>;</span><br><span class="line">lua_pushinteger(L, id);</span><br><span class="line">lua_setglobal(L, <span class="string">"gid"</span>); <span class="comment">//in lua, gid = 999</span></span><br><span class="line">id = <span class="number">1000</span>; <span class="comment">//in lua, gid = 999</span></span><br><span class="line">lua_pushinteger(L, id);</span><br><span class="line">lua_setglobal(L, <span class="string">"gid"</span>); <span class="comment">//in lua, gid = 1000</span></span><br></pre></td></tr></table></figure>
<p>要注意的是，Lua 注册 C 变量的时候是以赋值方式进行的，即 C 变量的值改了，Lua 变量并不会跟着改，而是要重新注册。</p>
<h2 id="批量注册"><a href="#批量注册" class="headerlink" title="批量注册"></a>批量注册</h2><p>每个 C 函数都要手动调用 <code>lua_setglobal</code> 进行注册，太过麻烦，而且每个函数都注册为一个全局变量，管理上也不方便。C API 提供了一种批量注册的方法，将多个 C 函数组织成一个模块，然后注册这个模块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(lua_State *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(lua_State *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(lua_State *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r = lua_tointeger(L, <span class="number">1</span>) * lua_tointeger(L, <span class="number">2</span>);</span><br><span class="line">	lua_pushinteger(L, r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> luaL_Reg libs[] = &#123;</span><br><span class="line">	&#123;<span class="string">"cadd"</span>, add&#125;,</span><br><span class="line">	&#123;<span class="string">"csub"</span>, sub&#125;,</span><br><span class="line">	&#123;<span class="string">"cmul"</span>, mul&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaopen_mathlib</span><span class="params">(lua_State *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	luaL_register(L, <span class="string">"algebra"</span>, libs);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码定义了三个 C 函数，然后使用结构体 <code>struct luaL_Reg</code> 将它们组成为一个模块 <code>libs</code>，然后通过 C API <code>luaL_register</code> 注册这个模块，以全局变量 <code>algebra</code> 保存，这样在 Lua 中就可以使用 <code>algebra</code> 以及 <code>algebra.cadd</code> 等函数。</p>
<p><code>luaopen_mathlib</code> 是对外开放的一个接口，通过调用该函数就可以一键注册，类似于 <code>luaL_openlibs</code>，这个方法用于注册所有 Lua 默认库。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lua_State *L = luaL_newstate();</span><br><span class="line">luaopen_mathlib(L);</span><br><span class="line">luaL_dostring(L, <span class="string">"return algebra.cadd(5, 8)"</span>);</span><br></pre></td></tr></table></figure>
<p>这个例子中，C 函数的定义和使用是在同一个程序中的，通常这样做是没有意义的，如果是同一个 C 程序，直接由 C 函数调用 C 函数即可，又何必将 C 函数注册到 Lua 环境，再由另外的 C 函数执行 Lua 代码，在 Lua 代码中调用前面注册的 C 函数呢？实际的应用场景是将 C 函数导出为一个库，然后由其它用 Lua 写逻辑的程序调用或者直接在 Lua 解释器中加载使用。</p>
<p>Lua 中的 <code>require</code> 方法不仅能够加载其它 Lua 模块，也能直接加载由 C 程序导出的链接库，其原理就是根据链接库的名字 <code>xxx</code> 去找到函数 <code>luaopen_xxx</code>，然后执行它。所以上面的 <code>luaopen_mathlib</code> 并不是随便起的名字，其意味着如果要导出动态链接库，其名字必须为 <code>mathlib.dll</code>，如果改成其它名字比如 <code>alglib.dll</code>，Lua 代码在 require 这个库的时候就会报错 <em><code>error loading module &#39;alglib&#39; from file &#39;.\alglib.dll&#39;</code></em>。</p>
<p>另外，<code>luaopen_xxx</code> 因为是提供给外部程序调用的接口，所以要加上关键字 <code>__declspec(dllexport)</code>，所以上面的函数定义要改为 <code>__declspec(dllexport) int luaopen_mathlib(lua_State *L);</code>。</p>
<p>之后在 Lua 中直接 require 这个 mathlib.dll 即可，</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"mathlib"</span>)</span><br><span class="line"><span class="built_in">print</span>(algebra.cadd(<span class="number">5</span>,<span class="number">5</span>)) <span class="comment">-- 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> alg = <span class="built_in">require</span>(<span class="string">"mathlib"</span>)</span><br><span class="line"><span class="built_in">print</span>(alg.csub(<span class="number">1</span>,<span class="number">2</span>)) <span class="comment">-- -1</span></span><br></pre></td></tr></table></figure>
<h1 id="tolua"><a href="#tolua" class="headerlink" title="tolua++"></a>tolua++</h1><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>批量注册虽然可以提高一定的效率，但还不够，从 C++ 导出到 Lua，仍需要我们手动为每一个函数做一层封装，以便与 Lua 交互，主要的工作就是从栈中取出参数，将返回值压入栈中，最后返回返回值个数，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">niubilityFunction</span><span class="params">(<span class="keyword">int</span>, CustomType*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lua_niubilityFunction</span><span class="params">(lua_State *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arg1 = lua_tointeger(L, <span class="number">1</span>);</span><br><span class="line">    CustomType* arg2 = (CustomType*)lua_touserdata(L, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = niubilityFunction(arg1, arg2);</span><br><span class="line">    lua_pushinteger(L, ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个过程要手写几乎是不可能，所以必须借助三方工具来自动生成，这个工具就是 tolua++。tolua 可以自动导出 C/C++ 中的常量、变量、函数、类等，提供给 Lua 直接访问和调用，这个过程称之为 Lua 绑定，这是 <a href="http://webserver2.tecgraf.puc-rio.br/~celes/tolua/tolua-3.2.html#using" target="_blank" rel="noopener">tolua 官方文档</a> 及 <a href="ttps://github.com/LuaDist/tolua" target="_blank" rel="noopener">tolua 下载地址</a>。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>从 Github 下载的 tolua 是源代码，必须先编译，编译之后我们将得到两个文件 <code>tolua.exe</code> 和 <code>tolua.lib</code>。<code>tolua.exe</code> 是一个可执行工具，运行这个工具就可以从包文件(.pkg) 中生成对应的 C/C++ 文件，这个 C/C++ 文件就是导出的可供 Lua 调用的代码。<code>tolua.lib</code> 则是 tolua 源码编译后的库，要在程序中使用 tolua，则必须包括这个库文件。</p>
<p>下载源码后使用 Cmake 生成工程，然后打开工程编译即可。具体的过程就不细说了，需要注意的一点是必须先将 Lua 库和头文件所在路径添加到环境变量，保证 Cmake 可以找到 Lua 库和 Lua 头文件，否则 Cmake 生成工程会失败。</p>
<h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><ol>
<li>第一步，根据 C/C++ 代码编写对应的 Package 文件，包文件语法基本与 .h 头文件一样，但需要注意下面几点：</li>
</ol>
<ul>
<li>不能有 <code>public, private</code> 等作用域修饰符，只能导出共有的成员，默认就是 <code>public</code>；</li>
<li>函数原型和头文件保持一致，包括函数名参数和返回值；</li>
<li>虚函数不能导出；</li>
<li>类构造函数和析构函数也得导出；</li>
<li>在文件头使用 <code>$#include &quot;test.h&quot;</code> 包含头文件。</li>
</ul>
<ol start="2">
<li>第二步，打开控制台，输入命令 `tolua -n xxx -o xxx.hpp xxx.pkg”；</li>
</ol>
<ul>
<li><code>-n</code> 指定模块名，tolua 会为每一个要导出的函数封装一个上层静态函数，然后提供一个模块注册接口，由这个接口负责将所有静态函数注册 Lua 环境，这个过程和上面讲的批量注册是一样的，<code>-n</code> 指定的就是这个模块名，如果不指定，则默认使用包文件名；</li>
<li><code>-o</code> 生成的文件名，这是源文件，一般为 <code>*.c, *.cpp</code>，不会生成对应的头文件，所以使用的时候需要手动写一个 <code>.h</code> 头文件，为了方便可直接将导出文件指定为 <code>*.hpp</code>；</li>
<li><code>*.pkg</code> 就是第一步写的包文件了。</li>
</ul>
<p>下面是示例，使用 C++ 编写一个简单类 <code>MyClass</code>，然后将其导出到 Lua。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyClass.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line">	~MyClass();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MyClass.pkg</span></span><br><span class="line">$<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyClass.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    MyClass(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line">	~MyClass();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将 <code>MyClass.h, MyClass.cpp, MyClass.pkg</code> 放在一个目录下，然后打开控制台，输入命令 <code>tolua -n tlib -o LuaMyClass.hpp MyClass.pkg</code> 即可在同目录下生成一个 <code>LuaMyClass.hpp</code> 文件。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li>新建一个 C++ 工程；</li>
<li>添加 Lua 头文件和库文件依赖；</li>
<li>附加包含目录 <code>tolua.h</code>；</li>
<li>把上面生成的 <code>tolua.lib</code> 添加到附加依赖库或者直接将 tolua 源码 <code>lib</code> 目录下的文件直接拷到工程；</li>
<li>将 <code>MyClass.h, MyClass.cpp, LuaMyClass.hpp</code> 拷贝到工程目录下；</li>
<li>编写代码。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LuaMyClass.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lualib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lauxlib.h"</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lua_State* state = luaL_newstate();</span><br><span class="line"></span><br><span class="line">    luaL_openlibs(state);</span><br><span class="line">    tolua_tlib_open(state);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (luaL_dofile(state, <span class="string">"test.lua"</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"execute lua file failed!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        lua_close(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lua_close(state);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lua 代码 <code>test.lua</code>：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> myClass = MyClass:new(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">local</span> result = myClass:<span class="built_in">execute</span>()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<p>如果在控制台看到打印结果 <code>3</code>，则表示 Lua 文件成功执行了，也就是说自定义类 <code>MyClass</code> 绑定到 Lua 成功了。</p>
<p><code>tolua_tlib_open</code> 用于注册刚导出的库，从而将导出的所有函数注册到 Lua 环境，这样执行 Lua 代码的时候就会回调到导出的函数，再由导出函数去调用源函数。因为我们上面导出的时候指定了 <code>-n tlib</code>，所以生成的注册函数是 <code>tolua_tlib_open</code>，如果不指定，则默认会生成的是 <code>tolua_MyClass_open</code>。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>接下来看一下生成文件 <code>LuaMyClass.hpp</code> 的内容，分析下 tolua 的工作原理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TOLUA_API <span class="keyword">int</span> <span class="title">tolua_tlib_open</span><span class="params">(lua_State *tolua_S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lua_pushcfunction(tolua_S, luaopen_tlib);</span><br><span class="line">    lua_pushstring(tolua_S, <span class="string">"tlib"</span>);</span><br><span class="line">    lua_call(tolua_S, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LUALIB_API <span class="keyword">int</span> <span class="title">luaopen_tlib</span><span class="params">(lua_State *tolua_S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tolua_open(tolua_S);</span><br><span class="line">    tolua_reg_types(tolua_S);</span><br><span class="line">    tolua_module(tolua_S, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    tolua_beginmodule(tolua_S, <span class="literal">NULL</span>);</span><br><span class="line">    tolua_cclass(tolua_S, <span class="string">"MyClass"</span>, <span class="string">"MyClass"</span>, <span class="string">""</span>, tolua_collect_MyClass);</span><br><span class="line">    tolua_beginmodule(tolua_S, <span class="string">"MyClass"</span>);</span><br><span class="line">    tolua_function(tolua_S, <span class="string">"new"</span>, tolua_tlib_MyClass_new00);</span><br><span class="line">    tolua_function(tolua_S, <span class="string">"delete"</span>, tolua_tlib_MyClass_delete00);</span><br><span class="line">    tolua_function(tolua_S, <span class="string">"execute"</span>, tolua_tlib_MyClass_execute00);</span><br><span class="line">    tolua_endmodule(tolua_S);</span><br><span class="line">    tolua_endmodule(tolua_S);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tolua_reg_types</span><span class="params">(lua_State *tolua_S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tolua_usertype(tolua_S, <span class="string">"MyClass"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tolua_collect_MyClass</span><span class="params">(lua_State *tolua_S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass *self = (MyClass *)tolua_tousertype(tolua_S, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    tolua_release(tolua_S, self);</span><br><span class="line">    <span class="keyword">delete</span> self;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tolua_tlib_MyClass_new00</span><span class="params">(lua_State *tolua_S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = ((<span class="keyword">int</span>)tolua_tonumber(tolua_S, <span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> b = ((<span class="keyword">int</span>)tolua_tonumber(tolua_S, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    &#123;</span><br><span class="line">        MyClass *tolua_ret = (MyClass *)<span class="keyword">new</span> MyClass(a, b);</span><br><span class="line">        tolua_pushusertype(tolua_S, (<span class="keyword">void</span> *)tolua_ret, <span class="string">"MyClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tolua_tlib_MyClass_delete00</span><span class="params">(lua_State *tolua_S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass *self = (MyClass *)tolua_tousertype(tolua_S, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    tolua_release(tolua_S, self);</span><br><span class="line">    <span class="keyword">delete</span> self;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tolua_tlib_MyClass_execute00</span><span class="params">(lua_State *tolua_S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass *self = (MyClass *)tolua_tousertype(tolua_S, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> tolua_ret = (<span class="keyword">int</span>)self-&gt;execute();</span><br><span class="line">    tolua_pushnumber(tolua_S, (lua_Number)tolua_ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只贴出了简化后的核心代码，总共 7 个函数，包括 4 个通用函数和 3 个自定义函数。</p>
<p>3 个自定义函数就是类 <code>MyClass</code> 的三个成员函数，构造函数 <code>new</code>，析构函数 <code>delete</code> 及普通函数 <code>execute</code>；</p>
<ul>
<li><code>tolua_tlib_MyClass_new00</code> 先从栈中取出两个参数，再执行 <code>new MyClass(a, b)</code> 创建一个对象，然后把对象压入栈中，返回 1 表示栈中放了一个返回值；</li>
<li><code>tolua_tlib_MyClass_delete00</code> 先从栈中取出对象，然后执行 <code>tolua_release(self)</code> 在 Lua 层释放对象，再执行 <code>delete self</code> 在 C++ 层释放对象；</li>
<li><code>tolua_tlib_MyClass_execute00</code> 先从栈中取出对象，再调用 <code>self-&gt;execute()</code> 执行具体的方法，再将执行结果压入栈中，返回 1 表示栈中放了一个返回值。</li>
</ul>
<p><code>tolua_collect_MyClass</code> 做的事情和 <code>tolua_tlib_MyClass_delete00</code> 是一样的，仔细看会发现它们的核心代码是完全一样的，都是回收对象。</p>
<p><code>tolua_tlib_open</code>, <code>luaopen_tlib</code> 都是对外提供的一键注册模块接口，这两个接口做的事情也是一样的，其实 <code>tolua_tlib_open</code> 做的事情就是调用接口 <code>luaopen_tlib</code>，所以真正将模块注册到 Lua 环境的是 <code>luaopen_tlib</code> 接口，这个接口又通过 <code>tolua_reg_types</code> 将模块注册为一个新的用户类型。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linjinxin.com/2019/12/03/cocos2dx/tolua2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林锦新">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome to Code World">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/03/cocos2dx/tolua2/" itemprop="url">【Cocos2d-x】使用 tolua++ 导出 C++ 类（3.x版本）</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-03T22:12:41+08:00">
                2019-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cocos2d-x/" itemprop="url" rel="index">
                    <span itemprop="name">Cocos2d-x</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/03/cocos2dx/tolua2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/12/03/cocos2dx/tolua2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><em>版本之痛，痛中之痛；环境之难，难中之难。</em></p>
</blockquote>
<p>cocos2d-x3.x 与 2.x 很不一样，关于 Lua 绑定也不同。在 2.x 版本，引擎目录下有个 <code>tolua++.exe</code> 文件，通过包描述文件 <code>*.tolua</code>，执行脚本 <code>build.bat</code> 来一键导出。而在 3.x 版本，描述文件换成了 <code>*.ini</code>，然后编写 python 脚本 <code>generator.py</code>，使用 python 来导出。</p>
<h1 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h1><p>首先来看一下 cocos2d-x3.x 的源码目录结构，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">|-cocos2d-x-3.x</span><br><span class="line">    |-build</span><br><span class="line">    |-docs</span><br><span class="line">    |-tests</span><br><span class="line">    |-templates</span><br><span class="line">    |-extensions</span><br><span class="line">    |-external</span><br><span class="line">    |-tools</span><br><span class="line">        |-tolua</span><br><span class="line">            |-genbindings.py</span><br><span class="line">            |-cocos2dx.ini</span><br><span class="line">            |-cocos2dx_ui.ini</span><br><span class="line">            |-...</span><br><span class="line">            |-README.mdown</span><br><span class="line">        |-bindings-generator</span><br><span class="line">            |-libclang</span><br><span class="line">                |-libclang.dll</span><br><span class="line">                |-libclang.so</span><br><span class="line">                |-libclang.dylib</span><br><span class="line">            |-clang</span><br><span class="line">                |-cindex.py</span><br><span class="line">            |-generator.py</span><br><span class="line">    |-cocos</span><br><span class="line">        |-2d</span><br><span class="line">        |-...</span><br><span class="line">        |scripting</span><br><span class="line">            |-js-bindings</span><br><span class="line">            |-lua-bindings</span><br><span class="line">                |-auto</span><br><span class="line">                    |-api</span><br><span class="line">                        |-Action.lua</span><br><span class="line">                        |-...</span><br><span class="line">                    |-lua_cocos2dx_auto.hpp</span><br><span class="line">                    |-lua_cocos2dx_auto.cpp</span><br><span class="line">                    |-lua_cocos2dx_ui_auto.hpp</span><br><span class="line">                    |-lua_cocos2dx_ui_auto.cpp</span><br><span class="line">                    |-...</span><br><span class="line">                |-scripting</span><br><span class="line">                    |-init.lua</span><br><span class="line">                    |-...</span><br></pre></td></tr></table></figure>
<p><code>build</code> 为工程目录，<code>docs</code> 帮助文档，<code>tests</code> 官方示例，<code>templates</code> 为创建项目时使用的模板，<code>extensions</code> 为源码的一些扩展，<code>external</code> 为外部库，主要是一些第三方的基础库，比如物理引擎、md5、json 等等。重点要介绍的是 <code>tools</code> 和 <code>cocos</code> 这两个文件夹。</p>
<ul>
<li><code>cocos</code> 目录是 cocos2d-x 引擎的 C++ 源码，其中 <code>cocos/scripting</code> 为导出的脚本，包括 js 和 lua，分别放在 <code>cocos/scripting/lua-bindings</code> 和 <code>cocos/scripting/js-bindings</code> 目录下；<code>cocos/scripting/lua-bindings/auto</code> 为 tolua 生成文件存放的地方。</li>
<li><code>tools</code> 目录下是 cocos2d-x 非常实用的一些工具，包括创建项目、编译项目、运行项目的控制台命令等，这里我们要看的是 <code>tolua</code> 和 <code>bindings-generator</code> 这两个文件夹；<code>tolua</code> 下是包描述文件和可执行脚本 <code>genbindings.py</code>，<code>binding-generator</code> 目录下则是需要用到的一些库或脚本。</li>
</ul>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>在开始之前需要做一个准备工作，就是配置环境，主要配置的是 python 环境，在 <code>tools/tolua/README.mdown</code> 中其实已经有关于环境配置的说明：</p>
<ul>
<li>首先，安装 ndk 并配置环境变量 <strong>NDK_ROOT</strong>；</li>
<li>然后，下载安装 python2.7，注意必须安装 32 位版本，下载地址：<a href="http://www.python.org/ftp/python/2.7.3/python-2.7.3.msi" target="_blank" rel="noopener">python2.7.3</a>；</li>
<li>配置 python 环境变量 <strong>PYTHON_BIN</strong>；</li>
<li>下载安装 python 库 pyyaml，下载地址：<a href="http://pyyaml.org/download/pyyaml/PyYAML-3.11.win32-py2.7.exe" target="_blank" rel="noopener">pyyaml</a>，pyyaml 安装的时候会读取 python 安装路径并将结果安装在 <strong>%PYTHON_BIN%\Lib\site-packages</strong> 目录下；</li>
<li>下载 python 库 pyCheetah，下载地址：<a href="https://raw.github.com/dumganhar/my_old_cocos2d-x_backup/download/downloads/Cheetah.zip" target="_blank" rel="noopener">pyCheetah</a>，下载之后解压到  <strong>%PYTHON_BIN%\Lib\site-packages</strong> 目录下即可。</li>
</ul>
<h1 id="Lua-绑定"><a href="#Lua-绑定" class="headerlink" title="Lua 绑定"></a>Lua 绑定</h1><p>首先，跟写普通 C++ 程序一样，我们先写一个要导出的 C++ 类 <code>MyClass</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyClass.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MyClass(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line">	~MyClass();</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">excute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MyClass.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyClass.h"</span></span></span><br><span class="line"></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">    <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass::~MyClass()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MyClass::excute()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就可以准备导出这个类了，使用的是 <code>tools/tolua/genbindings.py</code> 以及每个类对应的 <code>ini</code> 文件，这个 python 脚本可以导出 cocos2d-x 中的所有类，我们可以修改这个脚本，添加我们自定义的类，也可以模仿这个脚本另外写一个脚本，然后执行我们自己写的这个脚本。为了防止破坏源代码，我们使用第二种，把 <code>genbindings.py</code> 复制一份，命名为 <code>genbindings_myclass.py</code>，再把 <code>cocos2dx.ini</code> 复制一份，命名为 <code>myclass.ini</code>。在引擎源码下创建一个 <code>custom</code> 目录，然后把 <code>myclass.ini</code> 和 C++ 源文件统一放在这个目录下，而 <code>genbindings_myclass.py</code> 则仍放在 <code>tools/tolua</code> 目录下，这样改动最小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|-cocos2d-x-3.x</span><br><span class="line">    |-cocos</span><br><span class="line">        |-custom</span><br><span class="line">            |-MyClass.h</span><br><span class="line">            |-MyClass.cpp</span><br><span class="line">            |-myclass.ini</span><br><span class="line">            |-auto</span><br><span class="line">    |-tools</span><br><span class="line">        |-tolua</span><br><span class="line">            |-genbindings_myclass.py</span><br></pre></td></tr></table></figure>
<p>修改 <code>genbindings_myclass.py</code>：</p>
<ul>
<li><code>tolua_root</code> 为包描述文件 <code>myclass.ini</code> 的路径，即 <code>project_root/cocos/custom</code>；</li>
<li><code>output_dir</code> 为生成文件的路径，我们放在 <code>project_root/cocos/custom/auto</code> 目录下；</li>
<li><code>cmd_args</code> 指定我们要导出的 C++ 类，key 是一个 ini 配置文件，value 指定源文件名和导出文件名；这是一个 table，可以指定多个 ini 配置文件，一个配置文件可以配置一个类或多个类；这里我们只需要一个 <code>myclass.ini</code>，源文件名为 <code>myclass</code>，这个源文件名在 <code>myclass.ini</code> 的第一行定义，不是真正的源码的文件名，导出的文件名为 <code>lua_myclass_auto</code>。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># genbindings_myclass.py</span></span><br><span class="line">tolua_root = <span class="string">'%s/tools/tolua'</span> % project_root</span><br><span class="line">output_dir = <span class="string">'%s/tests/custom/auto'</span> % project_root </span><br><span class="line">cmd_args = &#123;<span class="string">'myclass.ini'</span> : (<span class="string">'myclass'</span>, <span class="string">'lua_myclass_auto'</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>修改 <code>myclass.ini</code>：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源文件名，与上面 cmd_args 配置的一致</span></span><br><span class="line"><span class="section">[myclass]</span></span><br><span class="line"><span class="attr">prefix</span> = myclass</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 导出的类所在命名空间，在 lua 层使用时需要用到，不写也行，表示在全局空间</span></span><br><span class="line"><span class="attr">target_namespace</span> = cc</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 要导出的 c++ 类头文件路径</span></span><br><span class="line"><span class="attr">headers</span> = %(cocosdir)s/tests/custom/MyClass.h</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 要导出的类名</span></span><br><span class="line"><span class="attr">classes</span> = MyClass</span><br><span class="line"></span><br><span class="line"><span class="attr">skip</span> =</span><br><span class="line"><span class="attr">abstract_classes</span> =</span><br></pre></td></tr></table></figure>
<p>总结一下就是创建了 <code>genbindings_myclass.py</code> 和 <code>myclass.ini</code> 这两个文件，接下来在 <code>tools/tolua</code> 文件夹下打开命令行，输入 <code>python genbindings_myclass.py</code>。 如果没错误，将在 <code>tests/custom/auto</code> 目录生成相应的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">|-cocos2d-x-3.x</span><br><span class="line">    |-cocos</span><br><span class="line">        |-custom</span><br><span class="line">            |-MyClass.h</span><br><span class="line">            |-MyClass.cpp</span><br><span class="line">            |-myclass.ini</span><br><span class="line">            |-auto</span><br><span class="line">                |-lua_myclass_auto.hpp</span><br><span class="line">                |-lua_myclass_auto.cpp</span><br><span class="line">                |-api</span><br><span class="line">                    |-MyClass.lua</span><br><span class="line">                    |-lua_myclass_auto.lua</span><br></pre></td></tr></table></figure>
<p>如果报错，检查一下 <code>genbindings_myclass.py</code> 和 <code>myclass.ini</code> 有没有写错，特别是源文件路径 <em>headers</em> 和 目标文件 <em>output_dir</em>。还有就是 python，pyyaml 和 pyCheetah 是不是全装的 32 位，还有 python 环境变量是否配置对，当然 <code>MyClass.h</code> 和 <code>MyClass.cpp</code> 肯定也不能有错误。</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>新建一个 lua 项目，把 <code>MyClass.h, MyClass.cpp, lua_myclass_auto.hpp, lua_myclass_auto.cpp</code> 这四个文件拷到项目中，然后打开 <code>AppDelegate.cpp</code>，添加下面内容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lua_myclass_auto.hpp"</span></span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> AppDelegate::applicationDidFinishLaunching()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    lua_State* L = engine-&gt;getLuaStack()-&gt;getLuaState();</span><br><span class="line">    lua_module_register(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//register custom function</span></span><br><span class="line">    register_all_myclass(<span class="built_in">stack</span>-&gt;getLuaState());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>register_all_myclass</code> 在 <code>lua_myclass_auto.hpp</code> 中声明，所以要引入这个头文件，在 <code>lua_myclass_auto.cpp</code> 中实现，我们可以看看这个函数，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TOLUA_API <span class="keyword">int</span> <span class="title">register_all_myclass</span><span class="params">(lua_State* tolua_S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tolua_open(tolua_S);</span><br><span class="line">	</span><br><span class="line">	tolua_module(tolua_S,<span class="string">"cc"</span>,<span class="number">0</span>);</span><br><span class="line">	tolua_beginmodule(tolua_S,<span class="string">"cc"</span>);</span><br><span class="line"></span><br><span class="line">	lua_register_myclass_MyClass(tolua_S);</span><br><span class="line"></span><br><span class="line">	tolua_endmodule(tolua_S);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说就是打开 tolua，把 c++ 层的函数注册到 lua 环境中，之后就可以在 lua 中直接使用这些函数了。具体的可以看我这篇文章<a href="http://blog.csdn.net/xingxinmanong/article/details/78137514" target="_blank" rel="noopener">tolua 用法</a>。</p>
<p>接下来打开 src/app/views/MainScene.lua，开始测试我们的例子，</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> MainScene = class(<span class="string">"MainScene"</span>, cc.<span class="built_in">load</span>(<span class="string">"mvc"</span>).ViewBase)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MainScene:onCreate</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> test = cc.MyClass:new(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">	<span class="keyword">local</span> num = test:excute()</span><br><span class="line">	<span class="keyword">local</span> str = <span class="string">"Hello World"</span> .. num</span><br><span class="line">	cc.Label:createWithSystemFont(str, <span class="string">"Arial"</span>, <span class="number">40</span>)</span><br><span class="line">	:move(display.cx, display.cy)</span><br><span class="line">	:addTo(self)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> MainScene</span><br></pre></td></tr></table></figure>
<p>这里我们创建 MyClass 的一个实例，然后调用其 excute 方法；注意我们前面导出的时候定义其命名空间为 cc，所以这里要写 cc.MyClass，否则会报错。接下来就是见证成果的时候了，编译运行项目，看到下面结果就表示大功告成了。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwOTI5MjExNDEzMjQ2?x-oss-process=image/format,png" alt="tolua 应用"></p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p><strong>1. NDK 版本不对</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">====</span><br><span class="line">Errors <span class="keyword">in</span> parsing headers:</span><br><span class="line">1. &lt;severity = Fatal,</span><br><span class="line">    location = &lt;SourceLocation file <span class="string">'/home/xxx/NDK/platforms/android-14/arch-arm/usr/include/android/log.h'</span>, line 70, column 10&gt;,</span><br><span class="line">    details = <span class="string">"'stdarg.h' file not found"</span>&gt;</span><br><span class="line">====</span><br></pre></td></tr></table></figure>
<p>如果出现这个错误，是因为 NDK 工具链 <code>llvm</code> 匹配不上，最简单直接的办法就是换一个版本的 NDK，通常是使用了版本太高的 NDK 才会出现，比如我之前电脑上装了 r10 和 r20 两个版本，不知道什么时候环境变量设成了 <code>NDK_ROOT = D:\Android\android-ndk-r20</code>，把它换成 <code>NDK_ROOT = D:\Android\android-ndk-r10e</code> 就行了。注意要删掉 <code>tools/tolua/userconfi.ini</code>，然后重启终端再执行就可以了。</p>
<p>to be continue…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linjinxin.com/2019/12/03/cocos2dx/tolua1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林锦新">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome to Code World">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/03/cocos2dx/tolua1/" itemprop="url">【Cocos2d-x】使用 tolua++ 导出 C++ 类（2.x版本）</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-03T20:28:40+08:00">
                2019-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cocos2d-x/" itemprop="url" rel="index">
                    <span itemprop="name">Cocos2d-x</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/03/cocos2dx/tolua1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/12/03/cocos2dx/tolua1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><em>每天进步一点点，能不退步太多；再进步一点，能不退步；再进步一点点，能有所进步；再进步一点点，方能成功。</em></p>
</blockquote>
<p>Cocos2dx 版本非常乱，主要有 2.x 和 3.x 两个版本，另外还是 lua 版本还有 quick 分支。本文主要介绍低版本(2.x)cocos2d-x 对应的 quick 版本，如何使用 tolua++ 来导出自定义的 C++ 类，因为没找到 cocos2d-x 的 2.x 版本，所以不知道 2dx 和 quick 是不是一样。</p>
<h1 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h1><p>先来看一下 quick-cocos2d-x-2.x 的工程结构，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">|-quick-cocos2d-x</span><br><span class="line">    |-bin</span><br><span class="line">        |-win32</span><br><span class="line">            |-lua51.dll</span><br><span class="line">            |-luac.exe</span><br><span class="line">            |-luajit.exe</span><br><span class="line">            |-php.exe</span><br><span class="line">            |-tolua++.exe</span><br><span class="line">    |-framework</span><br><span class="line">        |-display.lua</span><br><span class="line">    |-lib</span><br><span class="line">        |-cocos2d-x</span><br><span class="line">            |-scripting</span><br><span class="line">                |-lua</span><br><span class="line">                    |-cocosdx_support</span><br><span class="line">                        |-LuaCocos2d.h</span><br><span class="line">                        |-LuaCocos2d.cpp</span><br><span class="line">        |-framework_precompiled</span><br><span class="line">        |-luabinding</span><br><span class="line">            |-cocos2dx</span><br><span class="line">                |-Cocos2d.tolua</span><br><span class="line">            |-Cocos2d.tolua</span><br><span class="line">            |-build.bat</span><br><span class="line">            |-build.sh</span><br><span class="line">        |-proj.win32</span><br><span class="line">        |-proj.android</span><br><span class="line">    |-player</span><br><span class="line">        |-sources</span><br><span class="line">        |-proj.win32</span><br><span class="line">        |-proj.mac</span><br></pre></td></tr></table></figure>
<p>最重要的就是上面列出的 <code>bin, framework, lib, player</code> 四个文件夹，另外还有几个不那么重要的文件夹，<code>docs</code> 是帮助文档，<code>samples</code> 是官方例子，<code>template</code> 是创建工程的默认模板，<code>tool</code> 貌似没什么用。</p>
<ul>
<li><code>bin</code> 保存了引擎用到的一些工具和可执行脚本，其中 <code>bin/win32</code> 下有跟 Lua 相关的工具，包括 Lua 编译器 <code>luac</code> 和 <code>luajit</code>，还有我们马上要用到的 <code>tolua++</code>；</li>
<li><code>framework</code> 为引擎的基础框架，即封装好的一些代码库集合，里面全是 Lua 文件，因为 quick 是纯 Lua 版本，引擎源码已经被编成一个“播放器”了，对项目而言，这些上层封装的 Lua 代码才是 framework；</li>
<li><code>lib</code> 是引擎源码存放的地方，包括 <code>cocos2d-x</code> 目录下的源码和 <code>proj.win32, proj.android</code> 等源码工程，以及用于将 C++ 导出到 Lua 的相关文件 <code>luabinding</code>；</li>
<li><code>player</code> 则是一个播放器工程，用于生成一个可直接运行的播放器，之后使用 quick 创建项目就只需要把这个编好的播放器拷过去就行，然后直接开撸 Lua 代码，不需要引擎的 C++ 源码；在 <code>player/proj.win32</code> 下有个解决方案 <code>player.sln</code>，它包含自身的播放器项目 <code>player.vcxproj</code> 和源码项目 <code>lib/proj.win32/cocos2dx.vcxproj</code>。</li>
</ul>
<h1 id="Lua-绑定"><a href="#Lua-绑定" class="headerlink" title="Lua 绑定"></a>Lua 绑定</h1><p>引擎的目录结构已经很清楚了，<code>lib</code> 是引擎源码，<code>framework</code> 是 quick 封装的上层 Lua 库，<code>player</code> 是播放器工程，<code>bin</code> 则是常用工具。进行 Lua 绑定需要用到 <code>bin</code> 和 <code>lib</code> 这两个文件夹，</p>
<ul>
<li><code>bin</code> 目录下有 Lua 绑定工具 <code>tolua++.exe</code>；</li>
<li><code>lib/luabinding</code> 为 Lua 绑定的工作目录，包括每个类的包描述文件 <code>*.tolua</code>、定制脚本 <code>basic.lua</code> 和可执行脚本 <code>build.bat/build.sh</code>；</li>
<li><code>lib/framework_precompiled</code> 目录下 Lua framework 的预编译文件，下面只有 <code>framework_precompiled.zip</code> 一个文件；</li>
<li><code>lib/cocos2d-x</code> 则为引擎的源码目录，tolua 导出的文件自然也是源码的一部分，所以也在这个目录下，其完整路径为 <code>lib/cocos2d-x/scripting/lua/cocos2dx_support</code>。</li>
</ul>
<p><strong>进行 Lua 绑定只需要一步，执行 <code>lib/luabinding/build.bat/build.sh</code> 即可</strong>，这个脚本的内容如下，</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">DIR</span>=%~dp0</span><br><span class="line"><span class="built_in">set</span> TOLUA=<span class="variable">%QUICK_COCOS2DX_ROOT%</span>\bin\win32\tolua++.exe</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /d "<span class="variable">%DIR%</span>"</span><br><span class="line"><span class="variable">%TOLUA%</span> -L "<span class="variable">%DIR%</span>basic.lua" -o "<span class="variable">%QUICK_COCOS2DX_ROOT%</span>\lib\cocos2d-x\scripting\lua\cocos2dx_support\LuaCocos2d.cpp" Cocos2d.tolua</span><br></pre></td></tr></table></figure>
<p>其实就只做一件事，调用 <code>bin/win32/tolua++.exe</code>，根据包描述文件 <code>lib/luabinding/Cocos2d.tolua</code> 和定制脚本 <code>lib/luabinding/basic.lua</code>，生成文件 <code>lib/cocos2d-x/scripting/lua/cocos2dx_support/LuaCocos2d.cpp</code>。</p>
<p>描述文件以 <code>.tolua</code> 为后缀(本来的后缀名应该是 <code>*.pkg</code>，不过这不重要)，语法和 C++ 头文件差不多，其作用是描述要导出的函数，每个 C++ 类都需要一个描述文件，但我们执行脚本的时候只指定了一个描述文件，这是因为描述文件和头文件一样，可以包含其它文件，下面是 <code>Cocos2d.tolua</code> 的内容，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$#include &quot;LuaCocos2d.h&quot;</span><br><span class="line">$pfile &quot;cocos2dx/include/ccTypes.tolua&quot;</span><br><span class="line">$pfile &quot;cocos2dx/cocoa/CCObject.tolua&quot;</span><br><span class="line">$pfile &quot;cocos2dx/cocoa/CCString.tolua&quot;</span><br><span class="line">//...</span><br></pre></td></tr></table></figure>
<p>在运行标准的 tolua++ 之前，还加载了额外的脚本 <code>basic.lua</code>，这是由于 cocos2dx 在 Lua 绑定方面并未完全遵照 tolua++ 的默认做法，因此需要对其进行定制，<code>basic.lua</code> 主要做的事情是：</p>
<ol>
<li>将所有导出的 CCXXXX 类的 <code>push</code> 函数（也就是将 cpp obj h传进 lua 时调用的函数）修改为自己的 <code>toluafix_pushusertype_ccobject</code>；</li>
<li>将 <code>function</code> 和 <code>table</code> 两种类型的 <code>to</code> 和 <code>is</code> 函数（分别是指将 lua obj 传进 cpp 时调的函数、判断一个变量是否为本类型时调的函数）修改为 <code>toluafix_is/to_funtion/table</code>。</li>
</ol>
<h1 id="自定义类导出"><a href="#自定义类导出" class="headerlink" title="自定义类导出"></a>自定义类导出</h1><ul>
<li>第一步，编写自己的 C++ 类 <code>MyClass</code>，放在源码目录 <code>lib/cocos2d-x</code> 下即可，无具体要求；</li>
<li>第二步，编写包描述文件 <code>MyClass.tolua</code>，放在 Lua 绑定工作目录 <code>lib/luabinding</code> 下即可，无具体要求；</li>
<li>第三步，在 <code>Cocos2d.tolua</code> 中包含 <code>MyClass.tolua</code>；</li>
<li>第四步，在 <code>cocos2d.h</code> 中包含 <code>MyClass.h</code>；</li>
<li>第五步，重新执行 <code>lib/luabinding/build.bat</code>，这样就会将自定义类 <code>MyClass</code> 也导出到 <code>LuaCocos2d</code> 库中去，所以使用的时候不需要自己去导入库。</li>
</ul>
<p>在 <code>basic.lua</code> 中定义了一个 table <code>CCObjectTypes</code>，放在这个 table 里的类表示是 cocos2d-x 对象类，需要对其进行定制；如果我们的自定义继承自 cocos2d-x 的对象，则需要把我们的自定义类也加入到 <code>CCObjectTypes</code> 中去，否则不能加进去，cocos2d-x 的对象类会修改 <code>toluafix_pushusertype_ccobject</code>，会使用到 <code>m_uID</code> 和 <code>m_nLuaID</code>，而我们自定义的类没有这两个字段，将其当作 cocos2d-x 对象处理是编译不过去的。</p>
<p>第二步和第三步是编写包描述文件，仿照着已有文件写就行，这两步做好之后通常就可以进行导出了，通常容易忽略的是第四步。这里要讲一下 Lua 绑定的原理，就是在原来 C++ 类的基础上封装一层，为每个需要导出的方法都封装一个静态函数，然后 C++ 程序打开 Lua 环境的时候将这些静态函数全部注册到 Lua 环境中去，生成一个全局的 Lua 变量，Lua 代码通过这个全局变量访问到 C++ 静态函数，而这个静态函数内部才调用真正的类方法。所以，<strong>Lua 绑定的结果是根据原来的 C++ 文件，再生成一个 C++ 文件</strong>，新生成的文件需要包含原来的头文件，因为新文件定义的静态方法做的事情就是访问原来的类方法。因此才有了第四步，引用头文件 <code>MyClass.h</code>，因为生成的文件 <code>LuaCocos2d.cpp</code> 默认会包含 <code>cocos2d.h</code>，所以这里才在 <code>cocos2d.h</code> 中包含 <code>MyClass.h</code>，当然也可以在其它地方包含，比如直接在 <code>LuaCocos2d.cpp</code> 中直接包含 <code>MyClass.h</code> 也行，或者在定制脚本 <code>basic.lua</code> 中写也行。</p>
<p>下面是一个导出方法的示例，是为 <code>MyClass</code> 的构造函数生成的一个静态函数，这个函数使用 C API 创建一个 <code>MyClass</code> 对象，注册到 Lua 环境中去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TOLUA_DISABLE_tolua_Cocos2d_MyClass_new00</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tolua_Cocos2d_MyClass_new00</span><span class="params">(lua_State* tolua_S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">int</span> a = ((<span class="keyword">int</span>)  tolua_tonumber(tolua_S,<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> b = ((<span class="keyword">int</span>)  tolua_tonumber(tolua_S,<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">    &#123;</span><br><span class="line">    MyClass* tolua_ret = (MyClass*)  Mtolua_new((MyClass)(a,b));</span><br><span class="line">    tolua_pushusertype(tolua_S,(<span class="keyword">void</span>*)tolua_ret,<span class="string">"MyClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//#ifndef TOLUA_DISABLE</span></span></span><br></pre></td></tr></table></figure>
<h1 id="单独导出"><a href="#单独导出" class="headerlink" title="单独导出"></a>单独导出</h1><p>上面的做法是将自定义跟着系统库一起导出，另外一种做法是单独导出我们的自定义类，只需要模仿着系统导出写一套文件即可。最终的文件结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|-quick-cocos2d-x</span><br><span class="line">    |-lib</span><br><span class="line">        |-custom</span><br><span class="line">            |-luabinding</span><br><span class="line">                |-basic.lua</span><br><span class="line">                |-build.bat</span><br><span class="line">                |-MyClass.tolua</span><br><span class="line">            |-MyClass.h</span><br><span class="line">            |-MyClass.cpp</span><br><span class="line">            |-LuaMyClass.hpp</span><br></pre></td></tr></table></figure>
<p>创建一个独立的目录 <code>lib/custom</code>，不干扰引擎原来的文件结构，然后第一步和第二步和原来一样，编写自定义的 C++ 类和包描述文件 <code>MyClass.tolua</code>；之后编写自己的定制脚本 <code>basic.lua</code> 和可执行脚本 <code>build.bat</code>，最终生成文件 <code>LuaMyClass.hpp</code>，默认不会生成头文件，所以这里将生成的文件命名为 <code>*.hpp</code>，这样使用的时候就直接包含就行了，如果生成 <code>*.cpp</code>，则需要自己再手动写一个头文件。</p>
<p><code>build.bat</code> 基本和原来一样，只是改一下包描述文件和生成文件，代码如下：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">DIR</span>=%~dp0</span><br><span class="line"><span class="built_in">set</span> TOLUA=<span class="variable">%QUICK_COCOS2DX_ROOT%</span>\bin\win32\tolua++.exe</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /d "<span class="variable">%DIR%</span>"</span><br><span class="line"><span class="variable">%TOLUA%</span> -L "<span class="variable">%DIR%</span>basic.lua" -o "<span class="variable">%DIR%</span>/../LuaMyClass.cpp" MyClass.tolua</span><br></pre></td></tr></table></figure>
<p>定制脚本 <code>basic.lua</code> 也和原来差不多，直接从 <code>lib/luabinding/basic.lua</code> 拷一份出来，然后做一下删减即可。首先，我们的自定义不是 cocos2d-x 对象，所以 <code>CCObjectTypes</code> 部分直接删掉；然后改一下 <code>replace</code> 部分的代码，简化头文件的引入，不需要引入 <code>cocos2d.h</code>，还有一些不必要的替换也去掉，最终的效果如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- usage: (use instead of ant)</span></span><br><span class="line"><span class="comment">-- tolua++ "-L" "basic.lua" "-o" "../../scripting/lua/cocos2dx_support/LuaCocos2d.cpp" "Cocos2d.pkg"</span></span><br><span class="line"></span><br><span class="line">_is_functions = _is_functions <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">_to_functions = _to_functions <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">_push_functions = _push_functions <span class="keyword">or</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- register LUA_FUNCTION, LUA_TABLE, LUA_HANDLE type</span></span><br><span class="line">_to_functions[<span class="string">"LUA_FUNCTION"</span>] = <span class="string">"toluafix_ref_function"</span></span><br><span class="line">_is_functions[<span class="string">"LUA_FUNCTION"</span>] = <span class="string">"toluafix_isfunction"</span></span><br><span class="line">_to_functions[<span class="string">"LUA_TABLE"</span>] = <span class="string">"toluafix_totable"</span></span><br><span class="line">_is_functions[<span class="string">"LUA_TABLE"</span>] = <span class="string">"toluafix_istable"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> toWrite = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> currentString = <span class="string">''</span></span><br><span class="line"><span class="keyword">local</span> out</span><br><span class="line"><span class="keyword">local</span> WRITE, OUTPUT = <span class="built_in">write</span>, <span class="built_in">output</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span><span class="params">(s)</span></span></span><br><span class="line">    <span class="comment">-- ...</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span><span class="params">(a)</span></span></span><br><span class="line">    <span class="comment">-- ...</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">post_output_hook</span><span class="params">(package)</span></span></span><br><span class="line">    <span class="keyword">local</span> result = <span class="built_in">table</span>.<span class="built_in">concat</span>(toWrite)</span><br><span class="line">    <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">replace</span><span class="params">(pattern, replacement)</span></span></span><br><span class="line">        <span class="comment">-- ...</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    replace(<span class="string">[[#ifndef __cplusplus</span></span><br><span class="line"><span class="string">#include "stdlib.h"</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">#include "string.h"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#include "tolua++.h"]]</span>,</span><br><span class="line">      <span class="string">[[extern "C" &#123;</span></span><br><span class="line"><span class="string">#include "tolua_fix.h"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#include &lt;map&gt;</span></span><br><span class="line"><span class="string">#include &lt;string&gt;</span></span><br><span class="line"><span class="string">#include "MyClass.h"</span></span><br><span class="line"><span class="string">#include "CCLuaEngine.h"]]</span>)</span><br><span class="line"></span><br><span class="line">    replace(<span class="string">[[/* Exported function */</span></span><br><span class="line"><span class="string">TOLUA_API int  tolua_Cocos2d_open (lua_State* tolua_S);]]</span>, <span class="string">[[]]</span>)</span><br><span class="line"></span><br><span class="line">    replace(<span class="string">[[*((LUA_FUNCTION*)]]</span>, <span class="string">[[(]]</span>)</span><br><span class="line"></span><br><span class="line">    replace(<span class="string">[[tolua_usertype(tolua_S,"LUA_FUNCTION");]]</span>, <span class="string">[[]]</span>)</span><br><span class="line"></span><br><span class="line">    replace(<span class="string">[[toluafix_pushusertype_ccobject(tolua_S,(void*)tolua_ret]]</span>,</span><br><span class="line">        <span class="string">[[int nID = (tolua_ret) ? (int)tolua_ret-&gt;m_uID : -1;</span></span><br><span class="line"><span class="string">    int* pLuaID = (tolua_ret) ? &amp;tolua_ret-&gt;m_nLuaID : NULL;</span></span><br><span class="line"><span class="string">    toluafix_pushusertype_ccobject(tolua_S, nID, pLuaID, (void*)tolua_ret]]</span>)</span><br><span class="line"></span><br><span class="line">    replace(<span class="string">'\t'</span>, <span class="string">'    '</span>)</span><br><span class="line"></span><br><span class="line">    WRITE(result)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>因为是单独导出，所以使用的时候要先进行注册，在生成的 <code>LuaMyClass.hpp</code> 中有一个 export function，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TOLUA_API <span class="keyword">int</span>  <span class="title">tolua_MyClass_open</span> <span class="params">(lua_State* tolua_S)</span></span>;</span><br></pre></td></tr></table></figure>
<p>调用这个函数就可以一键注册 <code>MyClass</code> 的所有方法到 Lua 环境中去。</p>
<p>首先，将 <code>MyClass.h, MyClass.cpp, LuaMyClass.hpp</code> 拷贝到项目中去，然后包含 <code>LuaMyClass.hpp</code>，再调用函数 <code>tolua_MyClass_open</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cocos2d.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LuaMyClass.hpp"</span></span></span><br><span class="line"><span class="comment">//#include ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> AppDelegate::applicationDidFinishLaunching()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    lua_State *L = pStack-&gt;getLuaState();</span><br><span class="line"></span><br><span class="line">    tolua_MyClass_open(L);</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linjinxin.com/2019/11/25/python/type/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林锦新">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome to Code World">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/25/python/type/" itemprop="url">【Python】数据类型</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-25T20:36:56+08:00">
                2019-11-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/11/25/python/type/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/11/25/python/type/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>**</p>
</blockquote>
<h1 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h1><p>特殊类型：空值为 <code>None</code>，如果要使一个变量为空值，得手动设置 <code>var = None</code>，未定义的变量不是空值，而是非法变量；空值可以使用，比如作为参数传给函数，而未定义变量则不能使用。</p>
<p>整数、浮点数、布尔值、字符串分别对应的数据类型是 <code>int, float, bool, str</code>。</p>
<p>整数支持二进制、八进制、十进制、十六进制。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(0b111, 0o111, 111, 0x111)</span><br><span class="line">(7, 73, 111, 273)</span><br></pre></td></tr></table></figure>
<p>浮点数可以用科学计数法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">print</span>(3.14, 3.14e2, -3.14e-2)</span><br><span class="line">(3.14, 314.0, -0.0314)</span><br></pre></td></tr></table></figure>
<p>布尔类型只有 <code>True, False</code> 两个取值，注意首字母大写。</p>
<p>字符串可以使用单引号、双引号括起来，\ 表示转义字符，使用单引号括起来的字符串可以直接用 “ 表示双引号不需要转义，同样的使用双引号括起来的字符串可以直接使用 ‘ 表示单引号不需要转义，即单引号和双引号是平等的，意义一样的。三引号同样表示字符串，一般用于表示多行字符串，使用三引号不需要使用 <code>\n</code> 来换行，而是在代码里直接换行，三引号可以是三对单引号，也可以是三对双引号，意义是一样的。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/user/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'"string"\n\'str\''</span>)</span><br><span class="line">print(<span class="string">"\"string\"\n'str'"</span>)</span><br><span class="line">print(<span class="string">'''"hello\tworld, 'ljx'"'''</span>)</span><br><span class="line">print(<span class="string">"""line1</span></span><br><span class="line"><span class="string">line2</span></span><br><span class="line"><span class="string">line3"""</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ python test.py</span><br><span class="line"><span class="string">"string"</span></span><br><span class="line"><span class="string">'str'</span></span><br><span class="line"><span class="string">"string"</span></span><br><span class="line"><span class="string">'str'</span></span><br><span class="line"><span class="string">"hello  world, 'ljx'"</span></span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br></pre></td></tr></table></figure>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量必须先定义再使用，使用未定义的变量会报错，Python 没有显式定义变量的语句，给变量赋值就是定义变量的过程。Python 是动态语言，即一个变量可以保存任意类型的值，可以使用赋值传递给多个变量赋值，也可以使用逗号隔开同时为多个变量分别赋值。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/user/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">a, b, c = <span class="number">10</span>, <span class="keyword">True</span>, <span class="number">3.14</span></span><br><span class="line">d = e = a</span><br><span class="line">a = <span class="string">'str'</span></span><br><span class="line">print(a, b, c, d, e) <span class="comment"># ('str', True, 3.14, 10, 10)</span></span><br></pre></td></tr></table></figure>
<p>Python 没有真正意义上的常量，全大写的变量名表示这是一个常量，但也只是一个约定而已，这个“常量”的值还是可以修改的。</p>
<h1 id="高级数据类型"><a href="#高级数据类型" class="headerlink" title="高级数据类型"></a>高级数据类型</h1><p>Python 的高级数据类型，也是 Python 最重要的特性，就是它的容器类，包括列表(List)、元组(Tuple)、字典(Dict)、集合(Set)。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>列表，即数组，有序的集合，使用一对中括号 [] 来表示，下标从 0 开始，也可以使用负数来从后往前索引，这时下标从 -1 开始。List 可以随时增删查改，其常用接口如下：</p>
<ul>
<li><code>list[inx]</code> 拿到某个位置的元素；</li>
<li><code>list.append(val)</code> 往列表最后插入元素；</li>
<li><code>list.insert(inx, val)</code> 往指定位置插入元素；</li>
<li><code>list.pop()</code> 删除末尾元素；</li>
<li><code>list.pop(i)</code> 删除指定位置元素；</li>
<li><code>list.remove(val)</code> 删除第一个值为 val 的元素；</li>
<li><code>list.clear()</code> 清空列表，删除所有元素；</li>
<li><code>list.index(val[,start[,end]]</code> 返回第一个值为 val 的下标，start, end 限制在特定子序列中查找；</li>
<li><code>list.count(val)</code> 返回 val 在列表中出现的次数；</li>
<li><code>list.reverse()</code> 反转列表；</li>
<li><code>list.copy()</code> 浅拷贝，这里的浅拷贝指的是元素浅拷贝，拷贝之后的列表和源列表是两个独立的列表了。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/user/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="keyword">True</span>, <span class="string">"name"</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">3.14</span>]</span><br><span class="line">arr2 = arr.copy()</span><br><span class="line">print(arr)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">print(arr[<span class="number">0</span>], arr[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">arr.pop()</span><br><span class="line">arr.pop(<span class="number">-2</span>)</span><br><span class="line">sub_list = arr[<span class="number">-1</span>]</span><br><span class="line">sub_list[<span class="number">0</span>], sub_list[<span class="number">1</span>] = sub_list[<span class="number">1</span>], sub_list[<span class="number">0</span>]</span><br><span class="line">arr.insert(<span class="number">0</span>, <span class="number">666</span>)</span><br><span class="line">arr.append(<span class="number">777</span>)</span><br><span class="line">print(arr)</span><br><span class="line">print(arr2)</span><br></pre></td></tr></table></figure>
<p>运行结果如下，重点看一下最后两句的输出，列表可以嵌套子列表，arr[-2] 就是一个子列表，arr 只是保存着这个子列表的一个引用，而 <code>list.copy</code> 的浅拷贝就体现在这里，arr 和 arr2 是两个完全独立的列表，修改其中一个列表不会影响到另一个列表，从列表层面上来讲是“深拷贝”的；但拷贝的时候，每个元素的值是浅拷贝的，所以 arr[-2] 和 arr2[-2] 保存的是同一个引用，任何一个的元素改了另一个也会跟着改。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python test.py</span><br><span class="line">[1, 2, True, <span class="string">'name'</span>, [3, 4], 3.14]</span><br><span class="line">0 3.14</span><br><span class="line">[666, 0, 2, True, [4, 3], 777]</span><br><span class="line">[1, 2, True, <span class="string">'name'</span>, [4, 3], 3.14]</span><br></pre></td></tr></table></figure>
<h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><p>List 本身就可以当作栈使用，使用其 <code>append</code> 函数进栈，<code>pop</code> 函数出栈。</p>
<p>List 也可以当成队列使用，<code>list.append()</code> 进队列，<code>list.pop(0)</code> 出队列；反向队列则 <code>list.append(0)</code> 进队列，<code>list.pop()</code> 出队列。但无论是正向队列还是反向队列，总有一个操作效率特别低，正向队列出队的时候特别慢，反向队列进队的时候特别慢，所以使用列表来表示队列不是最佳选择。</p>
<h1 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h1><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>类型判断有 <code>type</code> 和 <code>isinstance</code> 两个函数，<br>UnicodeEncodeError: ‘gbk’ codec can’t encode character u’\xa5’ in position 0: illegal multibyte sequence<br>UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 0-3: ordinal not in range(128)</p>
<p>  1.将字符串全都转成byte string。<br>            self.response.out.write(“你好”+self.request.get(“argu”).encode(“utf-8”))<br>        2.将字符串全都转成unicode string。<br>           self.response.out.write(u”你好”+self.request.get(“argu”))<br>            byte string转换成unicode string可以这样转unicode(unicodestring, “utf-8”)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linjinxin.com/2019/11/25/sfml/event/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林锦新">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome to Code World">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/25/sfml/event/" itemprop="url">【SFML】事件管理</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-25T15:19:43+08:00">
                2019-11-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SFML/" itemprop="url" rel="index">
                    <span itemprop="name">SFML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/11/25/sfml/event/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/11/25/sfml/event/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>**</p>
</blockquote>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>SFML 的事件使用联合(union)实现，即所有类型的事件使用同一个数据类型，使用的时候先通过 <code>event.type</code> 拿到事件类型，再去拿相应的成员数据，去拿不属于当前事件类型的成员数据是非法的，通常会拿到一个随机值或非法值。事件由窗口的 <code>pollEvent</code> 或 <code>waitEvent</code> 生产，通常是在主循环中迭代处理每一个事件。下面是一个典型的事件循环，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dealEvent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sf::Event evt;</span><br><span class="line">    <span class="keyword">while</span> (window.pollEvent(evt))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (evt.type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> sf::Event::Closed:</span><br><span class="line">            window.close();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> sf::Event::Resized:</span><br><span class="line">            window.display();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> sf::Event::KeyPressed:</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="关闭事件"><a href="#关闭事件" class="headerlink" title="关闭事件"></a>关闭事件</h1><p>当用户关闭窗口时，关闭事件 <code>sf::Event:Closed</code> 会触发，比如点击关闭按钮，按下键盘快捷键等；这时候只是收到一个关闭请求，窗口并没有真正关闭，要在监听到关闭事件的时候手动调用 <code>window.close()</code> 才能关闭窗口。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (event.type == sf::Event::Closed)</span><br><span class="line">    window.close();</span><br></pre></td></tr></table></figure>
<h1 id="调整大小事件"><a href="#调整大小事件" class="headerlink" title="调整大小事件"></a>调整大小事件</h1><p>当窗口大小改变时，调整大小事件 <code>sf::Event:Resized</code> 会触发，无论是用户手动去调整窗口大小或者程序通过接口 <code>window.setSize()</code> 来调整大小。这个事件通常用于调整渲染设置，比如 OpenGL 的渲染视口大小或者 SFML 图形的显示视图，即使窗口没什么显示的，也能调用 <code>window.display()</code> 来刷新视图。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (event.type == sf::Event::Resized)</span><br><span class="line">&#123;</span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, evt.size.width, evt.size.height);</span><br><span class="line">    window.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="获得-失去焦点事件"><a href="#获得-失去焦点事件" class="headerlink" title="获得/失去焦点事件"></a>获得/失去焦点事件</h1><p>当窗口获得焦点时会触发事件 <code>sf::Event::GainFocus</code>，失去焦点时会触发事件 <code>sf::Event::LostFocus</code>，这两个事件没有额外的数据，通常用于做一些暂停/恢复操作。当用户切换到其它窗口时，当前窗口会失去焦点，切换回当前窗口时会获得焦点，失去焦点的窗口将不再监听键盘事件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (event.type == sf::Event::LostFocus)</span><br><span class="line">    myGame.pause();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (event.type == sf::Event::GainedFocus)</span><br><span class="line">    myGame.resume();</span><br></pre></td></tr></table></figure>
<p>有个特别的点，监听到失去焦点事件时，如果对窗口做一些操作，比如设置窗口大小，则窗口会立即重新获得焦点，相当于使用代码来自动激活窗口。</p>
<h1 id="字符输入事件"><a href="#字符输入事件" class="headerlink" title="字符输入事件"></a>字符输入事件</h1><p>注意把这个事件和键盘事件区分开，<code>sf::Event::TextEntered</code> 不关心键盘操作，只关心键盘操作的结果，即最后产生的字符。特别是同时按下多个键的情况，比如同时按下 <code>shift+1</code>，键盘事件会产生两个 <code>KeyPressed</code> 事件，但只会产生一个 <code>TextEntered</code>，输入的结果为 <code>!</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linjinxin.com/2019/11/23/sfml/window/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林锦新">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome to Code World">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/23/sfml/window/" itemprop="url">【SFML】窗口管理</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-23T20:17:24+08:00">
                2019-11-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SFML/" itemprop="url" rel="index">
                    <span itemprop="name">SFML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/11/23/sfml/window/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/11/23/sfml/window/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>**</p>
</blockquote>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>SFML 的全称是 <code>Simple and Fast Multimedia Library</code>，即简单快速的多媒体库，顾名思义就是一个用于开发多媒体应用的库，包含 <strong>系统、窗口、图形、音频、网络</strong> 五个模块。SFML 为 PC 各个组件提供简单的接口，简化游戏及多媒体应用的开发，目前适用于 PC 的多个平台，包括 Windows，Linux，MacOS，未来可能会拓展到 Android 和 IOS，SFML 是使用 C++ 编写的库，同时官方也绑定了 C，Java，Pyhton，.Net，Go 等多种语言。另外，SFML 内嵌了 OpenGL 模块，很容易用来开发 OpenGL 程序，OpenGL 只是一个底层的图形库，本身没有窗口管理模块，所以需要借助第三方库，常用的库有 <code>glut(freeglut), glfw, qt, sfml</code>，而 SFML 除了窗口管理，还有系统图形、音频、网络模块，具备了一个完整多媒体应用所需的各个模块，无疑是一个比较好的选择，当然 QT 也是。</p>
<p>SFML 官网地址：<a href="https://www.sfml-dev.org，" target="_blank" rel="noopener">https://www.sfml-dev.org，</a> 官方有各个操作系统和各个版本的下载地址，以及 github 源码，以及清晰明了的 API 文档和教程。</p>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>本文基于 Windows 系统，C++ 语言，Visual Studio 2019 IDE。</p>
<p>SFML 包括 <code>system, window, graphics, audio, network</code> 5 个模块，对应的 Windows 编译库就有下面 5 个库：</p>
<ul>
<li><code>sfml-system.lib</code>：系统库，最基础的库，是其它库的基础依赖；</li>
<li><code>sfml-window.lib</code>：窗口管理库，依赖于 <code>sfml-system.lib</code>；</li>
<li><code>sfml-graphics.lib</code>：图形库，依赖于 <code>sfml-system.lib</code> 和 <code>sfml-window.lib</code>；</li>
<li><code>sfml-audio.lib</code>：音频库，依赖于 <code>sfml-system.lib</code>；</li>
<li><code>sfml-network.lib</code>：网络库，依赖于 <code>sfml-system.lib</code>。</li>
</ul>
<p>和 Windows 上的其它库一样，这五个库都区分 32 位和 64 位，debug 版本和 release 版本，动态库和静态库，以系统库为例，32 位版本和 64 位版本各有 <code>sfml-system.lib, sfml-system-d.lib, sfml-system-s.lib, sfml-system-s-d.lib</code> 这 4 个 lib 文件，另外还有 <code>sfml-system.dll, sfml-system-d.dll</code> 这 2 个 dll 文件，所以一个库就有 (4 + 2) * 2 = 12 个文件，5 个库就是 60 个文件，emm，是有点多。</p>
<p>可以看到所有库都依赖于系统库，图形库额外还要依赖于窗口库；如果只是想利用 SFML 来创建和管理窗口，则引用 <code>sfml-system, sfml-window</code> 这两个库，如果要使用其内置接口来绘制图形，则再加个 <code>sfml-graphics</code> 库；如果只是单纯的播放音频，则引入 <code>sfml-system, sfml-audio</code> 这两个库，只是单纯是使用网络功能，则引入 <code>sfml-system, sfml-network</code> 这两个库，当然如果使用音频或网络的时候是个 GUI 应用（非控制台应用），那 <code>sfml-window</code> 也是必不可少的。当然除了这五个库，还有其它基础库需要引入，<code>gdi32.lib, opengl32.lib, ogg.lib</code>，不过这些库 Visual Studio 都会自动帮我们引入，所以不用管，详细的可看官方文档 <a href="https://www.sfml-dev.org/tutorials/2.5/start-vc.php" target="_blank" rel="noopener">SFML and Visual Studio</a>，关于 Visual Studio 配置的详细内容，也可看我<a href>这篇文章</a>。</p>
<h1 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SFML/Window.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// sf::Window window(sf::VideoMode(800, 600), "My window");</span></span><br><span class="line"></span><br><span class="line">    sf:Window window;</span><br><span class="line">    window.create(sf::VideoMode(<span class="number">800</span>, <span class="number">600</span>), <span class="string">"My window"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先包含两个库 <code>sfml-system.lib</code> 和 <code>sfml-window.lib</code>，引入头文件 <code>&lt;sfml/window.hpp&gt;</code>。使用 <code>sf::Window</code> 类来创建一个窗口，有两种方式，一是在构造函数中直接传入参数，二是先创建一个无数据的对象，再调用 <code>create</code> 静态方法来初始化参数，二者的效果是一样的。窗口接收 4 个参数，</p>
<ul>
<li>arg1 的类型为 sf::VideoMode，表示窗口的显示模式；</li>
<li>arg2 为窗口的标题；</li>
<li>arg3 为窗口样式，不传则为默认值 <code>sf::Style::Default</code>；</li>
<li>arg4 为 OpenGL 的具体选项，不传则为空。</li>
</ul>
<h2 id="VideoMode"><a href="#VideoMode" class="headerlink" title="VideoMode"></a>VideoMode</h2><p><code>VideoMode</code> 包括三个属性 <code>width, height, bitsPerPixel</code>，分别表示窗口的宽度、高度和深度（每个像素多少 bit），深度不传的话则默认为 32，宽高则必须传。</p>
<p><code>VideoMode</code> 主要用途是“全屏模式”，它提供一个非常实用的静态方法 <code>getFullscreenModes</code>，用于获取当前操作系统下可用的全屏显示模式列表（显卡和显示器是否支持），只有使用这个列表里的显示模式，才能正常显示一个全屏窗口。我们玩主机游戏的时候会有一个选择分辨率的窗口，上面列出的分辨率不是随便列的，而是当前系统支持的显示模式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;sf::VideoMode&gt; modes = sf::VideoMode::getFullscreenModes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; modes.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sf::VideoMode mode = modes[i];</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Mode #"</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span></span><br><span class="line">                &lt;&lt; mode.width &lt;&lt; <span class="string">"x"</span> &lt;&lt; mode.height &lt;&lt; <span class="string">" - "</span></span><br><span class="line">                &lt;&lt; mode.bitsPerPixel &lt;&lt; <span class="string">" bpp"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sf::<span class="function">Window <span class="title">window2</span><span class="params">(modes[<span class="number">0</span>], <span class="string">"Window2"</span>, sf::Style::Fullscreen)</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子打印出所有可用的显示模式，并使用其中一个显示模式创建一个全屏窗口。</p>
<p><code>VideoMode</code> 还提供另一个静态方法 <code>getDesktopMode</code>，用于获取当前桌面使用的显示模式，这样就能拿到桌面的分辨率和显示深度，从而创建一个和桌面一样分辨率和显示深度的窗口或其它操作。</p>
<h2 id="窗口样式"><a href="#窗口样式" class="headerlink" title="窗口样式"></a>窗口样式</h2><p>SFML 提供五种窗口样式，有些样式可以组合，有些则与其它样式互斥。</p>
<ul>
<li><code>sfml::Style::None</code>：无任何装饰，不能与其它样式组合，在一些特殊场合很有用，比如启动界面；</li>
<li><code>sfml::Style:Fullscreen</code>：全屏样式，全屏显示且无任何装饰，不能与其它样式组合，必须使用系统支持的显示模式；</li>
<li><code>sfml::Style::Titlebar</code>：带一个标题栏，可与其它样式组合使用；</li>
<li><code>sfml::Style:Resize</code>：可缩放且提供最大化按钮，可与其它样式组合使用；</li>
<li><code>sfml:Style:Close</code>：可关闭，提供关闭按钮，可与其它样式组合使用。</li>
</ul>
<p>默认为第六种样式 <code>sfml:Style:Default</code>，它是后面三种样式的组合，即 <code>sfml::Style::Titlebar | sfml::Style::Resize | sfml::Style::Close</code>，有标题栏、最大化按钮和关闭按钮，可调整大小和关闭，统称为窗口样式；因此，SFML 的窗口样式可大致分为三种，无样式、全屏样式和窗口样式。</p>
<h2 id="OpenGL-上下文"><a href="#OpenGL-上下文" class="headerlink" title="OpenGL 上下文"></a>OpenGL 上下文</h2><p>创建一个窗口完整的代码如下，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sf::ContextSettings settings;</span><br><span class="line">sf::Window window(sf::VideoMode(400, 400), "Hello SFML", sf::Style::Default, settings);</span><br></pre></td></tr></table></figure>
<p><code>VideoMode</code> 和 <code>Style</code> 分别表示显示模式和窗口样式，而最后一个参数 <code>sf::ContextSettings</code> 则是专门为 OpenGL 定制的，用于定义 OpenGL context 的配置，比如 OpenGL 主版本、次版本、深度缓冲区的位数、模块缓冲区的位数、抗锯齿等级，具体的这里先不说，后面讲到 OpenGL 的时候再详细讲，现在只需要知道这个参数可省略就行。</p>
<h1 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h1><p>上面的代码只创建一个“死窗口”，首先在 <code>main</code> 函数创建完窗口之后马上就结束了，所以你会看到一个窗口闪一下就没了，然后程序就退出了，所以需要在创建窗口之后让程序停在某个地方而不是直接退出，即定义一个程序主循环。光让程序停住还不行，这时窗口虽然看到了，但还是个“死窗口”，无法移动、关闭、缩放，因为没有把窗口加入到程序主循环中去。把窗口加入到主循环，其实就是实时监听并处理窗口事件，对窗口的所有操作都是基于事件。</p>
<p>程序主循环最容易想到的就是在 <code>main</code> 方法中加入一个死循环 <code>while(true){ ... }</code>，唯一要处理的就是什么时候跳出循环，这里我们关闭窗口的时候退出程序，自然是窗口关闭的时候退出主循环，所以主循环的写法为 <code>while(window.isOpen()){ ... }</code>，而循环内则处理窗口事件。创建一个“活窗口”的完整代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SFML/Window.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sf::Window window(sf::VideoMode(800, 600), "My window");</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (window.isOpen())</span><br><span class="line">    &#123;</span><br><span class="line">        sf::Event event;</span><br><span class="line">        <span class="keyword">while</span> (window.pollEvent(event))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (event.type == sf::Event::Closed)</span><br><span class="line">                window.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h1><p>SFML 的窗口只是提供一个 OpenGL 上下文环境或者 SFML 内部绘制的环境，不具体其它专用的 GUI 库提供的高级功能，但也能做一些基础的操作，比如设置窗口位置、大小、标题、图标等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SFML/Graphics.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sf::Window window(sf::VideoMode(400, 400), "Hello SFML");</span><br><span class="line">    sf::Image image;</span><br><span class="line">    <span class="keyword">if</span> (image.loadFromFile(<span class="string">"../Res/title.png"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> size = image.getSize();</span><br><span class="line">        window.setIcon(size.x, size.y, image.getPixelsPtr());</span><br><span class="line">    &#125;</span><br><span class="line">    window.setTitle(<span class="string">"SFML Window"</span>);</span><br><span class="line">    window.setPosition(sf::Vector2i(<span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line">    window.setSize(sf::Vector2u(<span class="number">960</span>, <span class="number">640</span>));</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置窗口图标需要使用 <code>Image</code> 对象来加载图片，所以需要引用图形库，即需要 <code>sfml-system.lib, sfml-window.lib, sfml-graphics.lib</code> 三个库，头文件则导入 <code>SFML/Graphics.hpp&gt;</code> 即可。</p>
<p>如果要对窗口做更高级的操作，可以使用其它 GUI 库来创建窗口，然后将 SFML 的绘制环境嵌入进去，这种方式需要第三方创建的窗口返回一个特定操作系统的句柄，然后以这外句柄为参数来创建 SFML 窗口，SFML 窗口可以捕捉到第三方库创建的父窗口的事件，而且不影响父窗口的管理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sf::WindowHandle handle = <span class="comment">/* specific to what you're doing and the library you're using */</span>;</span><br><span class="line">sf::<span class="function">Window <span class="title">window</span><span class="params">(handle)</span></span>;</span><br></pre></td></tr></table></figure>
<p>反过来，也可以使用 SFML 来创建窗口，然后返回一个特定操作系统的句柄，再由其它库操作这个句柄从而实现更高级的窗口操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sf::Window window(sf::VideoMode(800, 600), "SFML window");</span><br><span class="line">sf::WindowHandle handle = window.getSystemHandle();</span><br><span class="line"><span class="comment">// you can now use the handle with OS specific functions</span></span><br></pre></td></tr></table></figure>
<h1 id="帧率"><a href="#帧率" class="headerlink" title="帧率"></a>帧率</h1><p>SFML 有两种设置帧率的方法，第一种是开启显示器垂直同步，第二种是手动设置最大帧率，两种方式选其一，不能同时使用，即不能开启显示器垂直同步的同时又手动设置最大帧率。</p>
<p>通过接口 <code>setVerticalSyncEnabled</code> 开启显示器垂直同步，可解决一些视觉问题，比如撕裂，当应用的刷新频率与显示器不同步时，显示器的上方可能会显示上一帧的内容，而下方显示下一帧的内容，这就出现的画面撕裂的情况；要注意的是这个可能会无效，原因是显示器把垂直同步关了，把显示器设置中的 <code>vertical synchronization</code> 从 <code>off</code> 改为 <code>controlled by application</code> 即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.setVerticalSyncEnabled(<span class="literal">true</span>); <span class="comment">// call it once, after creating the window</span></span><br></pre></td></tr></table></figure>
<p>通过接口 <code>setFramerateLimit</code> 手动设置最大帧率，这是 SFML 内部使用 <code>sf::Clock</code> 和 <code>sf:sleep</code> 实现的，所以不是完全可靠的，特别是高帧率，其取决于特定操作系统和底层硬件，不要用此来实现精准计时。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.setFramerateLimit(<span class="number">60</span>); <span class="comment">// call it once, after creating the window</span></span><br></pre></td></tr></table></figure>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li>SFML 支持一个程序创建多个窗口，每个窗口可以运行在单独的线程上，也可以都运行在主线程上（在 MacOS 上，所以窗口必须运行在主线程上）；</li>
<li>SFML 暂不支持多显示器管理，即多个显示器的时候，你无法决定窗口默认显示在哪个显示器上；</li>
<li>窗口比桌面大可能会显示不正常，当然一般也不会创建比桌面还大的窗口，但要注意的是使用 <code>VideoMode:getDesktopMode()</code> 获取的显示模式，再加上边界和标题格栏等装饰物，创建出来的窗口是比桌面大的；</li>
<li>窗口的事件处理必须和窗口在同一线程，如果实在想分离一些东西出来，可以把渲染、物理、逻辑等分离到其它线程，但窗口管理和该窗口的事件处理必须在同一线程。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linjinxin.com/2019/11/16/python/init/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林锦新">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome to Code World">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/16/python/init/" itemprop="url">【Python】基础知识</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-16T17:22:33+08:00">
                2019-11-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/11/16/python/init/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/11/16/python/init/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>Python 是一门很高级的脚本语言，不用编译，解释运行。Python 使用简单，有很多封装好的库，但运行效率很慢。Python 主要应用于网站后台，游戏后台，还有很多系统工具，Python 是程序员日常开发自动化工具首选的脚本语言。</p>
<p>Python 目前有两个大版本，Python2.x 和 Python3.x，这两个版本的差别挺大的，<strong>本系列文章基于 Python3</strong>。</p>
<p>安装 Python 很简单，从官网下载之后安装，把安装根目录添加到环境变量 path，就可以在命令行直接运行 Python 命令。</p>
<p>安装完 Python 还需要安装一个 Python 的自动包管理工具 pip。从 <a href="https://bootstrap.pypa.io/get-pip.py" target="_blank" rel="noopener">这个地址</a> 下载 pip 的官方安装脚本 <code>get-pip.py</code>，然后打开命令行，输入 <code>Python get-pip.py</code>，这个过程会自动下载并安装，除了 pip 还会自动下载并安装 setuptools 和 wheel 这两个包。pip 安装完成之后会在 Python 的安装目录下创建一个 Scripts 文件夹，pip 和其它安装的包都在这个目录下，把 Scripts 这个路径添加到环境变量，就可以直接在命令行运行 pip 命令或其它命令。</p>
<h2 id="配置开发环境"><a href="#配置开发环境" class="headerlink" title="配置开发环境"></a>配置开发环境</h2><p>开发环境因人而异，比较流行的 Python IDE 是 Pycharm，但我不想装太多 IDE，所以想用文本编辑器来做开发。我个人比较喜欢 Visual Studio Code，它像其它编辑器一样轻量，又可以通过不同的插件来实现 IDE 一样的功能，代码提示和断点调试。首先装一个 Python 的调试插件，在扩展工具那里搜 Python，安装第一项即可，这是微软官方提供的一个插件，也可以通过 <a href="https://marketplace.visualstudio.com/items?itemName=ms-Python.Python" target="_blank" rel="noopener">这个地址</a> 下载。</p>
<p>接下来通过 pip 工具安装三个常用的包，</p>
<ul>
<li><code>pip install pylint</code> 安装 pylint 工具，这个工具用于检查源代码中的错误和不符合规范的地方；</li>
<li><code>pip install flake8</code> 安装 flake8 插件，也用于检查代码中的错误或不规范的地方。要开启或关闭这个插件，只需要在用户配置或工作区配置中进行设置即可；输入 ctrl+shift+p 打开 vs code 的命令窗口，然后输入 workspace settings 可以打开工作区设置，输入 user settings 可以打开用户设置，工作区设置只针对当前的工作区（打开的文件夹），用户设置针对所有工作区，这几个设置的优先级是工作区设置会覆盖用户设置，用户设置覆盖默认设置。打开工作区设置或用户设置之后，添加 <code>&quot;python.linting.flake8Enabled&quot;: true</code> 就可以开启 flake8，如果要关闭改为 false 即可，或者删掉（因为默认设置就是关闭的）；</li>
<li><code>pip install yapf</code> 安装 yapf 插件，用于格式化代码，安装完 yapf 并启用之后，就可以使用 vs code 默认的快捷键 alt+shift+f 来格式化代码。打开工作区设置或用户设置，添加 <code>&quot;python.formatting.provider&quot;: &quot;yapf&quot;</code> 就可以启用 yapf，要关闭则改为 none 或者其它的格式化插件。</li>
</ul>
<h2 id="Python-解释器"><a href="#Python-解释器" class="headerlink" title="Python 解释器"></a>Python 解释器</h2><p>Python 解释器用于解释执行 Python 源代码，在命令行中输入 <code>Python xx.py</code> 就可以解释执行某个 Python 源文件，这个 Python.exe 就是 Python 的解释器。Python 安装完之后默认会有一个 GUI 工具 Python IDLE 和一个命令行工具 Python Comand Line，运行 GUI 工具或者命令行工具，或者在 cmd 中输入 Python 命令，都可以打开 Python 解释器的交互环境。解释器交互环境以 &gt;&gt;&gt; 为标志，在交互环境下每输入一条语句都会被立即解释执行，每条语句如果有返回结果都会输出，可以将 Python 解释器当作一个简单的计算器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> <span class="string">"hello world"</span></span><br><span class="line">hello world</span><br><span class="line">&gt;&gt;&gt; 3 * 5</span><br><span class="line">15</span><br><span class="line">&gt;&gt;&gt; 4 &amp; 5 | 10</span><br><span class="line">14</span><br><span class="line">&gt;&gt;&gt; a = 1024 * 1024</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span> a</span><br><span class="line">1048576</span><br><span class="line">&gt;&gt;&gt; a + 1</span><br><span class="line">1048577</span><br><span class="line">&gt;&gt;&gt; import math</span><br><span class="line">&gt;&gt;&gt; math.pow(2, 10)</span><br><span class="line">1024.0</span><br></pre></td></tr></table></figure>
<p>退出 Python 交互环境使用 exit 函数即可，输入 <code>exit()</code> 即可返回到命令行或者关闭 Python IDLE 或 Python Command Line。</p>
<h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><h2 id="输出-print"><a href="#输出-print" class="headerlink" title="输出 print"></a>输出 print</h2><p>和大多数语言一样，Python 使用 print 作为输出的关键字，在 2.x 中 print 只是一个关键字，但到了 3.x print 是一个函数了，所以 2.x 的 print 的用法是 <code>print message</code>，而 3.x 的用法是 <code>print(message)</code>，当然 2.x 加上括号也可以，但这个括号不是函数调用的意思，只是单纯的把一个表达式括起来而已，但 3.x 必须有括号，这个括号表示这是一个函数调用。</p>
<h3 id="基本输出"><a href="#基本输出" class="headerlink" title="基本输出"></a>基本输出</h3><p>print 可直接输出字符串、数字、布尔值、列表、字典等所有数据类型，也可以在参数里写上表达式，print 会输出表达式计算后的结果。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#output all datatype</span></span><br><span class="line">print(<span class="string">"hello world"</span>)</span><br><span class="line">print(<span class="number">500</span>)</span><br><span class="line">print(<span class="keyword">True</span>)</span><br><span class="line">print((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">print([<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>])</span><br><span class="line">print(&#123;<span class="string">'a'</span>: <span class="number">10</span>, <span class="string">'b'</span>: <span class="number">20</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output expression</span></span><br><span class="line">print(<span class="number">16</span> * <span class="number">16</span>)</span><br><span class="line">print(<span class="number">100</span> == <span class="string">'100'</span>)</span><br><span class="line">print(<span class="number">100</span> == <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">500</span><br><span class="line">True</span><br><span class="line">(1, 2, 3)</span><br><span class="line">[<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</span><br><span class="line">&#123;<span class="string">'a'</span>: 10, <span class="string">'b'</span>: 20&#125;</span><br><span class="line">256</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<h3 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h3><p>print 可以一次性输出多个数据，用逗号隔开即可，如 <code>print(1, 2)</code>；print 输出多个数据时默认用空格隔开，也可以使用 sep 自定义间隔符，如 <code>print(1, 2, sep = &#39;-&#39;)</code>；print 默认以回车为结束符，即打印完数据之后都会换行，可以使用 end 参数自定义结束符，如 <code>print(1, end = &#39;&#39;)</code>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># output param</span></span><br><span class="line">print(<span class="string">'a'</span>, <span class="string">'b'</span>, end=<span class="string">' | '</span>)</span><br><span class="line">print(<span class="keyword">True</span>, <span class="keyword">False</span>, sep=<span class="string">'-&gt;'</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b | True-&gt;False</span><br></pre></td></tr></table></figure>
<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p>Python 的 print 不像 c 语言中的 printf 一样死板，而是像 c++ 中的 cout 一样智能，无论什么数据类型的数据都可以直接输出；但 Python 的 print 也可以像 c 语言中的 printf 一样格式化输出，用法基本与 c 语言一样，只是写法不大一样，Python 格式化输出的变量必须放在 %() 里面，如 <code>print(&quot;%d %d&quot; %(var1, var2))</code>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># format output</span></span><br><span class="line">var = <span class="number">0x101</span></span><br><span class="line">print(<span class="string">"%d, %i, %u, %o, %x, %X, %f, %F, %g, %G, %e, %E"</span> %</span><br><span class="line">      (var, var, var, var, var, var, var, var, var, var, var, var))</span><br><span class="line">var = <span class="number">3.14</span></span><br><span class="line">print(<span class="string">"%-10.3f,%010.5f"</span> % (var, var))</span><br></pre></td></tr></table></figure>
<p>%d、%i 以有符号十进制数输出，%u 以无符号十进制数输出，%o 以八进制数输出，%x(X) 以十六进制输出，%f(F) 以浮点数输出，%e(E) 以科学计数法输出浮点数，%g(G) 为自动格式判断。以浮点数输出时，<em>%m.nf</em> 的格式表示输出宽度为 m 位，保留 n 位小数，如果数据长度不足 m 位，则默认在前面补上空格；使用 <em>%0m.nf</em> 可修改补位符为 ‘0’，也可以修改成其它补位符；默认为右对齐，即补位符加在数据的前面，使用 <em>%-m.nf</em> 可修改为左对齐。运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">257, 257, 257, 401, 101, 101, 257.000000, 257.000000, 257, 257, 2.570000e+02, 2.570000E+02</span><br><span class="line">3.140     ,0003.14000</span><br></pre></td></tr></table></figure>
<p><code>print(&quot;%d %d&quot; %(var1, var2))</code> 这是 2.x 的写法，3.x 兼容了这种写法，也提供了一种更好的写法，使用格式化输出函数 format() 将输出数据括起来，然后参数占位符使用和 c# 类似的 <em>{0}</em>，当然也可以使用上面的这些格式，如 <em>{0:%f}</em>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VAR = <span class="number">3.1414926</span></span><br><span class="line">print(<span class="string">"&#123;0:0.3f&#125;,&#123;1:0.4f&#125;"</span>.format(VAR, VAR))</span><br><span class="line">print(<span class="string">"&#123;0&#125;,&#123;1&#125;"</span>.format(<span class="string">"hello"</span>, <span class="string">"world"</span>))</span><br><span class="line">print(<span class="string">"&#123;0[0]&#125;,&#123;0[1]&#125;,&#123;1&#125;"</span>.format([<span class="string">"hello"</span>, <span class="string">"world"</span>], <span class="string">"!"</span>))</span><br></pre></td></tr></table></figure>
<p>占位符使用 {下标}，如果要有格式则使用 {下标:格式}，后面使用 .format(数据)，记住不能少了这个点。运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.141,3.1415</span><br><span class="line">hello,world</span><br><span class="line">hello,world,!</span><br></pre></td></tr></table></figure>
<h2 id="输入-input"><a href="#输入-input" class="headerlink" title="输入 input"></a>输入 input</h2><p>Python2.x 中有两个函数用于接收用户收入，<strong>raw_input 和 input</strong>；raw_input 将所有输入都当作字符串处理，因此任何输入它都能全盘接收，而 input 希望读取到一个合法的表达式，所以字符串要加上引号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; raw_input(<span class="string">"raw_input:"</span>)</span><br><span class="line">raw_input:hello</span><br><span class="line"><span class="string">'hello'</span></span><br><span class="line">&gt;&gt;&gt; raw_input(<span class="string">"raw_input:"</span>)</span><br><span class="line">raw_input:100</span><br><span class="line"><span class="string">'100'</span></span><br><span class="line">&gt;&gt;&gt; input(<span class="string">"input:"</span>)</span><br><span class="line">input:100</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; input(<span class="string">"input:"</span>)</span><br><span class="line">input:<span class="string">'hello'</span></span><br><span class="line"><span class="string">'hello'</span></span><br><span class="line">&gt;&gt;&gt; input(<span class="string">"input:"</span>)</span><br><span class="line">input:hello</span><br><span class="line">NameError: name <span class="string">'hello'</span> is not defined</span><br><span class="line">&gt;&gt;&gt; hello = <span class="string">'hello'</span></span><br><span class="line">&gt;&gt;&gt; input(<span class="string">"input:"</span>)</span><br><span class="line">input:hello</span><br><span class="line"><span class="string">'hello'</span></span><br></pre></td></tr></table></figure>
<p>可以看到，raw_input 无论接收到的输入是字符串还是数字，都会保存为字符串；而 input 则根据输入的数据的类型来保存，所以输入数字得到的结果就是数字，而输入字符串时要加上引号，不加引号 input 会将其识别为表达式，在这里的 hello 也就是被识别成变量名了。input 其实是对 raw_input 的二次封装，它可以输入一个表达式，结果是表达式计算后的结果；官方的建议是除非有特别的需求，否则不要使用 input，而是要使用 raw_input，因此到了 3.x 就把 input 去掉了，只保留了 raw_input 并改名为 input，也就是说 3.x 的 input 其实就是 2.x 的 raw_input。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; input(<span class="string">"please input a string:"</span>)</span><br><span class="line">please input a string:hello</span><br><span class="line"><span class="string">'hello'</span></span><br><span class="line">&gt;&gt;&gt; raw_input()</span><br><span class="line">NameError: name <span class="string">'raw_input'</span> is not defined</span><br></pre></td></tr></table></figure>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h2><p>Python 的每条语句独占一行，不需要分号或其它标点符号作为结束符，如果想在同一行写多条语句，就需要用分号将每条语句隔开；虽然将多条语句写成一行不会有语法错误，但很不规范，最好不要这么写。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#print("hello") print(" world") #wrong</span></span><br><span class="line">print(<span class="string">"hello"</span>, end=<span class="string">''</span>); print(<span class="string">" world"</span>, end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>有时候一条语句太长写在一行太难看，可以分成几行来写，使用反斜杠 \ 就可以实现。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = <span class="number">10</span> + \</span><br><span class="line"> <span class="number">11</span> + \</span><br><span class="line"> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>在 () [] {} 中的多行语句，则不需要 \。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;<span class="string">"apple"</span>, <span class="string">"pear"</span>, </span><br><span class="line">      <span class="string">"banana"</span>, <span class="string">"orange"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>Python 不使用花括号 {} 或者 end 等关键字来定义代码块，而是使用缩进，所以 Python 里面的缩进不仅是为了代码整洁好看，而是有语法要求的，缩进不正确是会报语法错误的。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#if True:</span></span><br><span class="line"><span class="comment">#print("done") #error</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">True</span>:</span><br><span class="line">      print(<span class="string">"done"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="注释与字符串"><a href="#注释与字符串" class="headerlink" title="注释与字符串"></a>注释与字符串</h2><ul>
<li>单行注释使用 #，多行注释使用三引号 ‘’’ 或 “””，单行注释的规范是 # 后面要空一格；</li>
<li>字符串可以使用单引号、双引号和三引号，三引号用于多行字符串，多行注释其实就是一个字符串；</li>
<li>Python 字符串变量的值不能修改，操作字符串会创建一个新的字符串；</li>
<li>在字符串前面加 r 或 R，表示这是一个原始(raw)字符串，即不解析转义字符；</li>
<li>在字符串前面加 u 或 U，表示这是一个 Unicon 字符串。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#string</span></span><br><span class="line">str1 = <span class="string">'word'</span></span><br><span class="line">str2 = <span class="string">"this is a word"</span></span><br><span class="line">str3 = <span class="string">"""this is a very</span></span><br><span class="line"><span class="string">      very very long word"""</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">raw string</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">print(<span class="string">"hello\nworld"</span>)</span><br><span class="line">print(<span class="string">r"hello\nworld"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="首行规则"><a href="#首行规则" class="headerlink" title="首行规则"></a>首行规则</h2><p>一个 py 文件首行必须指明使用的编码，如果是 Unix 类系统，py 文件是可以直接运行的，跟 Shell 脚本一样，所以首行指明 Python 的安装路径，第二行才是编码。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/user/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linjinxin.com/2019/10/14/coder/vim/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林锦新">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome to Code World">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/14/coder/vim/" itemprop="url">Vim 简明教程</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-14T12:01:21+08:00">
                2019-10-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT-日常/" itemprop="url" rel="index">
                    <span itemprop="name">IT 日常</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/14/coder/vim/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/10/14/coder/vim/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><em>先定个小目标，早睡和早起！</em></p>
</blockquote>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>Vi(Vim) 作为一个强大的编辑器，其强大的功能由非常多的命令支撑；这么多的命令靠死记硬背显示是不行的，而是需要在训练中强化记忆，这个帖子只是对常用命令作一个记录。<br>首先，要了解一下 vi 编辑器的三种模式。</p>
<ul>
<li><p>一般模式：这是最常见的模式，绝大部分的命令都是在这个模式下运行的；在这个模式下，我们可以随意地定位光标，删除任意多的内容，复制粘贴，撤销重做等等</p>
</li>
<li><p>编辑模式：一旦进入这个模式，vi 编辑器就与一般的编辑器没什么不同了，也是使用 backspace 或 delete 键进行删除，使用光标键进行移动</p>
</li>
<li><p>指令模式：在这个模式下可以执行一些指令，比如保存文件，退出 vi 编辑器等</p>
</li>
</ul>
<p>最常用的模式是一般模式，另外一般模式是另外两个模式的桥梁，也就是说另外两个模式要相互转换必须经过一般模式。刚进入 vi 时就处于一般模式，如果想从另外两个模式转换到一般模式，按 ESC 键即可。在一般模式下，输入一些能够开始编辑的命令，就进入编辑模式，比如 i, o 等命令。在一般模式下，输入命令 : 或 / 或 ? 就可以进入指令模式。</p>
<h1 id="移动定位"><a href="#移动定位" class="headerlink" title="移动定位"></a>移动定位</h1><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>h</td>
<td>光标左移</td>
</tr>
<tr>
<td>l</td>
<td>光标右移</td>
</tr>
<tr>
<td>j</td>
<td>光标下移</td>
</tr>
<tr>
<td>k</td>
<td>光标上移</td>
</tr>
<tr>
<td>+</td>
<td>移动到下一行</td>
<td>定位到本行首个非空白字符</td>
</tr>
<tr>
<td>-</td>
<td>移动到上一行</td>
<td>定位到本行首个非空白字符</td>
</tr>
<tr>
<td>$</td>
<td>移动到行尾</td>
<td>光标定位到本行第一个字符</td>
</tr>
<tr>
<td>0</td>
<td>移动到行首</td>
<td>光标定位到本行最后一个字符</td>
</tr>
<tr>
<td>w</td>
<td>移动到下个单词的首字符</td>
</tr>
<tr>
<td>e</td>
<td>移动到下个单词的尾字符</td>
<td>如果当前光标已经在本单词的尾字符，则移动到下个单词的尾字符，否则移动到本单词的尾字符</td>
</tr>
<tr>
<td>b</td>
<td>移动到上个单词的首字符</td>
</tr>
<tr>
<td>nw</td>
<td>移动 n 个单词</td>
<td>光标定位在第 n 个单词的首字符</td>
</tr>
<tr>
<td>ne</td>
<td>移动 n 个单词</td>
<td>如果当前光标在本单词的尾字符，则定位到第 n 个单词的尾字符，否则定位到第 n-1 个单词的尾字符</td>
</tr>
<tr>
<td>nb</td>
<td>向前移动 n 个单词</td>
</tr>
<tr>
<td>gg</td>
<td>移动到文件首</td>
<td>光标定位在首行的第一个字符</td>
</tr>
<tr>
<td>G</td>
<td>移动到文件末</td>
<td>光标定位在尾行的第一个字符</td>
</tr>
<tr>
<td>n</td>
<td>定位到第 n 行</td>
<td>指令模式下运行，光标定位在首字符</td>
</tr>
<tr>
<td>n</td>
<td>往下移动 n 行（输入 n 之后按回车）</td>
<td>光标定位在首字符</td>
</tr>
<tr>
<td>ctrl+f</td>
<td>往下移动一页</td>
</tr>
<tr>
<td>ctrl+b</td>
<td>住上移动一页</td>
</tr>
<tr>
<td>ctrl+d</td>
<td>往下移动半页</td>
</tr>
<tr>
<td>ctrl+u</td>
<td>往上移动半页</td>
</tr>
<tr>
<td>H</td>
<td>移动到本屏第一行</td>
</tr>
<tr>
<td>M</td>
<td>移动到本屏中间行</td>
</tr>
<tr>
<td>L</td>
<td>移动到本屏最后一行</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>hjkl 这四个命令是两对命令，hl 左右移动，jk 上下移动，这种两边成对的方式比按顺序成对更为自然。</li>
<li>向下翻页和向上翻页分别是 forward 和 behind 的意思，一般阅读往前走都是向下走的，所以 ctrl+f 是向下翻页，ctrl+b 是向上翻页。</li>
<li>向下翻半页和向上翻半页则是 down 和 up 的意思，这两个就比较好理解了，ctrl+d 向下翻半页，ctrl+u 向上翻半页。</li>
</ul>
</blockquote>
<h1 id="退出编辑器"><a href="#退出编辑器" class="headerlink" title="退出编辑器"></a>退出编辑器</h1><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>wq</td>
<td>保存后退出</td>
<td>指令模式下运行</td>
</tr>
<tr>
<td>q!</td>
<td>不保存直接强制退出</td>
<td>指令模式下运行</td>
</tr>
</tbody>
</table>
<h1 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h1><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>往后删除一个字符</td>
<td>删除当前光标所在字符</td>
</tr>
<tr>
<td>X</td>
<td>往前删除一个字符</td>
<td>删除当前光标前面的字符</td>
</tr>
<tr>
<td>dw</td>
<td>往后删除一个单词</td>
<td>连同单词后面的空白字符一起删除</td>
</tr>
<tr>
<td>de</td>
<td>往后删除一个单词</td>
<td>不删除单词后面的空白字符</td>
</tr>
<tr>
<td>db</td>
<td>往前删除一个单词</td>
<td>不删除单词前面的空白字符，不删除光标所在字符</td>
</tr>
<tr>
<td>d$</td>
<td>从当前光标位置删除到行尾</td>
<td>包括当前光标所在字符</td>
</tr>
<tr>
<td>d0</td>
<td>从当前光标位置删除到行首</td>
<td>不包括当前光标所在字符</td>
</tr>
<tr>
<td>dG</td>
<td>从当前光标所在行删除到文件尾</td>
<td>包括当前行</td>
</tr>
<tr>
<td>dgg</td>
<td>从当前光标位置删除到文件头</td>
<td>不包括光标所在字符</td>
</tr>
<tr>
<td>dd</td>
<td>删除当前行</td>
<td>删除后光标会定位到下一行的行首</td>
</tr>
<tr>
<td>ndd</td>
<td>从当前行开始往下删除 n 行</td>
<td>包括当前行</td>
</tr>
<tr>
<td>di{</td>
<td>把光标定位在在 { 上，然后按下 di，就可以把括号内的内容删除，括号保留</td>
<td>di(，di[ 也同样</td>
</tr>
</tbody>
</table>
<blockquote>
<p>一个文本中有一个单词 pad，如果此时光标在字符 a 上，则表示当前所处位置是 a 的前面，p 的后面，所以输入 x 命令会删除字符 a，输入 X 命令会删除字符 p。如果此时进入插入模式，则新插入的内容也是在 a 的前面，p 的后面。</p>
</blockquote>
<h1 id="进入编辑模式"><a href="#进入编辑模式" class="headerlink" title="进入编辑模式"></a>进入编辑模式</h1><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>在当前光标处插入文本</td>
<td>在光标所在字符前面插入</td>
</tr>
<tr>
<td>a</td>
<td>在当前光标后面插入文本</td>
<td>在光标所在字符后面插入</td>
</tr>
<tr>
<td>I</td>
<td>在本行第一个非空字符前面插入文本</td>
</tr>
<tr>
<td>A</td>
<td>在本行最后一个字符后面插入文本</td>
</tr>
<tr>
<td>o</td>
<td>在下一行插入新行</td>
</tr>
<tr>
<td>O</td>
<td>在上一行插入新行</td>
</tr>
</tbody>
</table>
<h1 id="多选操作"><a href="#多选操作" class="headerlink" title="多选操作"></a>多选操作</h1><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>v</td>
<td>自由选择</td>
<td>进入可视状态之后，按任何移动键进行自由选择</td>
</tr>
<tr>
<td>shift+v</td>
<td>选择多行</td>
<td>进入可视状态之后，按 j k 或上下翻页键进行多行选择</td>
</tr>
<tr>
<td>ctrl+v</td>
<td>选择多列</td>
<td>进入可视状态之后，按 h l 进行多列选择，再按 j k 或翻页键选择多行</td>
</tr>
</tbody>
</table>
<h2 id="批量注释"><a href="#批量注释" class="headerlink" title="批量注释"></a>批量注释</h2><ul>
<li>第一种方法，使用 v 或 shift+v 或 ctrl+v 的任意一种，选择要注释的行之后，进入指令模式，输入 <code>normal i 注释符</code> 即可。这种方式不要求整行选择或者必须选择某一列，只要该行被选中，就会行首进行注释。  </li>
<li>第二种方法，使用 ctrl+v 进行多列选择，然后输入 i ，再输入注释符，最后按 esc 结束，就可以将选中的行进行注释。这种方式会在选中的列位置插入注释符，如果要在行首进行注释，则必须选中第一列。</li>
</ul>
<h2 id="批量取消注释"><a href="#批量取消注释" class="headerlink" title="批量取消注释"></a>批量取消注释</h2><p>按 ctrl+v 选中注释符所在列，然后选中要取消注释的列，按 d 删除注释符。这种方式其实是把注释符删掉，所以如果注释有多个的话(像//)，则必须选中所有注释符，才能完整删掉。</p>
<h2 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h2><p>选中要格式化的代码，按 = 即可。</p>
<h1 id="文件内查找"><a href="#文件内查找" class="headerlink" title="文件内查找"></a>文件内查找</h1><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>/+char</td>
<td>在一般模式下按 / 键进入指令械，然后输入要查找的字符 char，输入完成按回车键回到一般模式，这时就进入查找状态了</td>
<td>向前查找</td>
</tr>
<tr>
<td>?+char</td>
<td>同 /+char 一样</td>
<td>向后查找</td>
</tr>
<tr>
<td>shift+8</td>
<td>在一般模式下，光标定位在要查找的字符上，按下 shift+8 就可以查找这个字符</td>
<td>同 /+char 一样的功能</td>
</tr>
<tr>
<td>n</td>
<td>查找下一个</td>
<td>按定义的方向查找</td>
</tr>
<tr>
<td>N</td>
<td>查找上一个</td>
<td>按定义的方向反方向查找</td>
</tr>
</tbody>
</table>
<h1 id="文件內替換"><a href="#文件內替換" class="headerlink" title="文件內替換"></a>文件內替換</h1><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>:s/old/new</td>
<td>在一般模式下按 : 进入命令模式，然后输入 <code>s/{要替换的旧字符}/{要替换砀新字符}</code>，按回车键结束</td>
<td>只替换光标所在行的第一个匹配项</td>
</tr>
<tr>
<td>:s/old/new/g</td>
<td>同上</td>
<td>替换光标所在行的所有匹配项</td>
</tr>
<tr>
<td>:m,ns/old/new/g</td>
<td>同上，m,n 表示一个数字</td>
<td>替换第 m 行到第 n 行的所有匹配项</td>
</tr>
<tr>
<td>:%s/old/new/g</td>
<td>同上</td>
<td>替换整个文件的所有匹配项</td>
</tr>
<tr>
<td>:%s/old/new/gc</td>
<td>同上</td>
<td>替换整个文件的所有匹配项，每次匹配前由用户确认</td>
</tr>
<tr>
<td>r</td>
<td>在一般模式下按 r 删除当前光标所在字符同时进入编辑状态</td>
<td>输入一个新字符之后自动退出编辑状态，也就是 r 命令只能把单个字符替换成单个字符</td>
</tr>
<tr>
<td>R</td>
<td>在一般模式下按 R 会进入替换模式，当前光标会显示为下划线</td>
<td>每输入一个字符就会替换当前光标所在的字符，然后光标后移一位，直到按 ESC 退出编辑模式为止，如果替换到行尾，还是可以继续输入字符，则相当于变成插入模式，R 命令可以连续替换多个字符</td>
</tr>
<tr>
<td>ce</td>
<td>往后删除一个单词之后进入编辑状态</td>
<td>等价于 de + i</td>
</tr>
<tr>
<td>cw</td>
<td>同 ce</td>
<td>cw 和 ce 完全一样，也是等价于 de + i，而不是 dw + i，de 会保留单词后面的空格，dw 则会连同后面的空格一起删除</td>
</tr>
<tr>
<td>cb</td>
<td>往前删除一个单词后进入编辑状态</td>
<td>等价于 db + i</td>
</tr>
</tbody>
</table>
<h1 id="全局搜索"><a href="#全局搜索" class="headerlink" title="全局搜索"></a>全局搜索</h1><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>vim /char /% \</td>
<td>copen</td>
<td>只查找本文件</td>
<td>vim 是 vimgrep 的缩写，使用 vim 或 vimgrep 都可以，管道 copen 命令会打开一个新的分页，查找的结果显示在分页中</td>
</tr>
<tr>
<td>vim /char /* \</td>
<td>copen</td>
<td>查找本目录下的所有文件</td>
<td>使用 /* 或 /** 都可以</td>
</tr>
</tbody>
</table>
<h1 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号"></a>显示行号</h1><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>:set nu</td>
<td>在一般模式按 : 进入命令模式</td>
<td>显示行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>同上</td>
<td>隐藏行号</td>
</tr>
</tbody>
</table>
<h1 id="缓冲区跳转"><a href="#缓冲区跳转" class="headerlink" title="缓冲区跳转"></a>缓冲区跳转</h1><p>每个打开的文件都会有一个缓冲区，通过切换缓冲区可在不同文件之间切换查看。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>{:ls} or {:buffers}</td>
<td>列出所有缓冲区</td>
<td>列出缓冲区编号、文件名、当前定位行数</td>
</tr>
<tr>
<td>{:bn} or {:bnext}</td>
<td>切换到下一个缓冲区</td>
<td>含义：buffer next</td>
</tr>
<tr>
<td>{:bp} or {:bprevious}</td>
<td>切换到上一个缓冲区</td>
<td>含义：buffer previous</td>
</tr>
<tr>
<td>{:b[n]} or {:b [n]}</td>
<td>切换到指定缓冲区</td>
<td>n 为缓冲区编号</td>
</tr>
<tr>
<td>:b [exp]</td>
<td>切换到指定缓冲区</td>
<td>exp 为表达式，用于模糊匹配文件名</td>
</tr>
<tr>
<td>&lt;ctrl+^&gt;</td>
<td>切换到上一个活跃缓冲区</td>
<td>在当前缓冲区和上一个缓冲区来回切换</td>
</tr>
</tbody>
</table>
<h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><p>要查看所有缓冲区，除了使用 <code>:ls</code> 或 <code>:buffers</code> 来列出之外，还可以借助快捷键 <tab> 在跳转的时候列出所有缓冲区文件名，再次按 <tab> 可以在不同文件之间预选，当选中要跳转的文件后，按回车执行命令即可跳转到相应的缓冲区。</tab></tab></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>:b <tab></tab></td>
<td>列出缓冲区列表，再次按 <tab> 预选文件，按回车执行命令</tab></td>
<td><code>:b</code> 与 <tab> 之间要有空格</tab></td>
</tr>
<tr>
<td>:b exp<tab></tab></td>
<td>进行模糊匹配，只列出与 <code>exp</code> 匹配的文件</td>
</tr>
</tbody>
</table>
<h1 id="分屏显示"><a href="#分屏显示" class="headerlink" title="分屏显示"></a>分屏显示</h1><p>一个缓冲区对应一个文件，屏幕上只能显示一个缓冲区的内容，即只能显示一个文件；如果要同时显示多个文件，就需要分屏显示，通过把屏幕分隔成多个窗口，每个窗口显示一个缓冲区，就能做到在屏幕上同时显示多个文件。</p>
<p>水平分屏：以水平线进行分割，将屏幕分为上、中、下等多个窗口；<br>垂直分屏：以垂直线进行分割，将屏幕分为左、中、右等多个窗口。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>vim -o file1 file2</td>
<td>水平分屏打开多个文件</td>
<td>打开几个文件就开几个窗口，如果只有一个文件则不分屏</td>
</tr>
<tr>
<td>vim -O file1 file2</td>
<td>垂直分屏打开多个文件</td>
</tr>
<tr>
<td>{sp} or {split} or {new}</td>
<td>新增水平分屏，新窗口在最顶端且为当前活跃窗口</td>
<td>如果带文件名则打开该文件，否则打开当前窗口的文件，如果当前窗口也没打开文件，则新窗口也无文件</td>
</tr>
<tr>
<td>{vs} or {vsp} or {vsplit}</td>
<td>新增垂直分屏，新窗口在最左边且为当前活跃窗口</td>
<td>同水平分屏</td>
</tr>
<tr>
<td>{clo} or {close}</td>
<td>关闭当前窗口</td>
<td></td>
</tr>
<tr>
<td>&lt;ctrl+w&gt; s</td>
<td>水平分屏</td>
<td>以当前文件打开</td>
</tr>
<tr>
<td>&lt;ctrl+w&gt; v</td>
<td>垂直分屏</td>
<td>以当前文件打开</td>
</tr>
<tr>
<td>&lt;ctrl+w&gt; n</td>
<td>水平分屏</td>
<td>新窗口，无打开文件</td>
</tr>
<tr>
<td>&lt;ctrl+w&gt; q</td>
<td>关闭当前窗口</td>
</tr>
<tr>
<td>&lt;ctrl+w&gt; o</td>
<td>关闭当前窗口之外的所有窗口</td>
</tr>
</tbody>
</table>
<h1 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令"></a>外部命令</h1><p>在一般模式下输入 <code>:![cmd]</code> 即可执行外部命令，<code>:</code> 进入指令模式，<code>!</code> 表示接下来的命令是外部命令；执行成功之后会临时跳出 vim 回到终端，在终端显示执行结果，并提示 <em>请按 ENTER 或其它命令继续</em>，按下回车键或其它命令键就会回到 vim 界面。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="林锦新">
            
              <p class="site-author-name" itemprop="name">林锦新</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/linjinxin" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">林锦新</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://ljx.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
